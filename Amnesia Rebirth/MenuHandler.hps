#include "interfaces/UserModule_Interface.hps"
#include "custom/modules/ModuleInterfaces_Custom.hps"
#include "base/InputHandler_Types.hps"
#include "custom/helpers/helper_imgui_options.hps"
#include "custom/helpers/helper_modules_custom.hps"
#include "custom/helpers/helper_menu.hps"
#include "helpers/helper_imgui.hps"
#include "helpers/helper_game.hps"
#include "helpers/helper_audio.hps"
#include "helpers/helper_modules.hps"
#include "helpers/helper_effects.hps"
#include "base/AchievementHandler_Types.hps"

//---------------------------------------------------

bool mbHasMods = false;
	

enum eMainMenuButtonID
{
	eMainMenuButtonID_Continue,
	eMainMenuButtonID_NewGame,
	eMainMenuButtonID_LoadGame,
	eMainMenuButtonID_CustomStories,
	eMainMenuButtonID_Options,
	eMainMenuButtonID_ReturnToGame,
	eMainMenuButtonID_SaveAndExit,
	eMainMenuButtonID_Exit
};

enum ePreMenuPhase
{
	ePreMenuPhase_Init,
	ePreMenuPhase_None,
	ePreMenuPhase_FrictionalLogo,
	ePreMenuPhase_FmodLogo,
	ePreMenuPhase_PressToContinue,
	ePreMenuPhase_Gamma,
	ePreMenuPhase_FinalFade,
	ePreMenuPhase_Done,
	ePreMenuPhase_Welcome,
};

enum eMainMenuGroup
{
	eMainMenuGroup_Main,
	eMainMenuGroup_StartGame,
	eMainMenuGroup_LoadGame,
	eMainMenuGroup_Options,
	eMainMenuGroup_Options_Game,
	eMainMenuGroup_Options_Controls,
	eMainMenuGroup_Options_KeyboardMouse,
	eMainMenuGroup_Options_Keybind,
	eMainMenuGroup_Options_Gamepad,
	eMainMenuGroup_Options_Display,
	eMainMenuGroup_Options_Graphics,
	eMainMenuGroup_Options_Display_Gamma,
	eMainMenuGroup_Options_Audio,
	eMainMenuGroup_Options_Accessibility,
	
	//eMainMenuGroup_Options_Audio,
	eMainMenuGroup_Options_Audio_Subtitles,
	eMainMenuGroup_Options_Video,
	eMainMenuGroup_Options_Video_Display,
	eMainMenuGroup_Options_Video_PostEffect,
	eMainMenuGroup_Options_Video_World,
	eMainMenuGroup_Options_Video_Gamma,
	eMainMenuGroup_Options_Input,
	eMainMenuGroup_Options_Input_Keybind,
	eMainMenuGroup_Options_Input_Mouse,
	eMainMenuGroup_Options_Input_GamepadMapping,
	eMainMenuGroup_Options_Gameplay,
	eMainMenuGroup_Options_Debug,
	eMainMenuGroup_CustomStories,
	eMainMenuGroup_None,
	eMainMenuGroup_LastEnum,
};

enum eGraphicSettings
{
	eGraphicSettings_Low,
	eGraphicSettings_Medium,
	eGraphicSettings_High,
	eGraphicSettings_LastEnum,
};

//-----------------------------------------

const bool gbMainMenuAnimatedBgActive = true;
const bool gbMainMenuVignetteActive = true;
const float gfMainMenuVignetteAlpha = 0.6f;

//-----------------------------------------

//-------------------------------------------------------------//
// Data for menu, values based on 1280x720 resolution
//-------------------------------------------------------------//

const cVector2f kScreenCenter = cVector2f(512, 384); // Virtual size: 1024x768

const cVector2f kMainMenuButtonPos = cVector2f(250, 400);
const cVector2f kTitlePos = cVector2f(80, 25);
const cVector2f kTitleSize = cVector2f(460, 365);
const cColor kMainMenuButtonBgColor = cColor(69.0 / 255.0, 139.0 / 255.0, 139.0 / 255.0, 1);

//-----------------------------------------

const float kBaseMenuHeight = 100.f;
const float kMenuItemHeight = gfFontSize_MainMenu+4;
const cVector2f kOptionsButtonPos = cVector2f(200, 250);
const cVector2f kOptionsBgPos = cVector2f(kOptionsButtonPos.x-46, kOptionsButtonPos.y-15);
const cVector2f kOptionsBgSize = cVector2f(488, 280);
const cVector2f kOptionsBgSizePS4 = cVector2f(488, 245);

const cVector2f kOptionsVideoBgSize = cVector2f(680, kBaseMenuHeight+kMenuItemHeight*5.f);

const cVector2f kOptionsGameplayButtonPos = cVector2f(200, 250);
const cVector2f kOptionsGameplayBgPos = cVector2f(kOptionsGameplayButtonPos.x-46, kOptionsGameplayButtonPos.y-15);
const cVector2f kOptionsGameplayBgSize = cVector2f(280, 255);
const cVector2f kOptionsGameplayPS4BgSize = cVector2f(280, 255);

const cVector2f kOptionsAccessibilityBgSize = cVector2f(360, 130);

const cVector2f kOptionsControlsButtonPos = cVector2f(200, 200);
const cVector2f kOptionsControlsBgPos = cVector2f(kOptionsControlsButtonPos.x-46, kOptionsControlsButtonPos.y-15);
const cVector2f kOptionsControlsBgSize = cVector2f(280, 430);
const cVector2f kOptionsControlsPS4BgSize = cVector2f(280, 245);

const cVector2f kOptionsDisplayButtonPos = cVector2f(200, 130);
const cVector2f kOptionsDisplayBgPos = cVector2f(kOptionsDisplayButtonPos.x-46, kOptionsDisplayButtonPos.y-15);
const cVector2f kOptionsDisplayBgSize = cVector2f(280, 460);

const cVector2f kOptionsGraphicsButtonPos = cVector2f(200, 30);
const cVector2f kOptionsGraphicsBgPos = cVector2f(kOptionsGraphicsButtonPos.x-46, kOptionsGraphicsButtonPos.y-15);
const cVector2f kOptionsGraphicsBgSize = cVector2f(300, 640);

const cVector2f kOptionsAudioButtonPos = cVector2f(200, 320);
const cVector2f kOptionsAudioBgPos = cVector2f(kOptionsAudioButtonPos.x-46, kOptionsAudioButtonPos.y-15);
const cVector2f kOptionsAudioBgSize = cVector2f(300, 220);
const cVector2f kOptionsAudioBgSizePS4 = cVector2f(300, 240);

const cVector2f kOptionsSubtitlesBgSize = cVector2f(340, 328);

const cVector2f kOptionsDebugButtonPos = cVector2f(200, 90);
const cVector2f kOptionsDebugBgPos = cVector2f(kOptionsDebugButtonPos.x-46, kOptionsDebugButtonPos.y-15);
const cVector2f kOptionsDebugBgSize = cVector2f(430, 520);

const cVector2f kOptionsVideoPostEffectBgSize = cVector2f(680, kBaseMenuHeight+kMenuItemHeight*4.f);
const cVector2f kOptionsVideoWorldBgSize = cVector2f(680, kBaseMenuHeight+kMenuItemHeight*8.f);
const cVector2f kOptionsVideoDisplayBgSize = cVector2f(680, kBaseMenuHeight+kMenuItemHeight*7.f);
const cVector2f kOptionsVideoGammaBgSize = cVector2f(680, kBaseMenuHeight+kMenuItemHeight*1.f);
const cVector2f kOptionsBgBorderSize = cVector2f(680, 42.5);
const cVector2f kInputBgSize = cVector2f(680, kBaseMenuHeight+kMenuItemHeight*3.f);
const cVector2f kInputGamepadBgSize = cVector2f(680, kBaseMenuHeight+kMenuItemHeight*4.f);
const cVector2f kInputPS4BgSize = cVector2f(680, 220);
const cVector2f kKeybindWindowBgSize = cVector2f(680, 380);
const cVector2f kOptionsMappingBgSize = cVector2f(820, 370);

const cVector2f kBackMargin = cVector2f(0,20);

const cVector2f kGammaBgSize = cVector2f(680, 220);

const cVector2f kOptionMenu_KeybindBgPos = cVector2f(350, 335);
const cVector2f kOptionMenu_KeybindBgSize = cVector2f(550, 35);
const cVector2f kOptionMenu_KeybindBgBorderSize = cVector2f(550, 42.5);
const cVector2f kOptionMenu_PressXPos = cVector2f(250, 345);

//-----------------------------------------

const cVector2f kSaveSlotSpacing = cVector2f(175, 0);
const cVector2f kSaveSlotPos = cVector2f(0, 275);

//-----------------------------------------

////////////////
// LOAD GAME

const cVector2f kLoadWindowBgSize = cVector2f(680, 370);
const cVector2f kLoadBgPos = cVector2f(kOptionsBgPos.x, kOptionsBgPos.y);
const cVector2f kLoadBgSize = cVector2f(548, 352);
const cVector2f kLoadFramePos = cVector2f(kLoadBgPos.x+36, kLoadBgPos.y+30);
const cVector2f kLoadFrameSize = cVector2f(450, 279);
const cVector2f kLoadScrollPos = cVector2f(638, kLoadFramePos.y);	
const cVector2f kLoadScrollSize = cVector2f(17, kLoadFrameSize.y);	// Full size of the scroll area
const cVector2f kLoadButtonPos = cVector2f(210, 535); 				// Text outside frame cVector2f(256, 116);
const cVector2f kLoadSlotsPos = cVector2f(210, 265);				// Text inside frame
const cVector2f kLoadSlotsTimestampPos = cVector2f(kLoadFramePos.x+kLoadFrameSize.x-28, kLoadSlotsPos.y);	// Right aligned
const float kLoadSlotsFontSize = 28;
const float kLoadSlotsSpacing = 26;

//-----------------------------------------

////////////////
// KEYBINDINGS

const cVector2f kKeybindBgPos = cVector2f(kOptionsBgPos.x, kOptionsBgPos.y-128);
const cVector2f kKeybindBgSize = cVector2f(420, 520);
const cVector2f kKeybindFramePos = cVector2f(kKeybindBgPos.x+30, kKeybindBgPos.y+30);
const cVector2f kKeybindButtonPos = cVector2f(kKeybindBgPos.x+30, kKeybindBgPos.y+36);
const cVector2f kKeybindSlotsPos = cVector2f(kKeybindFramePos.x+12, kKeybindFramePos.y+12);
const float kKeybindSpacing = 32;

//-----------------------------------------

const cVector2f kMappingSize = cVector2f(768, 480);
const cVector2f kMappingSize_PS4 = cVector2f(918, 480);

const cVector2f kMappingPos = kOptionsButtonPos+cVector2f(0,-100);
const cVector2f kMappingPos_PS4 = kOptionsButtonPos+cVector2f(175,-45);

const cVector2f kGamepadPresetSize = cVector2f(640, 320);
const cVector2f kGamepadPresetSize_PS4 = cVector2f(472, 297);

const float kMappingGfxHeightMul = 0.115f;
const float kMappingGfxHeightMul_PS4 = 0.12f;

const float kMappingGamepadAlpha = 0.3f;
const float kMappingGamepadAlpha_PS4 = 0.8f;

const cVector2f kMappingArrowPosRight = cVector2f(130+130, 400-160);
const cVector2f kMappingArrowPosLeft = cVector2f(180+640+30, 400-160);

const cVector2f kMappingButtonPosRight = cVector2f(-1024+180+130, 260-160);
const cVector2f kMappingButtonPosLeft = cVector2f(180+680, 260-160);

const cVector2f kMappingArrowSize = cVector2f(32, 64);
const cVector2f kMappingButtonSize = cVector2f(1024, 320);

//-----------------------------------------

float gfContinueGameFadeOutTime = 6.f;

//-----------------------------------------

const cColor kSelectedColor = cColor(1.0 / 255.0, 1);
const cColor kDeselectedColor = cColor(1, 1);
const cColor kDisabledColor = cColor(100.0 / 255.0, 1);

//-----------------------------------------

class cBindableAction
{
	cBindableAction(){}
	cBindableAction(tString asAction, bool abAnalog = false)
	{
		msAction = asAction;
		mbAnalog = abAnalog;
	}

	tString msAction;
	bool mbAnalog;
};

//-----------------------------------------

///////////////
// MODS MENU
const cVector2f kModsBgSize = cVector2f(820, 575);
const cVector2f kModsBgPos = cVector2f(kOptionsBgPos.x - 70, kOptionsBgPos.y-210);
const float kModsSlotsSpacing = 26;
const int kMaxModsToShow = 16;

//-----------------------------------------

/////////////////////////////////////////
// Last Time Playing Screen
class cLastTimeOnGameScreen
{
	cLastTimeOnGameScreen()
	{
		CleanUp();
	}
	
	void LoadingStarted()
	{
		mbLoading_Started = true;
	}
	void Start(const tString &in asEntry)
	{
		if(IsActive()) return;
		
		msEntry = asEntry;
		if(msEntry.length()>0)
		{
			msText = cLux_Translate("LastTimeOnGameText", asEntry);
			if(msText.length()==0)
			{
				msEntry = "";
			}
			else
			{
				@mpScriptImGui = cLux_CreateScriptImGui("LastTimeOnGame", true);
				
				cImGuiGfx defPointer();
				defPointer.mColor = cColor(0.0f,0.0f);
				
				mpScriptImGui.mpImGui.SetDefaultMouse(defPointer);
				mpScriptImGui.mpImGui.SetDefaultFont(cImGuiFont("default_small.fnt", cVector2f(17) ));
				mpScriptImGui.mpImGui.SetShowMouse(false);
				
				mbFontSizeNeedsAdjust = true;
				mfFontHeight = 26.0f;
				
				cVector2f vAspect = cGraphics_GetLowLevel().GetScreenSizeFloat();
				float fAspect = vAspect.x/vAspect.y;
																  							  
				//21:9
				if (fAspect >= 2.38f && fAspect < 2.42f)
				{
					mfFontHeight = 38.0f;
				}
									
				LoadScreen_SetForceBackground(true);
				
				mpScriptImGui.mpImGui.AddTimer("Enable", 0.5f);
			}
		}
		
		if(IsActive()==false)
		{
			cLux_GetSaveHandler().ContinueLoading(true);
					
			LoadScreen_SetForceBackground(false);
			
			CleanUp();
		}
	}
	
	void CleanUp()
	{
		msText = "";
		@mpScriptImGui = null;
		
		mbLoading_Started = false;
		mbLoading_LoadHeaderDone = false;
		mbLoading_LoadGameDone = false;
		mbLoading_LoadScreenHidden = false;
		mbDismiss = false;
		LoadScreen_SetForceBackground(false);
	}
	
	bool IsActive()
	{
		return mpScriptImGui !is null;
	}
	
	void Update(float afTimeStep)
	{
		if(mbLoading_Started==false)
			return;
			
		if(mbLoading_LoadHeaderDone==false)
		{
			mbLoading_LoadHeaderDone = cLux_GetSaveHandler().IsDoneLoadingHeader();
			if(mbLoading_LoadHeaderDone)
			{
				Start(cScript_GetGlobalVarString("LastTimeOnGameText"));
			}
		}
		
		if(IsActive()==false) return;
		
		cImGui @mpImGui = mpScriptImGui.mpImGui;
		
		////////////////////////////////////////////
		// So timers and stuff work
		mpImGui.Begin(afTimeStep);
		{
			////////////////////////////////////////
			// Check flags
			if(mbLoading_LoadGameDone==false)
			{
				mbLoading_LoadGameDone = cLux_GetSaveHandler().IsDoneLoadingSavedGame();
				
				if(mbLoading_LoadGameDone)
				{
					//cLux_AddDebugMessage("Saved game is done loading - waiting for loadscreen to go");
					
					//cLux_SetGamePaused(true);
				}
			}
			else if(mbLoading_LoadScreenHidden==false)
			{
				mbLoading_LoadScreenHidden = LoadScreen_IsVisible()==false;
								
				if(mbLoading_LoadScreenHidden)
				{
					//cLux_AddDebugMessage("Loadscreen gone - prompting to continue");
					
					mpImGui.SetStateFloat("PromptAlpha", 0.0f);
					mpImGui.FadeStateFloat("PromptAlpha", 1.0f, 0.5f);
				}					
			}
			else if(mbDismiss==false)
			{
				tString sKeyPress = cLux_GetInputHandler().GetLatestKeyPressed();
				if(sKeyPress.length()!=0)
				{
					mbDismiss = true;
					
					//cLux_AddDebugMessage("Dismissing");
					
					// Start fadeout
					mpImGui.FadeStateFloat("Alpha", 0.0, 0.25f);
					
					cLux_GetSaveHandler().StartLoadedGame();
					//cLux_SetGamePaused(false);
					
					cSoundEntry @pEntry = @cSound_GetEntry("loadscreen_background");
					if(pEntry !is null)
						pEntry.FadeOut(1.0f/3.0f);
				}
			}
			
			////////////////////////////////////
			// Check timers
			if(mpImGui.TimerOver("Enable"))
			{
				mpImGui.SetStateFloat("Alpha", 0.0f);
				mpImGui.FadeStateFloat("Alpha", 1.0f, 1.0f);
				Music_StopAll(2.0f);
                Sound_Stop("MenuBGNoise",2.0f);
				cSound_PlayGuiStream("loadscreen_background", true, 0.15f, cVector3f(0,0,0), eSoundEntryType_Safe);
				//cSound_GetEntry("loadscreen_background").FadeIn(0.15f, 1.0f/3.0f);
				//Music_PlayExt("loadscreen_background", true, 0.15f, 1.0f, 3.0f, 0.0f, eMusicPrio_BgAmb, true);
			}
			
			/////////////////////////////////////
			// Check fadings
			if(mpImGui.FadeOver("Alpha"))
			{
				if(mbDismiss)
				{
					CleanUp();
					return;
				}
				else
				{
					cLux_GetSaveHandler().ContinueLoading(false);
				}
			}
			
			/////////////////////////////////////////
			// Draw the screen
			{
				float fZ = 415.0f;
				float fBGZ = 401.15f;   // 400.9f is LoadHandler black bg, 401.1f is whatever and 401.5f is brain icon
				
				float fAlpha = mpImGui.GetStateFloat("Alpha");
								
				mpImGui.SetModColorMul(cColor(1,fAlpha));
				
				// Bottom layer : black
				cImGuiGfx gfxBlack;
				gfxBlack.mColor = cColor(0,1);
				mpImGui.DoImage(gfxBlack, ImGui_FullScreenPos(10.0f), ImGui_FullScreenSize());
				
				// Bottom layer overlay: loading screen background
				cImGuiGfx gfxBG("loadscreen_backdrop.dds", eImGuiGfx_Texture);
				cVector2f vGfxBGSize = GetRatioCorrectSizeByNrmWidth(gfxBG, 1.0f);
				
				mpImGui.SetAlignment(eImGuiAlign_CenterCenter);
				mpImGui.DoImage(gfxBG, NrmPos(0.5f, 0.5f, fBGZ), vGfxBGSize);
				
				// Last time played screenshot
				cImGuiGfx gfxScreenshot(msEntry, eImGuiGfx_Texture);
				cVector3f vGfxScreenshotPos = NrmPos(0.25f, 1.0f/7.0f, fZ);
				cVector2f vGfxScreenshotSize = GetRatioCorrectSizeByNrmWidth(gfxScreenshot, 0.5f);
				
				mpImGui.SetAlignment(eImGuiAlign_TopLeft);
				mpImGui.DoImage(gfxScreenshot, vGfxScreenshotPos, vGfxScreenshotSize);
				
				// Set loading bar position
				cLux_LoadScreenSetBarPosAndSize(cVector2f(vGfxScreenshotPos.x, vGfxScreenshotPos.y + vGfxScreenshotSize.y - 4.2f), cVector2f(vGfxScreenshotSize.x, 4.2f));

				cVector3f vLinePos = vGfxScreenshotPos;
				vLinePos.y += vGfxScreenshotSize.y + 15.0f;
				
				// Text data and setup
				cImGuiTextFrameData textFrameData;
				textFrameData.mbUseBackgroundGfx = false;
				textFrameData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu, 56));
				textFrameData.mFont.mvSize = cVector2f(mfFontHeight);
				textFrameData.mFont.mColor = cColor(1,1);
				
				cVector3f vTextFramePos = vLinePos + cVector3f(15.0f,0,0);
				cVector2f vTextFrameSize(vGfxScreenshotPos.x + vGfxScreenshotSize.x - vTextFramePos.x, NrmSize(0.0f, 0.95f).y-vLinePos.y);
				
				if(mbFontSizeNeedsAdjust)
				{
					mbFontSizeNeedsAdjust = false;
					
					array<tWString> vLines;
					GetFontWordWrapRowsW(textFrameData.mFont, 1.0f, msText, vTextFrameSize.x, vLines);
					
					lNumMaxLines = int(cMath_Abs(vTextFrameSize.y/(mfFontHeight)));
					lNumLinesInText = vLines.length();
					
					if(lNumLinesInText>lNumMaxLines)
					{
						float fHeightIntervalStart = 0.0f;
						float fHeightIntervalEnd = mfFontHeight;
						float fHeightIntervalMid;
												
						while(lNumLinesInText!=lNumMaxLines)
						{
							fHeightIntervalMid = (fHeightIntervalStart+fHeightIntervalEnd)*0.5f;
							mfFontHeight = fHeightIntervalMid;
							
							textFrameData.mFont.mvSize = cVector2f(mfFontHeight);
							
							GetFontWordWrapRowsW(textFrameData.mFont, 1.0f, msText, vTextFrameSize.x, vLines);
						
							lNumMaxLines = int(cMath_Abs(vTextFrameSize.y/(mfFontHeight)));
							lNumLinesInText = vLines.length();
							
							if(lNumLinesInText<lNumMaxLines)
								fHeightIntervalStart = fHeightIntervalMid;
							else
								fHeightIntervalEnd = fHeightIntervalMid;
						}
					}
				}
				
				float fSeparation = 30.0f;
				float fLineHeight = vTextFrameSize.y*0.65f;
				
				// Vertical line
				mpImGui.SetAlignment(eImGuiAlign_TopLeft);
				mpImGui.DrawLine(cVector2f(vLinePos.x, vLinePos.y+5.0f), cVector2f(vLinePos.x, vLinePos.y + fLineHeight), fZ, 5.0f, cColor(1, fAlpha));
								
				// Text frame
				mpImGui.DoTextFrame(msText, cVector2f(0), 0, 0, textFrameData, vTextFramePos, vTextFrameSize);
				
				// PATHOS logo
				//cImGuiGfx gfxIcon("loading_pathos_logo.tga", eImGuiGfx_Texture);
				//mpImGui.SetAlignment(eImGuiAlign_TopRight);
				//mpImGui.DoImage(gfxIcon, vLinePos+cVector3f(-fSeparation,5.0f,0), GetRatioCorrectSizeByHeight(gfxIcon, fLineHeight-5.0f));
				
				if(mbLoading_LoadScreenHidden)
				{
					float fPromptAlpha = mpImGui.GetStateFloat("PromptAlpha");
					mpImGui.SetModColorMul(cColor(1,fAlpha*fPromptAlpha));
					
					cImGuiLabelData labelData;
					labelData.mFont.SetFile("sansation_medium.fnt");
					labelData.mFont.mvSize = cVector2f(28, 28);
					labelData.mFont.mColor = cColor(1,1);
					labelData.mFontAlign = eFontAlign_Center;
									
					gfxBlack.mColor.a = 0.75f;
					mpImGui.SetAlignment(eImGuiAlign_CenterCenter);
					mpImGui.DoImage(gfxBlack, NrmPos(0.5f, 0.5f, fZ+9.5f), NrmSize(1.0f, 0.0f) + cVector2f(0, labelData.mFont.mvSize.y*4.0f));
					
					mpImGui.DoLabel(cLux_Translate("LoadScreen", "PressToStart"), labelData, NrmPos(0.5f, 0.5f, fZ+10.0f));
				}
			}
		}
		mpImGui.End();
	}
	
	cVector3f NrmPos(float afX, float afY, float afZ)
	{
		cVector2f vOffset = mpScriptImGui.mpImGui.GetSet().GetVirtualSizeOffset();
		cVector2f vNrmSize = NrmSize(afX, afY);
		
		return cVector3f(vNrmSize.x-vOffset.x, vNrmSize.y-vOffset.y, afZ);
	}
	
	cVector2f NrmSize(float afX, float afY)
	{
		cVector2f vSize = mpScriptImGui.mpImGui.GetSet().GetVirtualSize();
		vSize.x *= afX;
		vSize.y *= afY;
		
		return vSize;
	}
	
	cVector2f GetRatioCorrectSizeByWidth(const cImGuiGfx &in aGfx, float afWidth)
	{
		cVector2f vGfxSize = mpScriptImGui.mpImGui.GetGfxSize(aGfx);
		if (vGfxSize.x==0)
		{
			vGfxSize.x=1;
			vGfxSize.y=1;
		}
		
		float fRatio = vGfxSize.y/vGfxSize.x;
		
		return cVector2f(afWidth, afWidth*fRatio);
	}

	cVector2f GetRatioCorrectSizeByNrmWidth(const cImGuiGfx &in aGfx, float afWidth)
	{
		return GetRatioCorrectSizeByWidth(aGfx, afWidth*mpScriptImGui.mpImGui.GetCurrentGroupSize().x);
	}

	cVector2f GetRatioCorrectSizeByHeight(const cImGuiGfx &in aGfx, float afHeight)
	{
		cVector2f vGfxSize = mpScriptImGui.mpImGui.GetGfxSize(aGfx);
		if (vGfxSize.x==0)
		{
			vGfxSize.x=1;
			vGfxSize.y=1;
		}
		
		float fRatio = vGfxSize.y/vGfxSize.x;
		
		return cVector2f(afHeight/fRatio, afHeight);
	}
	
	cLuxScriptImGui @mpScriptImGui;
	tString msEntry;
	tWString msText;
	
	bool mbFontSizeNeedsAdjust;
	float mfFontHeight;
	uint lNumMaxLines;
	uint lNumLinesInText;
		
	bool mbLoading_Started;
	bool mbLoading_LoadHeaderDone;
	bool mbLoading_LoadGameDone;
	bool mbLoading_LoadScreenHidden;
	bool mbDismiss;
};

cLastTimeOnGameScreen gLastTimeOnGameScreen;

//-----------------------------------------

bool gbFirstRun = true;
float mfMenuMusicVol = 0.35f;
float mfMenuCompMusicVol = 0.6f;

class cScrMenuHandler : iScrUserModule, iScrUserModule_Interface, iScrMenuHandler_Interface
{
	
	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// INIT
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void Init()
	{
		mBaseObj.SetScriptableIsSaved(false);
		
		////////////////////////////////////
		// Options background
		cColor topCol(0.6f, 1.0f);
		mGfxFrame.mGfxCornerTopRight = cImGuiGfx("menu_corner_tr.tga");
		mGfxFrame.mGfxBorderTop = cImGuiGfx("menu_border_top.tga");
		mGfxFrame.mGfxCornerTopLeft = cImGuiGfx("menu_corner_tl.tga");
		mGfxFrame.mGfxBorderLeft = cImGuiGfx("menu_border_left.tga");
		mGfxFrame.mGfxBorderRight = cImGuiGfx("menu_border_right.tga");
		mGfxFrame.mGfxCornerBottomLeft = cImGuiGfx("menu_corner_bl.tga");
		mGfxFrame.mGfxCornerBottomRight = cImGuiGfx("menu_corner_br.tga");
		mGfxFrame.mGfxBorderBottom = cImGuiGfx("menu_border_bottom.tga");
		mGfxFrame.mGfxBackground.mColor = cColor(5.0f/255.0f, 60.0f/255.0f, 72.0f/255.0f, 0.25f);
		
		mGfxFrame.mColorCornerTopLeft = topCol;
		mGfxFrame.mColorCornerTopRight = topCol;
	}
	
	//------------------------------------------------------------
	
	void LoadUserConfig()
	{
	}
	
	//------------------------------------------------------------
	
	void SaveUserConfig()
	{
	}
	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// INTERFACE
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void EnablePauseMenu(bool abX)
	{
		if(LoadScreen_IsVisible()) return;
	
		mbPauseMenuEnabled = abX;

		if(mbPauseMenuEnabled == false)
		{
			SetMenuActive(false);
		}
	}

	void ShowMainMenu(bool abX)
	{
		SetMenuActive(abX);
		mbMainMenuActive = abX;
		cLux_SetGamePaused(false, false, false, false);
		
		cLux_AddDebugMessage("Show menu: "+abX);

		if(abX)
		{
			Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);

			////////////////////////////////
			// Variable setup
			mbPremenuActive = (mbShowPreMenu || Platform_IsConsole()) && gbFirstRun;
			mbClearTimersNextFrame = true;

			if(mbPremenuActive)
			{
				mPreMenuPhase = ePreMenuPhase_Init;
				mlPreMenuState=0;
				mbInitPreMenu=true;
				
				mbBackgroundShowTitle = false;
				mfBackgroundTitleAlpha=0;
				
				mbMouseVisible = false;
				mbShowPressX = Platform_IsConsole();
				gbFirstRun = false;
				
				if(cLux_ScriptDebugOn())
				{
					//gbFirstRun = true;
				}
				
				mfMainAlpha =0;
			}
			else
			{
				mbBackgroundShowTitle = true;
				mfBackgroundTitleAlpha=0;

				mbMouseVisible = true;
				mbShowPressX = false;

				mfMainAlpha = 1;
			}

			if(mbShowPreMenu)
			{
				tString sLang = mpConfig.GetString("Main", "StartLanguage", cLux_GetDefaultGameLanguage());
				if((sLang == "english" || sLang == "english.lang") == false)
				{
					// TO DO: We discussed having subs on for every language
					mpConfig.SetBool("Sound", "ShowSubtitles", true);
				}
				else
				{
					// Set it to false if english
					mpConfig.SetBool("Sound", "ShowSubtitles", mpConfig.GetBool("Sound", "ShowSubtitles", false));
					
				}
			}

			mbBackgroundTitleSounds = true;
			
			/////////////
			//Music
			if(mbPauseMenuEnabled==false && mbPremenuActive==false)
			{
				//Music_PlayExt("Menu_Music", true, mfMenuMusicVol, 1.0f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
				cLux_AddTodoMessage("Sound: Menu background noise");
				Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
			}
				
						
			/////////////
			// If save files have not been checked, focus is set when that happens
			if(mbHasSaveFiles)
				msFocusNextFrame = mbCanContinue ? "Continue" : "NewGame";
		}
	}
	
	//------------------------------------------------------- 
	
	bool mbStartFocusNotSet = false;
	
	void SetMenuActive(bool abX)
	{
		cLux_SetGamePaused(abX, true, true, true);
		mbMenuActive = abX;

		if(mbMenuActive == false)
		{
			/////////////
			// Restore mouse input
			cLux_GetGuiHandler().SetGameHudInputFocus(false);
		}
		else
		{
			cLux_GetGuiHandler().SetGameHudInputFocus(true);
		}
		
		mbShowRestartWarning = false;
		mbShowApplyChanges = false;
		mbShowApplyKeyChanges = false;
		mbShowReset = false;
		mbShowExit = false;
		mbShowPlayGo = false;
		mbSaveAndExit = false;
		mbShowNewGame = false;
		mbShowLoadGame = false;
		mbShowDuplicateKeys = false;
		mbShowPressX = false;
		mbPremenuActive = false;
		mlActionToBind= 0;

		if(abX)
		{
			mbClearTimersNextFrame = true;
			msFocusNextFrame = "ReturnToGame";
		
			mlClickedPauseMenuButton = -1;
			mlClickedMainMenuButton = -1;

			mCurrentGroup = eMainMenuGroup_Main;
		}
	}
	
	//------------------------------------------------------- 
	
	bool GetMenuActive()
	{
		return mbMenuActive;
	}
	
	//------------------------------------------------------- 
		
	void GameOver()
	{
		mbGameOver = true;
		EnablePauseMenu(false);
		ShowMainMenu(true);
	}
	
	//------------------------------------------------------- 
	
	void SetMainMenuSketchbookSketch(const tString& in asSketch)
	{
		msMenuSketchbookSketch = asSketch;
		
		mpConfig.SetString("Game", "MenuSketchbookSketch", asSketch);
		mpConfig.Save();
	}
	
	//------------------------------------------------------- 
	
	void SetMainMenuGhoulPhase(int alPhase)
	{
		if (alPhase >= 10)
			mMenuGhoulPhase = eMainMenuPhase_Ghoul_VeryStrong;
		else if (alPhase >= 8)
			mMenuGhoulPhase = eMainMenuPhase_Ghoul_Strong;
		else if (alPhase >= 6)
			mMenuGhoulPhase = eMainMenuPhase_Ghoul_Medium;
		else if (alPhase >= 4)
			mMenuGhoulPhase = eMainMenuPhase_Ghoul_Mild;
		else if (alPhase >= 2)
			mMenuGhoulPhase = eMainMenuPhase_Ghoul_VeryMild;
		else
			mMenuGhoulPhase = eMainMenuPhase_Ghoul_None;
		
		if(mpConfig !is null)
		{
			mpConfig.SetInt("Game", "MenuGhoulPhase", mMenuGhoulPhase);
			mpConfig.Save();
		}
	}
	
	//------------------------------------------------------- 
	
	void SetMainMenuItemsPhase(eMainMenuPhase_Items aPhase)
	{
		mMenuItemsPhase = aPhase;
		
		mpConfig.SetInt("Game", "MenuItemsPhase", mMenuItemsPhase);
		mpConfig.Save();
	}
	
	void SetSaveLoadEnabled(bool abX)
	{
		cLux_AddDebugMessage("SetSaveLoadEnabled "+abX);
		mbSaveLoadEnabled = abX;
	}

	//------------------------------------------------------------
	
	/////////////////////////////////////////
	//MAP LOADING
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void Initiate(cLuxMap @apMap)
	{
		mbMainMenuActive = false;
		mbPauseMenuEnabled = true;
		msSelectedAudioButton = "Volume";
		msSelectedVideoButton = "Resolution";
		msSelectedInputButton = "Keybind";
		msSelectedInputMouseButton = "MouseSens";
		msSelectedInputGamepadButton = "GamepadMapping";
		msSelectedOptionsButton = "Options_Game";
		msSelectedDebugButton = "Profiler";
		msSelectedPauseMenuButton = "ReturnToGame";
		msSelectedGammaButton = "Gamma";
		msSelectedVideoWorldButton ="TextureQuality"; 
		msSelectedDisplayButton ="Resolution";
		msSelectedGraphicsButton ="Graphics";
		msSelectedGameplayButton = "Language";
		msSelectedVideoGammaButton = "Gamma";
		msFocusNextFrame = "";
	
		mfFadeOut = 0.0f;

		if(apMap.GetName() == "main_menu")
		{
			mfFadeIn = 1.0;
		}

		mbMenuActive = false;

		////////////////
		// Setup multi select options
		@mpConfig = cLux_GetUserConfig();
		@mpKeyConfig = cLux_GetKeyConfig();

		//////////////
		// Load config
		
		mbShowPreMenu = mpConfig.GetBool("Main", "ShowPreMenu", true);
		mbFirstGameStart = mpConfig.GetBool("Main", "FirstGameStart", (mbShowPreMenu) ? true : false);
		
		mMenuSketchbookPhase = eMainMenuPhase_Sketchbook(mpConfig.GetInt("Game", "MenuSketchbookPhase", eMainMenuPhase_Sketchbook_None));
		msMenuSketchbookSketch = mpConfig.GetString("Game", "MenuSketchbookSketch", "loadscreen_1aa");
		mMenuGhoulPhase = eMainMenuPhase_Ghoul(mpConfig.GetInt("Game", "MenuGhoulPhase", eMainMenuPhase_Ghoul_None));
		mMenuItemsPhase = eMainMenuPhase_Items(mpConfig.GetInt("Game", "MenuItemsPhase", eMainMenuPhase_Ghoul_None));
		
		/////////////
		// Setup resolutions
		mvResolutionValues.resize(0);
		mvResolutionSizes.resize(0);
		array<int> vBits;
		mvRefresh.resize(0);

		cSystem_GetAvailableVideoModes(mvResolutionSizes, vBits, mvRefresh, 32, 15, true);

		for(uint i = 0; i < mvResolutionSizes.size(); ++i)
		{
			mvResolutionValues.push_back(""+mvResolutionSizes[i].x + "x"+mvResolutionSizes[i].y);
		}
		

		///////////////
		// Setup custom refresh rates to pick from
		array<int> kvRefreshRates = { 15,20,30,60 }; 
		mvRefresh = kvRefreshRates;
		mvRefreshValues.resize(0);

		for(uint i = 0; i < mvRefresh.size(); ++i)
		{
			mvRefreshValues.push_back(""+mvRefresh[i] + " FPS");
		}

		if(mvLangFiles.size() == 0)
		{
			//////////////
			// Get lang files
			mvLangFiles.push_back("brazilian_portuguese");
			mvLangFiles.push_back("english");
			mvLangFiles.push_back("french");
			mvLangFiles.push_back("german");
			mvLangFiles.push_back("italian");
			mvLangFiles.push_back("russian");
			mvLangFiles.push_back("spanish");
		}

		/////////////////////
		// Actions
		array<cBindableAction> vActions = 
		{
			cBindableAction("Forward"),
			cBindableAction("Backward"),
			cBindableAction("Left"),
			cBindableAction("Right"),
			cBindableAction("Jump"),
			cBindableAction("Crouch"),
			cBindableAction("Run"),
			cBindableAction("LeanRight"),
			cBindableAction("LeanLeft"),
			cBindableAction("Interact"),
			cBindableAction("InteractCancel"),
			cBindableAction("InteractRotate"),
			cBindableAction("Flashlight"),
			cBindableAction("Match"),
			cBindableAction("Amulet"),
			cBindableAction("CheckBaby"),
			cBindableAction("Throw"),
			cBindableAction("OpenInventory"),
			cBindableAction("OpenIdeas"),
			cBindableAction("OpenNotes"),
			cBindableAction("OpenMemories"),
			cBindableAction("OpenAlys"),
			cBindableAction("ShowText")
			// Removed to make binding simpler
			//cBindableAction("Examine")
		};

		mvActions = vActions;
		
		array<cBindableAction> vGamepadActions = 
		{
			cBindableAction("GamepadMove", true),
			cBindableAction("GamepadLook", true),
			cBindableAction("Jump"),
			cBindableAction("Crouch"),
			cBindableAction("Run"),
			cBindableAction("OpenInventory"),
			cBindableAction("Interact"),
			cBindableAction("Flashlight"),
			// Removed to make binding simpler
			//cBindableAction("Examine"),
			cBindableAction("InteractCancel"),
			cBindableAction("AnalogLean"),
			cBindableAction("Throw"),
			cBindableAction("GamepadRotateUp"),
			cBindableAction("GamepadRotateDown"),
			cBindableAction("GamepadRotateLeft"),
			cBindableAction("GamepadRotateRight"),
			cBindableAction("MenuConfirm"),
			cBindableAction("MenuCancel"),
			cBindableAction("MenuUp"),
			cBindableAction("MenuDown"),
			cBindableAction("MenuLeft"),
			cBindableAction("MenuRight"),
			cBindableAction("MenuScrollUp"),
			cBindableAction("MenuScrollDown"),
			cBindableAction("GamepadBack"),
			cBindableAction("OpenMenu")
		};
		mvGamepadActions = vGamepadActions;

		mbInitiated = true;
	}

	void OnMapEnter(cLuxMap @apMap)
	{
		Initiate(apMap);
		mbSavingGame = false;
	}

	void OnMapLeave(cLuxMap @apMap)
	{
		mbPauseMenuEnabled = true;
		mbShowPressX = false;
		mbPremenuActive = false;
		mbSavingGame = false;
	}
	
	//------------------------------------------------------------
	
	void PreloadData(cLuxMap@ apMap)
	{
		//////////////////////////
		//Preload the pause menu
		
		//TO DO: Nuke unnecessary graphics
		ImGui_PreloadImage("menu_corner_tr.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("menu_border_top.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("menu_corner_tl.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("menu_border_left.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("menu_border_right.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("menu_corner_bl.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("menu_corner_br.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("menu_border_bottom.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("submenu_game.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("submenu_options.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("submenu_input.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("submenu_video.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("submenu_display.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("submenu_rendering.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("submenu_audio.tga", eImGuiGfx_Image);

		ImGui_PreloadImage("imgui_pointer_normal.tga", eImGuiGfx_Image);
		ImGui_PreloadImage("startmenu_button_long_jitter1", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_button_long_jitter2", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_button_long_jitter3", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_button_long_jitter4", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_button_long", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_options_button_long", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_options_button_meter", eImGuiGfx_Texture);
		ImGui_PreloadImage("startmenu_options_button_dropdown", eImGuiGfx_Texture);

		ImGui_PreloadImage("startmenu_options_msgbox_button_left.tga");
		ImGui_PreloadImage("startmenu_options_msgbox_button_right.tga");

		ImGui_PreloadImage("startmenu_options_button_on", eImGuiGfx_Image);
		ImGui_PreloadImage("startmenu_options_button_off", eImGuiGfx_Image);
		ImGui_PreloadImage("startmenu_options_arrow", eImGuiGfx_Image);
		
		ImGui_PreloadImage(Platform_IsConsole() ? "startmenu_button_x" : "startmenu_button_xbox_A", eImGuiGfx_Image); 
		ImGui_PreloadImage(Platform_IsConsole() ? "startmenu_button_circle" : "startmenu_button_xbox_B", eImGuiGfx_Image);
		ImGui_PreloadImage("startmenu_button_direction2", eImGuiGfx_Image);
	}
	
	void CreateWorldEntities(cLuxMap @apMap)
	{
	
	}
	void DestroyWorldEntities(cLuxMap @apMap)
	{
	
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// GENERAL
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void OnEnterContainer(const tString&in asOldContainer)
	{
	
	}
	void OnLeaveContainer(const tString&in asNewContainer)
	{
	
	}
	
	//------------------------------------------------------------
	
	void Update(float afTimeStep)
	{
	}
	
	void PostUpdate(float afTimeStep)
	{
	}
	
	void Reset()
	{
	}
	void VariableUpdate(float afDeltaTime)
	{
		
	}

	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// ACTIONS
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	void OnGui(float afTimeStep)
	{
		//cLux_AddDebugMessage("SELECTED: "+msSelectedOptionsButton);
		if(mbInitiated == false && cLux_GetCurrentMap() !is null)
		{
			Initiate(cLux_GetCurrentMap());
		}

		if(mbClearTimersNextFrame)
		{
			///////////////
			// Make sure timers arent saved
			ImGui_StopTimer("NewGame");
			ImGui_StopTimer("ExitToMainMenu");
			ImGui_StopTimer("ExitGame");

			mbClearTimersNextFrame = false;
		}
		
		///////////////////////////////////
		// Display ScriptDebug ON message, to ease confusion
		if(cLux_ScriptDebugOn() && cLux_HideDebugOutputOn()==false)
		{
			cVector3f vPos;
			vPos.x = -cLux_GetHudVirtualOffset().x;
			vPos.y = -cLux_GetHudVirtualOffset().y;
			vPos.z = 0.0f;
			vPos.z = 0;
			
			ImGui_SetTransCategory("");
			
			ImGui_GroupBegin(vPos, ImGui_GetSize());
				
			cImGuiLabelData labelData;
			labelData.mColorBase = cColor(1.0f,0.3f,1.0f);
			ImGui_DoLabelExt("ScriptDebug ON", labelData, cVector3f(5.0f,ImGui_GetSize().y-20.0f,100.0f), -1,1.0f);
			ImGui_GroupEnd();
		}

		if(cLux_GetCurrentMap() !is null)
		{
			//////////////////////////////////
			// Check for load save error
			tString sError;
			if(cLux_GetSaveHandler().HasLoadError(sError))
			{
				msLoadSaveError = sError;
				mbProfileError = false;
				LoadScreen_SetForceBackground(false);
			
				if(mbMenuActive == false) 
				{
					if(mbMainMenuActive)	ShowMainMenu(true);
					else					SetMenuActive(true);
				}

				if(msLoadSaveError == "NoSpace") msLoadSaveError = ""; //solved on a OS level
				if(msLoadSaveError == "PlayGo")
				{
					mbShowPlayGo = true;
					msLoadSaveError = "";
				}
			}

			if(cLux_HasConfigLoadError(sError))
			{
				msLoadSaveError = sError;
				mbProfileError = true;
			
				if(mbMenuActive == false) 
				{
					if(mbMainMenuActive)	ShowMainMenu(true);
					else					SetMenuActive(true);
				}
			}
		}
		
		//////////////////////////////////////
		// Last time playing screen handling
		gLastTimeOnGameScreen.Update(afTimeStep);
		
		if(gLastTimeOnGameScreen.IsActive() || mbMenuActive == false) 
			return;

		if(mbMainMenuActive && mbHasSaveFiles == false)
		{
			/////////////
			// Save files
			if(cLux_GetSaveHandler().GetSaveFiles(mvSaveNames, mvSaveDates, mvSaveFiles))
			{
				mbHasSaveFiles = true;
				mbCanContinue = mvSaveFiles.size() > 0;
				
				// Set focus here
				msFocusNextFrame = mbCanContinue ? "Continue" : "NewGame";
				
				if(mbCanContinue)
				{
					msContinueFile = mvSaveFiles[0]; 

					///////////
					// Remove "CheckPoint" from save file list
					for(uint i = 0; i < mvSaveFiles.size(); ++i)
					{
						if(mvSaveNames[i] == tWString("CheckPoint"))
						{
							for(uint j = i + 1; j < mvSaveFiles.size(); ++j)
							{
								mvSaveFiles[j-1] = mvSaveFiles[j];
								mvSaveDates[j-1] = mvSaveDates[j];
								mvSaveNames[j-1] = mvSaveNames[j];	
							}
						
							mvSaveFiles.resize(mvSaveFiles.size()-1);
							mvSaveDates.resize(mvSaveDates.size()-1);
							mvSaveNames.resize(mvSaveNames.size()-1);

							break;
						}
					}
				}
			}
			else
			{
				// Don't let menu continue until saves have been checked
				//cLux_AddDebugMessage("Saves not retrieved yet...");
				return;
			}
		}
		
		
		//////////////////////////////////
		// Main alpha
		if(mbPremenuActive)
			mfMainAlpha = cMath_IncreaseTo(mfMainAlpha, afTimeStep*0.5f, 0.0f);
		else
			mfMainAlpha = cMath_IncreaseTo(mfMainAlpha, afTimeStep*0.5f, 1.0f);

		/////////////////////////////////////
		//Renders a in game mouse pointer.
		cImGuiGfx mouseGfx("imgui_pointer_normal.tga");
		mouseGfx.mColor = cColor_White;
		if(ImGui_GetMouseVisible() && mbMouseVisible)
			ImGui_DoMouse(mouseGfx, cVector3f_Zero, cVector2f(27, 36));
		
		/////////////////////////////////////
		//Setup Properties
		cGuiSet@ pSet = cLux_GetCurrentImGui().GetSet();
		mvSize = pSet.GetVirtualSize();
		mvOffset = pSet.GetVirtualSizeOffset();
		mvAspectRatio = cGraphics_GetLowLevel().GetScreenSizeFloat();
		mvAspectRatio /= mvAspectRatio.y;
		mlActionHorizontal = 0;
				
		ImGui_SetTransCategory("Menu");

		@mpConfig = cLux_GetUserConfig();
		@mpKeyConfig = cLux_GetKeyConfig();
		
		if (mbPauseSoundDelay)
		{
			ImGui_AddTimer("PauseSfx", 0.05f);
			mbPauseSoundDelay = false;
		}
		
		if(ImGui_TimerOver("PauseSfx")) 
		{
			Sound_PlayGui("special_fx/frontend/pause", 1.0f, eSoundEntryType_Gui);
		}
			
		
		
		/////////////////////////////////////
		//Set frame focus
		if(msFocusNextFrame != "")
		{
			//////////
			// Setup focus when changing groups
			ImGui_SetFocus(msFocusNextFrame);
			msFocusNextFrame = "";
		}
		
		/////////////////////////////////////
		// MainMenu-Button Press Check
		if(mbMenuButtonPressed && mbPremenuActive == false && mbShowPressX == false)
		{
			mbMenuButtonPressed = false;
			if(mCurrentGroup == eMainMenuGroup_Main && ((mbShowApplyChanges || mbShowApplyKeyChanges || mbShowDuplicateKeys || mbShowReset ||  mbShowRestartWarning || mbShowExit || mbShowPlayGo || mbShowNewGame || mbShowLoadGame|| mbShowSelectedModDialog || mfKeepDisplaySetting > 0 || mlActionToBind > 0) == false))
			{
				if(mbMainMenuActive == false)
				{
					/////////////
					// Disable menu
					SetMenuActive(false);
					return;
				}
				else
				{
					////////////
					// Show exit menu
					//mlClickedMainMenuButton = 4;
					//ImGui_AddTimer("ButtonClicked", 0.15);
					//cLux_AddTodoMessage("Sound: Menu main button pressed");
				}
			}
			else
			{
				//////////////
				// Map menu button to back button
				cLux_GetCurrentImGui().SendAction(eImGuiAction_Cancel, true, true);
			}
		}
		mbMenuButtonPressed = false;
		
		
		//////////////////////////////////////////////
		// Message box
		if(	mbShowApplyChanges || mbShowDuplicateKeys || 
			mbShowApplyKeyChanges || mbShowReset || 
			mbShowRestartWarning || mbShowExit || mbShowPlayGo ||
			mbShowNewGame || mbShowLoadGame || mbShowSelectedModDialog ||
			mbShowDetectSettings ||
			mfKeepDisplaySetting > 0 || mlActionToBind > 0 || 
			(msLoadSaveError.length() > 0 && mbPremenuActive == false))
		{
			////////////////
			// Display message box and disable input for any other widgets
			ShowMessageBoxes();
			ImGui_SetModUseInput(false); 
		}
		///////////////
		// Catch left and right input
		else
		{
			float fStartingTimer = 0.35f;
			float fFinalTimer = 0.25;
			float fTimerReductionFactor = 0.8f;
			
			{
				if(ImGui_ActionTriggered(eImGuiAction_Right, true))
				{
					mlActionHorizontal++;
					
					ImGui_SetStateFloat("HoriPressTimer", fStartingTimer);
					ImGui_AddTimer("RightPressed", fStartingTimer);
				}
							
				if(ImGui_ActionTriggered(eImGuiAction_Left, true))
				{
					mlActionHorizontal--;
					
					ImGui_SetStateFloat("HoriPressTimer", fStartingTimer);
					ImGui_AddTimer("LeftPressed", fStartingTimer);
				}
			}
			
			if(ImGui_TimerExists("RightPressed"))
			{
				if(ImGui_ActionIsDown(eImGuiAction_Right)==false)
				{
					ImGui_StopTimer("RightPressed");
				}
				else
				{
					if(ImGui_TimerOver("RightPressed"))
					{
						mlActionHorizontal++;
						
						float fTimer = ImGui_GetStateFloat("HoriPressTimer");
						fTimer *= fTimerReductionFactor;
						if(fTimer<fFinalTimer)
							fTimer = fFinalTimer;

						ImGui_SetStateFloat("HoriPressTimer", fTimer);
						ImGui_AddTimer("RightPressed", fTimer);
					}
				}
			}
			
			if(ImGui_TimerExists("LeftPressed"))
			{
				if(ImGui_ActionIsDown(eImGuiAction_Left)==false)
					ImGui_StopTimer("LeftPressed");
				else
				{
					if(ImGui_TimerOver("LeftPressed"))
					{
						mlActionHorizontal--;
						
						float fTimer = ImGui_GetStateFloat("HoriPressTimer");
						fTimer *= fTimerReductionFactor;
						if(fTimer<fFinalTimer)
							fTimer = fFinalTimer;

						ImGui_SetStateFloat("HoriPressTimer", fTimer);
						
						ImGui_AddTimer("LeftPressed", fTimer);
					}
				}
			}
			
			ImGui_SetModUseInput(true); 
		}

		///////////////
		// Applying key config might cause actions to fire again, so ignore them
		if(mlIgnoreInput > 0)
		{
			mlIgnoreInput--;
			ImGui_SetModUseInput(false);
			ImGui_ActionTriggered(eImGuiAction_Cancel, true);
		}

		/////////////
		// Draw & Update Background
		GuiBackground(afTimeStep);
		
		/////////////
		// Fade screen and execute action
		if(	ImGui_TimerExists("NewGame") || 
			ImGui_TimerExists("Continue") ||
			ImGui_TimerExists("LoadGame") ||
			ImGui_TimerExists("ExitToMainMenu") ||
			ImGui_TimerExists("ExitGame"))
		{
			/////////////
			// Fade to black
			if(ImGui_TimerExists("ExitGame"))
				mfFadeOut += afTimeStep / mfExitGameFadeLength;
			else
				mfFadeOut += afTimeStep / mfFadeLength;
			
			if(mfFadeOut>1) mfFadeOut=1;
				
			cImGuiGfx gfx;
			ImGui_DrawGfx(gfx, ImGui_FullScreenPos(40.0), ImGui_FullScreenSize(), cColor(0, mfFadeOut));
			ImGui_SetModUseInput(false); 

			///////////////////////////
			// Action: New Game
			if(ImGui_TimerOver("NewGame"))
			{
				ImGui_StopTimer("NewGame");
				mbWelcomeScreen = true;
				//SetMenuActive(false);
				//mbGameOver = false;
				//msPreviousSaveLoaded = "";
				//StartNewGame();
				
				return;
			}
			
			///////////////////////////
			// Action: Continue
			if(ImGui_TimerOver("Continue"))
			{
				ImGui_StopTimer("Continue");
				StartSavedGameLoad(msContinueFile);
				
				return;
			}

			///////////////////////////
			// Action: Load Game
			if(ImGui_TimerOver("LoadGame"))
			{
				ImGui_StopTimer("LoadGame");
				StartSavedGameLoad(mvSaveFiles[mlSaveFileToLoad]);
								
				return;
			}
			
			///////////////////////////
			// Action: Exit To Main menu
			if(ImGui_TimerOver("ExitToMainMenu"))
			{
				ImGui_StopTimer("ExitToMainMenu");
				mbGameOver = false;
				cLux_GetEffectHandler().FadeOut(0.0);
				
				cLux_StartMap(cLux_GetMainMenuFile());
				msPreviousSaveLoaded = "";

				SetMenuActive(false);
								
				return;
			}
			
			if(ImGui_TimerOver("ExitGame"))
			{
				ImGui_StopTimer("ExitGame");
				mbGameOver = false;
				cLux_GetEffectHandler().FadeOut(0.0);
				SetMenuActive(false);
				cLux_Exit();
				
				return;
			}
		}
		/////////////
		// Set focus back to this set!
		else
		{
			if(cLux_GetGuiHandler().GetGameHudInputFocus() == false)
			{
				cLux_GetGuiHandler().SetGameHudInputFocus(true);
			}
		}
		
		/////////////
		// Fade to black
		if(mfFadeIn > 0.0f)
		{
			mfFadeIn -= afTimeStep / mfFadeLength;
			cImGuiGfx gfx;
			ImGui_DrawGfx(gfx, ImGui_FullScreenPos(40.0), ImGui_FullScreenSize(), cColor(0, mfFadeIn));
		}
		
		if(mbPremenuActive==false)
			OptionMenu_SetModColor(cColor(1, mfMainAlpha));
			
		//cLux_AddDebugMessage("TARGET: "+mTargetGroup+" CURR: "+mCurrentGroup);
		/////////////////////
		// Do title fading and parallax
		switch(mTargetGroup)
		{
			case eMainMenuGroup_Main:
			{
				if (mbPremenuActive == false || mPreMenuPhase == ePreMenuPhase_FinalFade)
					mbBackgroundShowTitle = true;
				mbParallax = false; break;
			}
			case eMainMenuGroup_StartGame:
			case eMainMenuGroup_LoadGame:
			case eMainMenuGroup_Options:
			{
				mbBackgroundShowTitle = false;
				mbParallax = true; break;
			}
			case eMainMenuGroup_CustomStories:
			{
				mbParallax = true; break;
			}
		}
		
		/////////////
		// Draw current state
		switch(mCurrentGroup)
		{
			////////////////
			// Main menu
			case eMainMenuGroup_Main:
			{
				if(mbMainMenuActive)
				{
					////////////
					// Gamma correction pre menu
					if(mbPremenuActive) 
					{
						GuiPreMenu(afTimeStep);
					}
					else if (mbWelcomeScreen)
					{
						GuiWelcomeMessages();
					}
					/////////////
					// Main menu
					else {
						GuiMainMenuSelection();
					}
				}
				////////////////
				// Pause menu
				else
				{
					GuiPauseMenuSelection();
				}
				break;
			}
			//////////////
			// StartGame
			case eMainMenuGroup_StartGame:
			{
				GuiStartGame(); break;
			}
			//////////////
			// LoadGame
			case eMainMenuGroup_LoadGame:
			{
				GuiLoadGame(); break;
			}
			//////////////
			// Options
			case eMainMenuGroup_Options:
			{
				//ImGui_AddTimer("TransitionOut", 1);
				GuiOptions(); break;
			}
			//////////////
			// Options - Game
			case eMainMenuGroup_Options_Game:
			{
				//ImGui_AddTimer("TransitionOut", 1);
				GuiOptionsGameplay(); break;
			}
			//////////////
			// Options - Controls
			case eMainMenuGroup_Options_Controls:
			{
				GuiOptionsControls(); break;
			}
			//////////////
			// Keybind
			case eMainMenuGroup_Options_Keybind:
			{
				GuiOptionsInputKeybind(); break;
			}
			//////////////
			// Options - Display
			case eMainMenuGroup_Options_Display:
			{
				GuiOptionsDisplay(); break;
			}
			//////////////
			// Options - Graphics
			case eMainMenuGroup_Options_Graphics:
			{
				GuiOptionsGraphics(); break;
			}
			//////////////
			// Options - Gamma
			case eMainMenuGroup_Options_Display_Gamma:
			{
				GuiOptionsGamma(/*mbPauseMenuEnabled*/); break;
			}
			//////////////
			// Options - Audio
			case eMainMenuGroup_Options_Audio:
			{
				GuiOptionsAudio(); break;
			}
			//////////////
			// Options - Accessibility
			case eMainMenuGroup_Options_Accessibility:
			{
				GuiOptionsAccessibility(); break;
			}			
			//////////////
			// Keybind
			case eMainMenuGroup_Options_Input_Keybind:
			{
				GuiOptionsInputKeybind(); break;
			}
			//////////////
			// Mouse input Options
			case eMainMenuGroup_Options_Input_Mouse:
			{
				//GuiOptionsInputMouse(); break;
			}			
			//////////////
			// Gamepad mapping
			case eMainMenuGroup_Options_Input_GamepadMapping:
			{
				GuiOptionsInputGamepadPresets(); break;
			}
			//////////////
			// Gameplay Options
			case eMainMenuGroup_Options_Gameplay:
			{
				GuiOptionsGameplay(); break;
			}
			//////////////
			// Gamma Video Options
			case eMainMenuGroup_Options_Video_Gamma:
			{					
				GuiOptionsGamma(/*mbPauseMenuEnabled*/); break;
			}
			//////////////
			// Subtitle Options
			case eMainMenuGroup_Options_Audio_Subtitles:
			{
				GuiOptionsSubtitles(); break;
			}
			//////////////
			// Debug Options
			case eMainMenuGroup_Options_Debug:
			{
				GuiOptionsDebug(); break;
			}
			////////////////
			// Custom Stories
			case eMainMenuGroup_CustomStories:
			{
				GuiCustomStories();break;
			}
		}
		
		OptionMenu_SetModColor(cColor(1, 1));
		OptionMenu_ResetExtraWidth();
		
		ImGui_SetTransCategory("");
	}
	
	//-------------------------------------------------------
	
	void StartNewGame()
	{
		SetMenuActive(false);
		mbGameOver = false;
		mbWelcomeScreen = false;
		msPreviousSaveLoaded = "";
		
		MainMenu_SetPhase_Items(eMainMenuPhase_Items_None);
		MainMenu_Sketchbook_SetSketch("loadscreen_1aa");
		MainMenu_SetPhase_Ghoul(0);
		Game_ResetPlaytime();
		cLux_StartNewGame();
	}
	
	//-------------------------------------------------------
	
	void StartSavedGameLoad(const tWString &in asFile)
	{
		mbGameOver = false;
		cLux_GetSaveHandler().DelayedLoadGameFromFile(asFile, "", "", true, true);
		msPreviousSaveLoaded = asFile;
		LoadScreen_SetForceBackground(true);
		SetMenuActive(false);
		
		gLastTimeOnGameScreen.LoadingStarted();
		
		//gbMainMenuLoadingSavedGameStarted = true;
		//gbMainMenuLoadingSavedGame_LoadHeaderDone = false;
		//gbMainMenuLoadingSavedGameDone = false;
	}
	
	//------------------------------------------------------

	bool mbShowingGammaMenu = false;
	
	bool mbParallax = false;
	float mfParallaxEasingValue = 0;
	float mfOffsetFgH = 0;
	float mfOffsetBgH = 0;
	float mfIdleOffsetFgH = 0;
	float mfIdleOffsetFgV = 0;
	float mfIdleOffsetBgH = 0;
	float mfIdleOffsetBgV = 0;
	
	float mfEasingValue = 0;
	float mfBgScaleEasingValue = 0;
	
	//float mfRaysAlpha = 0.9f;
	
	cVector2f vMouseEasing(0,0);
	cVector2f vTempMousePos(0,0);
	cVector2f vSketchOffset(0,0);
	
	float mfTime = 0;
	float mfBgScaleMul = 1.f;
	
	array<cVector2f> mvMousePositions;
	bool mbParallaxWait = false;
	
	void BackgroundParallax(float afTimeStep)
	{
		mfTime += afTimeStep;
		
		//mfRaysAlpha = 0.8f+cMath_Sin(0.5*mfTime+5)/5;
		
		mfIdleOffsetFgH = cMath_Sin(mfTime+10);
		mfIdleOffsetFgV = 2*cMath_Sin(mfTime/2);
		
		mfIdleOffsetBgH = cMath_Sin(mfTime+10);
		mfIdleOffsetBgV = 2*cMath_Sin(mfTime/2);
		
		
		
		mfIdleOffsetFgH -= (ImGui_GetMousePosition().x-kScreenCenter.x)*0.005;
		mfIdleOffsetFgV -= (ImGui_GetMousePosition().y-kScreenCenter.y)*0.004;
		
		mfIdleOffsetBgH += (ImGui_GetMousePosition().x-kScreenCenter.x)*0.0002;
		mfIdleOffsetBgV += (ImGui_GetMousePosition().y-kScreenCenter.y)*0.0002;
		
		///////////////////
		// Transition to Submenu
		if (mbParallax)
		{
			mfEasingValue = cMath_IncreaseTo(mfEasingValue,0.007f,1);
			mfBgScaleEasingValue = cMath_IncreaseTo(mfBgScaleEasingValue,0.015f,1);
			
			// Add position offset needed when zooming the background
			vSketchOffset.x = cMath_Easing(eEasing_SineInOut, mfBgScaleEasingValue, 0, 6);
			vSketchOffset.y = cMath_Easing(eEasing_SineInOut, mfBgScaleEasingValue, 0, 3);
			
			mfBgScaleMul = cMath_Easing(eEasing_SineInOut, mfBgScaleEasingValue, 1, 1.3f);
			mfOffsetFgH = cMath_Easing(eEasing_SineInOut, mfBgScaleEasingValue, 0, 15.f);
			mfOffsetBgH = cMath_Easing(eEasing_SineInOut, mfEasingValue, 0, -5.f);
		}
		else
		{
			mfEasingValue = cMath_IncreaseTo(mfEasingValue,0.005f,0);
			mfBgScaleEasingValue = cMath_IncreaseTo(mfBgScaleEasingValue,0.015f,0);
			
			// Add position offset needed when zooming the background
			vSketchOffset.x = cMath_Easing(eEasing_SineInOut, mfBgScaleEasingValue, 0, 6);
			vSketchOffset.y = cMath_Easing(eEasing_SineInOut, mfBgScaleEasingValue, 0, 3);
			
			mfBgScaleMul = cMath_Easing(eEasing_SineInOut, mfBgScaleEasingValue, 1, 1.3f);
			mfOffsetFgH = cMath_Easing(eEasing_SineInOut, mfBgScaleEasingValue, 0, 15.f);
			mfOffsetBgH = cMath_Easing(eEasing_SineInOut, mfEasingValue, 0.f, -5.f);
		}

	}
	
	//------------------------------------------------------- 
	
	float mfAlphaEasingValue = 0;
	
	eMainMenuPhase_Sketchbook mMenuSketchbookPhase = eMainMenuPhase_Sketchbook_None;
	tString msMenuSketchbookSketch = "";
	eMainMenuPhase_Ghoul mMenuGhoulPhase = eMainMenuPhase_Ghoul_None;
	eMainMenuPhase_Items mMenuItemsPhase = eMainMenuPhase_Items_None;
	
	void GuiBackground(float afTimeStep)
	{
		cVector2f vScaledSize = cVector2f(2000,768);	// Image scale locked on virtual hud height (3640x1540) (correct calculation should be 1815 :S)
		cVector2f vOuterOffset = cVector2f(200,50);		// Area the image is drawn outside of screen (200x100) - A BIT OF A MAGIC NUMBER
		cVector2f vSize = vScaledSize+vOuterOffset*mfBgScaleMul;
		
		cVector3f vBgCenter = cVector3f(kScreenCenter.x+mfOffsetBgH+mfIdleOffsetBgH,kScreenCenter.y+mfIdleOffsetBgV,0);
		cVector3f vFgCenter = cVector3f(kScreenCenter.x+mfOffsetFgH+mfIdleOffsetFgH,kScreenCenter.y+mfIdleOffsetFgV,0);
		
		BackgroundParallax(afTimeStep);
		
		if(mbMainMenuActive)
		{
			//////////////
			// Background 
			cImGuiGfx gfxBkg("menu_bg_uw_background.png", eImGuiGfx_Texture);
			ImGui_DrawAlignedGfx(gfxBkg, cVector3f(vBgCenter.x,vBgCenter.y,-10), eImGuiAlign_CenterCenter,vSize);
			
			/////////////
			// Light rays
			const float fRayMaxBrightness = 1;
			
			cImGuiGfx gfxRay_1("bg_light_ray_1.png", eImGuiGfx_Texture);
			const float fOscTime1 = ImGui_FadeOscillateFloat("OscillationTime1", 2, 10, 1);
			gfxRay_1.mColor = cColor(1, ImGui_FadeOscillateFloat("light_ray_1", 0, fRayMaxBrightness, fOscTime1));
			ImGui_DrawAlignedGfx(gfxRay_1, cVector3f(vBgCenter.x,vBgCenter.y,-8.f), eImGuiAlign_CenterCenter,vSize);
			
			cImGuiGfx gfxRay_2("bg_light_ray_2.png", eImGuiGfx_Texture);
			const float fOscTime2 = ImGui_FadeOscillateFloat("OscillationTime2", 2, 10, 2);
			gfxRay_2.mColor = cColor(1, ImGui_FadeOscillateFloat("light_ray_2", fRayMaxBrightness, 0, fOscTime2));
			ImGui_DrawAlignedGfx(gfxRay_2, cVector3f(vBgCenter.x,vBgCenter.y,-8.f), eImGuiAlign_CenterCenter,vSize);
			
			cImGuiGfx gfxRay_3("bg_light_ray_3.png", eImGuiGfx_Texture);
			const float fOscTime3 = ImGui_FadeOscillateFloat("OscillationTime3", 2, 10, 3);
			gfxRay_3.mColor = cColor(1, ImGui_FadeOscillateFloat("light_ray_3", 0, fRayMaxBrightness, fOscTime3));
			ImGui_DrawAlignedGfx(gfxRay_3, cVector3f(vBgCenter.x,vBgCenter.y,-8.f), eImGuiAlign_CenterCenter,vSize);
			
			/////////////
			// Foreground
			cImGuiGfx gfxFg("menu_bg_uw_foreground.png", eImGuiGfx_Texture);
			ImGui_DrawAlignedGfx(gfxFg, cVector3f(vFgCenter.x,vFgCenter.y,-6.f), eImGuiAlign_CenterCenter,vSize);
						
			///////////////////
			// Sketchbook
			tString sImage = msMenuSketchbookSketch+"_slant.dds";
			cImGuiGfx gfxTestSketch(sImage, eImGuiGfx_Texture);
			gfxTestSketch.mMaterial = eGuiMaterial_Modulative;
			cVector2f vMySize = vSize*(cVector2f(0.32,0.53));
			ImGui_DrawAlignedGfx(gfxTestSketch, cVector3f(vFgCenter.x+250+vSketchOffset.x,vFgCenter.y+160+vSketchOffset.y,-5.f), eImGuiAlign_CenterCenter, vMySize, cColor(1.0f,1.0f,1.0f,0.75f));
			
			////////////////////////
			// Skethcbook sand cover
			cImGuiGfx gfxFgSandCover("sandedge_cover", eImGuiGfx_Texture);
			ImGui_DrawAlignedGfx(gfxFgSandCover, cVector3f(vFgCenter.x,vFgCenter.y,-4.5f), eImGuiAlign_CenterCenter,vSize);
			
			/////////////////////
			// Ghoul Progression
			if (mMenuGhoulPhase > eMainMenuPhase_Ghoul_None)
			{
				// Ghoul elements are additive
				for (int i = 1; i <= mMenuGhoulPhase; i++)
				{
					cImGuiGfx gfxGhoul("menu_bg_uw_ghoul"+i+".png", eImGuiGfx_Texture);
					ImGui_DrawAlignedGfx(gfxGhoul, cVector3f(vFgCenter.x,vFgCenter.y,-4.f), eImGuiAlign_CenterCenter,vSize);
					//ImGui_DrawGfx(gfxGhoul, ImGui_FullScreenPos(-1.0), ImGui_FullScreenSize());
				}
			}
			
			/////////////
			// Items
			if (mMenuItemsPhase > eMainMenuPhase_Items_None)
			{
				cImGuiGfx gfxMonkey("menu_bg_uw_monkey.png", eImGuiGfx_Texture);
				ImGui_DrawAlignedGfx(gfxMonkey, cVector3f(vFgCenter.x,vFgCenter.y,-3.f), eImGuiAlign_CenterCenter,vSize);
				
				if (mMenuItemsPhase == eMainMenuPhase_Items_DollRing)
				{
					cImGuiGfx gfxRing("menu_bg_uw_ring.png", eImGuiGfx_Texture);
					ImGui_DrawAlignedGfx(gfxRing, cVector3f(vFgCenter.x,vFgCenter.y,-2.f), eImGuiAlign_CenterCenter,vSize);
				}
			}
			
			//////////////////////
			// Animated texture graphics
			if (gbMainMenuAnimatedBgActive)
			{
				cImGuiGfx gfxBkgAnimated("menu_effect_001.dds", eImGuiGfx_TextureAnimated);
				gfxBkgAnimated.mfAnimationTime = 1.f / 30.f;
				ImGui_DrawAlignedGfx(gfxBkgAnimated, cVector3f(vBgCenter.x,vBgCenter.y, -1.5), eImGuiAlign_CenterCenter,vSize);
			}
			
			////////////
			// Vignette
			if (gbMainMenuVignetteActive)
			{
				cImGuiGfx GfFgVignette("vignette_alpha", eImGuiGfx_Texture);
				GfFgVignette.mColor = cColor(1, gfMainMenuVignetteAlpha);
				ImGui_DoImage(GfFgVignette, ImGui_FullScreenPos(1.0f), ImGui_FullScreenSize());
			}
			
			//////////////////////////////////////
			// Title alpha
			if(mbBackgroundShowTitle)
			{
				mfAlphaEasingValue = cMath_IncreaseTo(mfAlphaEasingValue,0.007f,1);
				mfBackgroundTitleAlpha = cMath_Easing(eEasing_SineInOut, mfAlphaEasingValue, 0, 1);
			}
			else
			{
				mfAlphaEasingValue = cMath_IncreaseTo(mfAlphaEasingValue,0.007f,0);
				mfBackgroundTitleAlpha = cMath_Easing(eEasing_SineInOut, mfAlphaEasingValue, 0, 1);
			}
			
			/////////////////////////////////////
			//Title
			if(mfBackgroundTitleAlpha>0)
			{
				cImGuiGfx gfxMainTitle("startmenu_title_small.png", eImGuiGfx_Texture);
				cColor colorMul1(1, mfBackgroundTitleAlpha);
				cColor titleCol1 = ImGui_GetStateColor("TitleColor", cColor(1.0, 1.0));	
				ImGui_DrawGfx(gfxMainTitle, OptionMenu_GetTopLeftOffset(kTitlePos, -20), OptionMenu_GetScaledSize(kTitleSize), titleCol1*colorMul1);
			}
		}
		else if(mCurrentGroup!=eMainMenuGroup_Options_Video_Gamma)
		{
			/////////////////////////////////////
			// Background when Paused
			cImGuiGfx gfx;
			//ImGui_DrawGfx(gfx, ImGui_FullScreenPos-1.0), ImGui_FullScreenSize(), cColor(0.1,0.1,0.1, 0.85));
		}
	}
	
	

	//-------------------------------------------------------
	
	void ClickNewGame()
	{
		//New game sting
		cLux_AddTodoMessage("Sound: New game stinger");
		//Sound_PlayGui("special_fx/frontend/new_game_sting", 1.0f, eSoundEntryType_Gui);
        Sound_Stop("MenuBGNoise", mfFadeLength);
		
		// No continue or load button, no need to confirm
		ImGui_AddTimer("NewGame", gfContinueGameFadeOutTime + 0.5);
		cSound_FadeOutAll(eSoundEntryType_WorldAll, 1.0f / (gfContinueGameFadeOutTime), false);
		
		//Fade out music quickly to stop the new game stinger from being out of key with the music
		Music_StopAll(1.0f);
		
		Sound_PlayGui("special_fx/frontend/new_game_sting", 1.0f, eSoundEntryType_Gui);
		
		cLux_GetGuiHandler().SetGameHudInputFocus(false);
		mbShowNewGame = false;
		mbBackgroundTitleSounds = false;
	}
	
	//-------------------------------------------------------
	
	eMainMenuGroup mTargetGroup;
	tString msTargetFocus;

	void GuiMainMenuSelection()
	{				
		int lEntryPos = 0;
		cImGuiLabelData disabledLabelData;
		disabledLabelData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu, 72));
		disabledLabelData.mFont.mvSize = cVector2f(36, 36);
		disabledLabelData.mFont.mColor = cColor(kDisabledColor.r,kDisabledColor.g,kDisabledColor.b,mfTransitionAlpha/2);
		
		/////////////////
		// Continue 
		if (mbSaveLoadEnabled == false)
		{
		}
		else
		{
			if(mbCanContinue && !mbGameOver)
			{
				if(OptionMenu_MainMenuButton("Continue", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_Continue, msSelectedMainMenuButton, mlClickedMainMenuButton, mfTransitionAlpha))
				{
					mlClickedMainMenuButton = eMainMenuButtonID_Continue;
					Sound_Stop("MenuBGNoise", 2.0f);
					Music_StopAll(2.0f);
					Sound_PlayGui("special_fx/frontend/new_game_sting", 1.0f, eSoundEntryType_Gui);
				}
					
				msSelectedMainMenuButton = OptionMenu_UpdateFocus("Continue", msSelectedMainMenuButton);
			}
			else
			{
				//////////////
				// Not possible to continue, disable it and render it as a label instead
				OptionMenu_MainMenuDisabledButton("Continue", kMainMenuButtonPos, lEntryPos, disabledLabelData);
			}
					
			++lEntryPos;
		}
		
		/////////////////
		// New Game 
		{
			if(OptionMenu_MainMenuButton("NewGame", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_NewGame, msSelectedMainMenuButton, mlClickedMainMenuButton, mfTransitionAlpha))
			{
				mlClickedMainMenuButton = eMainMenuButtonID_NewGame;
			}
			
			msSelectedMainMenuButton = OptionMenu_UpdateFocus("NewGame", msSelectedMainMenuButton);
			
			++lEntryPos;
		}
		
		/////////////////
		// Load Game 
		if (mbSaveLoadEnabled == false)
		{
		}
		else
		{
			if(mbCanContinue && mvSaveFiles.size() > 0)
			{
				if(OptionMenu_MainMenuButton("LoadGame", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_LoadGame, msSelectedMainMenuButton, mlClickedMainMenuButton, mfTransitionAlpha))
				{
					mlClickedMainMenuButton = eMainMenuButtonID_LoadGame;
				}
			
				msSelectedMainMenuButton = OptionMenu_UpdateFocus("LoadGame", msSelectedMainMenuButton);
			}
			else
			{
				//////////////
				// No games to load
				OptionMenu_MainMenuDisabledButton("LoadGame", kMainMenuButtonPos, lEntryPos, disabledLabelData);
			}
		
			++lEntryPos;
		}
		
		
		/////////////////
		// Custom stories
		if(cLux_GetModHandler().GetIsRunningMod()==false && Platform_IsConsole() == false)
		{
			if(OptionMenu_MainMenuButton("Mods", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_CustomStories, msSelectedMainMenuButton, mlClickedMainMenuButton, mfTransitionAlpha))
			{
				mlClickedMainMenuButton = eMainMenuButtonID_CustomStories;
			}
		
			msSelectedMainMenuButton = OptionMenu_UpdateFocus("Mods", msSelectedMainMenuButton);
				
			++lEntryPos;
		}
		
		/////////////////
		// Options
		{
			if(OptionMenu_MainMenuButton("Options", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_Options, msSelectedMainMenuButton, mlClickedMainMenuButton, mfTransitionAlpha))
			{
				mlClickedMainMenuButton = eMainMenuButtonID_Options;
			}
		
			msSelectedMainMenuButton = OptionMenu_UpdateFocus("Options", msSelectedMainMenuButton);
			
			++lEntryPos;
		}
		
						
		/////////////////
		// Exit
		if(Platform_IsConsole() == false)
		{
			if(OptionMenu_MainMenuButton("Exit", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_Exit, msSelectedMainMenuButton, mlClickedMainMenuButton, mfTransitionAlpha))
			{
				mlClickedMainMenuButton = eMainMenuButtonID_Exit;
			}

			msSelectedMainMenuButton = OptionMenu_UpdateFocus("Exit", msSelectedMainMenuButton);
		}
		
		{
			/////////////////
			// After the delay, perform the button click
			if (ImGui_TimerOver("ButtonClicked"))
				ImGui_StopTimer("ButtonClicked");

			switch(mlClickedMainMenuButton)
			{
			case eMainMenuButtonID_Continue: 
				///////////
				// Load the last save
				ImGui_AddTimer("Continue", gfContinueGameFadeOutTime);
				cSound_FadeOutAll(eSoundEntryType_WorldAll, 1.0f / gfContinueGameFadeOutTime, false);
				Music_StopAll(mfFadeLength);
				Sound_Stop("MenuBGNoise", mfFadeLength);
				cLux_GetGuiHandler().SetGameHudInputFocus(false);
				return;

				//break;
			case eMainMenuButtonID_NewGame:
				// New game

				if(mbCanContinue)
				{
					// Show message box to confirm
					mbShowNewGame = true;
					msFocusNextFrame = "No";
					msMessageBoxFocus = "No";
				}
				else
				{
					ClickNewGame();
				}
				break;
			case eMainMenuButtonID_LoadGame:
				// Load
				mTargetGroup = eMainMenuGroup_LoadGame;
				break;
			case eMainMenuButtonID_Options:
				// Open options and set focus
				cLux_AddDebugMessage("TARGET GROUP OPTIONS. SELECTED: "+msSelectedOptionsButton);
				mTargetGroup = eMainMenuGroup_Options;
				msTargetFocus = msSelectedOptionsButton;
				break;
			case eMainMenuButtonID_Exit:
				// Exit
				mbShowExit = true;
				msFocusNextFrame = "No";
				msMessageBoxFocus = "No";
				break;
			case eMainMenuButtonID_CustomStories:
				// Custom stories
				mTargetGroup = eMainMenuGroup_CustomStories;
				//mCurrentGroup = eMainMenuGroup_CustomStories;
				msFocusNextFrame = "Back";
				
				cLux_GetModHandler().CleanUpListing();
				cLux_GetModHandler().PrepareListing();
								
				break;
			}
			
			mlClickedMainMenuButton = -1;
		}
			
		// Transition is skipped in OptionMenu_MainMenuButton
		GuiHandleTransition(0.05, 0.025, mTargetGroup, msTargetFocus);
		
		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false,false);
	}

	//-------------------------------------------------------
	
	void ResetBlur()
	{
		if (mlBlurID > -1)
		{
			Effect_Blur_FadeOut(mlBlurID,0);
			mlBlurID = -1;
		}
	}
	
	//-------------------------------------------------------
	
	void GuiPauseDarkOverlay()
	{
		if (cLux_GetGamePaused() == false) return;
		
		// TEMP FOR DEMO
		cImGuiGfx blackImage("simple_black.dds", eImGuiGfx_Texture);
		blackImage.mColor = cColor(0,0,0,0.4f);
		ImGui_DoImage(blackImage, ImGui_FullScreenPos(14.0f), ImGui_FullScreenSize());
		
	}
	
	//-------------------------------------------------------
	
	void GuiPauseMenuSelection()
	{
		
		GuiPauseDarkOverlay();
		
/*		tString sControllerImage = "demo_controller_map";
		if (!cLux_GetInputHandler().GetGamepadWasLastDeviceUsed())
			sControllerImage = "demo_keyboard_map";
		cImGuiGfx@ image = cImGuiGfx(sControllerImage, eImGuiGfx_Texture);
		cVector2f size = ImGui_GetRatioCorrectSizeByNrmHeight(image, 0.8f);
		cVector2f offs = (ImGui_GetCurrentGroupSize()-size)/2.0f;
		ImGui_DoImage(cImGuiGfx(sControllerImage, eImGuiGfx_Texture), cVector3f(offs.x,offs.y,15.0f), size);*/
		
		int lEntryPos = 0;
		/////////////////
		// Continue
		{
			if(OptionMenu_MainMenuButton("ReturnToGame", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_ReturnToGame, msSelectedPauseMenuButton, mlClickedPauseMenuButton, mfTransitionAlpha))
			{
				mlClickedPauseMenuButton = eMainMenuButtonID_ReturnToGame;
			}

			msSelectedPauseMenuButton = OptionMenu_UpdateFocus("ReturnToGame", msSelectedPauseMenuButton);
		}
		
		++lEntryPos;
		
		/////////////////
		// Options
		{
			if(OptionMenu_MainMenuButton("Options", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_Options, msSelectedPauseMenuButton, mlClickedPauseMenuButton, mfTransitionAlpha))
			{
				mlClickedPauseMenuButton = eMainMenuButtonID_Options;
			}
		
			msSelectedPauseMenuButton = OptionMenu_UpdateFocus("Options", msSelectedPauseMenuButton);
		}

		++lEntryPos;

		/////////////////
		// Exit
		{
			if(OptionMenu_MainMenuButton("Exit", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_Exit, msSelectedPauseMenuButton, mlClickedPauseMenuButton, mfTransitionAlpha))
			{
				mlClickedPauseMenuButton = eMainMenuButtonID_Exit;
			}

			msSelectedPauseMenuButton = OptionMenu_UpdateFocus("Exit", msSelectedPauseMenuButton);
		}
		
		++lEntryPos;

		/////////////////
		// Save and exit
		if (mbSaveLoadEnabled == false)
		{
		}
		else if ( (Map_IsChanging()==false) && cLux_GetSavingEnabled() )
		{
			if(OptionMenu_MainMenuButton("SaveAndExit", kMainMenuButtonPos, lEntryPos, eMainMenuButtonID_SaveAndExit, msSelectedPauseMenuButton, mlClickedPauseMenuButton, mfTransitionAlpha))
			{
				mlClickedPauseMenuButton = eMainMenuButtonID_SaveAndExit;
			}

			msSelectedPauseMenuButton = OptionMenu_UpdateFocus("SaveAndExit", msSelectedPauseMenuButton);
		}
		else
		{
			//////////////
			// Not possible to save and exit, disable it and render it as a label instead
			
			cImGuiLabelData labelData;
			labelData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu_InfoBox, 56));
			labelData.mFont.mvSize = cVector2f(36, 36);
			labelData.mFont.mColor = kDisabledColor;
			
			OptionMenu_MainMenuDisabledButton("SaveAndExit", kMainMenuButtonPos, lEntryPos, labelData);

			//ImGui_DoLabelExt("SaveAndExit",labelData, OptionMenu_GetTopLeftOffset(kMainMenuButtonPos+ cVector2f(0, kOptionMenu_ButtonSpacing * 3.0f), 1.0));
		}

		//////////////
		// Show playgo?
		int64 lETA = 0;
		if(cLux_IsPlayGoReady(lETA) == false && cScript_GetGlobalVarBool("PlayGo"))
		{
			//////////////
			// Display text telling the player that they cant progress yet
			float fPulse = ImGui_FadeOscillateFloat("PlayGoPulse", 1, 0.8f, 1.5);
			cImGuiLabelData labelData;
			labelData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu_InfoBox, 56));
			labelData.mFont.mvSize = cVector2f(24, 24);
			labelData.mFont.mColor = cColor(fPulse,fPulse);
			labelData.mFontAlign = eFontAlign_Center;
			
			ImGui_DoLabelExt("PlayGoInstructions",labelData, OptionMenu_GetTopLeftOffset(kMainMenuButtonPos - cVector2f(150, 100), 1.0), cVector2f(1000, 32));

			///////////////
			// Time left to progress
			tString sCat = ImGui_GetTransCategory();
			ImGui_SetTransCategory("");

			int64 lSeconds = lETA % 60;
			int64 lMinutes = (lETA / 60) % 60;
			int64 lHour = (lETA / 3600);

			tString sTime;

			if(lHour > 9) sTime += lHour + ":";
			else if(lHour > 0) sTime += "0"+lHour + ":";
			
			if(lMinutes > 9) sTime += lMinutes + ":";
			else if(lMinutes > 0) sTime += "0"+lMinutes + ":";

			if(lSeconds > 9) sTime += lSeconds;
			else if(lSeconds > 0) sTime += "0"+lSeconds;

			ImGui_DoLabelExt(sTime,labelData, OptionMenu_GetTopLeftOffset(kMainMenuButtonPos - cVector2f(150, 64), 1.0), cVector2f(1000, 32));
			ImGui_SetTransCategory(sCat);
		}

		if(ImGui_ActionTriggered(eImGuiAction_Cancel, true))
		{
				/////////////
				// Disable menu
				SetMenuActive(false);
				ResetBlur();
				mfTransitionAlpha = 1;
				return;
		}

		//if(ImGui_TimerOver("ButtonClicked"))
		{
			/////////////////
			// After the delay, perform the button click
			ImGui_StopTimer("ButtonClicked");

			switch(mlClickedPauseMenuButton)
			{
			case eMainMenuButtonID_ReturnToGame: 
				// return to game
				SetMenuActive(false);
				ResetBlur();
				mfTransitionAlpha = 1;
				break;
			case eMainMenuButtonID_Options:
				// Options
				cLux_AddDebugMessage("CURR TARGET: "+mTargetGroup);
				mTargetGroup = eMainMenuGroup_Options;
				cLux_AddDebugMessage("NEW TARGET: "+mTargetGroup);
				msTargetFocus = msSelectedOptionsButton;
				cLux_AddDebugMessage(msSelectedOptionsButton);
				break;
			case eMainMenuButtonID_SaveAndExit:
				mbSaveAndExit = true;
			case eMainMenuButtonID_Exit:
				// Exit
				mbShowExit = true;
				msFocusNextFrame = "No";
				msMessageBoxFocus = "No";
				break;
			}

			mlClickedPauseMenuButton = -1;
		}
		
		GuiHandleTransition(0.05, 0.1, mTargetGroup, msTargetFocus);
		
		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
	}
	
	//-------------------------------------------------------
	
	int mlOptionItemId;
	
	void DoOptionsItem(array<tString> avMenuItems, const tString &in asName, eMainMenuGroup aGroup, const tString &in asFocusNextFrame, cVector2f avRightAnchor, cVector3f avInfoBoxPos, float afAlpha)
	{
		//cLux_AddDebugMessage("SELECTED OPT: "+msSelectedOptionsButton);
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			if(OptionMenu_ButtonOptions(asName, kOptionsButtonPos, mlCurrentItemId, msSelectedOptionsButton, true, avRightAnchor, avInfoBoxPos, afAlpha))
			{
				mTargetGroup = aGroup;
				msTargetFocus = asFocusNextFrame;
				
				if (asName == "Options_Gamma") mbShowingGammaMenu = true;
				if (asName == "Options_Graphics") mlCurrentResolution = GetCurrentResolution();
				if (asName == "Options_Display") mlCurrentResolution = GetCurrentResolution();
			}
			msSelectedOptionsButton = OptionMenu_UpdateFocusCustom(avMenuItems, avMenuItems[mlCurrentItemId], msSelectedOptionsButton);
		}
		mlCurrentItemId++;				
	}
	
	//------------------------------------------------------- 
	
	float mfTransitionAlpha = 1;
	
	int GuiHandleTransition(float afInSpeed, float afOutSpeed, eMainMenuGroup aTarget = eMainMenuGroup_Main, const tString &in asNextFrame="")
	{
		int lState;
		
		float fFadeMul = (mbMainMenuActive) ? 1 : 2;
		
		if (ImGui_TimerExists("TransitionIn"))
		{
			if (mfTransitionAlpha < 1)
			{
				lState = 1;
				mfTransitionAlpha += afInSpeed*fFadeMul;
			}
			else
			{
				mfTransitionAlpha = 1;
				ImGui_StopTimer("TransitionIn");
			}
		}
		else if (ImGui_TimerExists("TransitionOut"))
		{
			if (mfTransitionAlpha > 0)
			{
				if (mfTransitionAlpha == 1) 
				{
					if (Sound_GuiIsPlaying("special_fx/frontend/frontend_menu_change")) Sound_StopGui("special_fx/frontend/frontend_menu_change",0);
					Sound_PlayGui("special_fx/frontend/frontend_menu_change", 1.0f, eSoundEntryType_Gui);
				}
				
				lState = -1;
				mfTransitionAlpha -= afOutSpeed*fFadeMul;
			}
			else
			{
				ImGui_StopTimer("TransitionOut");
				
				cLux_AddDebugMessage("GOING TO: "+aTarget);
				mCurrentGroup = aTarget;
				msFocusNextFrame = asNextFrame;
				cLux_AddDebugMessage("NEXT FRAME: "+msFocusNextFrame);
				if (ImGui_TimerExists("TransitionIn") == false)
					ImGui_AddTimer("TransitionIn",10);
			}
		}
		else 
			lState = 0;
		
		return lState;
	}
	
	//------------------------------------------------------- 
	
	void GuiOptions()
	{
			

		GuiPauseDarkOverlay();
		
		array<tString> vMenuItemsPC = {"Options_Game", "Options_Controls", "Options_Display", "Options_Graphics", "Options_Audio", "Back"};
		array<tString> vMenuItemsPS4 = {"Options_Game", "Options_Controls", "Options_Gamma", "Options_Audio", "Back"};
		array<tString> vMenuItems = (Platform_IsConsole()) ? vMenuItemsPS4 : vMenuItemsPC;
		
		cVector2f vBgSize = (Platform_IsConsole()) ? kOptionsBgSizePS4 : kOptionsBgSize;

		if(cLux_DebugModeOn()) 
		{
			//////////////
			// Add debug options
			vMenuItems.insertAt(vMenuItems.size() - 1, "DebugOptions"); 
			vBgSize.y += 45;
		}

		cVector2f vOptionsMenuPos = kOptionsBgPos;
		cVector2f vOptionsMenuSize = vBgSize+cVector2f(gfOptionsMenu_ExtraWidth,0);
		cVector2f vRightAnchor = cVector2f(vOptionsMenuPos.x+vOptionsMenuSize.x+100,0);
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vOptionsMenuPos.x+vOptionsMenuSize.x-60,0),0);
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Options", vOptionsMenuPos, vOptionsMenuSize);

		////////////////////////////////////
		// Options background
				
		tString sBkg = OptionMenu_GetBackground(OptionMenu_GetScaledSize(vOptionsMenuSize));
		cImGuiGfx gfx = cImGuiGfx(sBkg, eGuiMaterial_Alpha, eImGuiGfx_TextureTemporary);
		gfx.mColor = cColor(1,mfTransitionAlpha);
		
		ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(vOptionsMenuPos, 0.0), OptionMenu_GetScaledSize(vOptionsMenuSize));		
		
		/////////////////////////
		// Handles dynamic scrolling
		mlCurrentItemId = mlFirstItemId;
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		DoScrollInput(vMenuItems);

		/////////////////
		// Game
		{
			DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Game, msSelectedGameplayButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
		}
		/////////////////
		// Input
		{
			DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Controls, msSelectedGameplayButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
		}
		/////////////////
		// Display
		if(Platform_IsConsole() == false)
		{
			DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Display, msSelectedVideoButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
		}
		/////////////////
		// Graphics
		if(Platform_IsConsole() == false)
		{
			DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Graphics, msSelectedVideoButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
		}
		else
		{
			///////////////
			// GAMMA (PS4)
			DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Display_Gamma, msSelectedVideoGammaButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
		}
		/////////////////
		// Audio
		{
			DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Audio, msSelectedAudioButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
		}
		/////////////////
		// Accessibility
		{
			//DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Accessibility, msSelectedAudioButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
		}
		/////////////////
		// Debug
		if (cLux_DebugModeOn())
		{
			DoOptionsItem(vMenuItems, vMenuItems[mlCurrentItemId-mlFirstItemId], eMainMenuGroup_Options_Debug, msSelectedDebugButton, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
		}
		/////////////////
		// Back
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			
			
			bool bButton = OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsButtonPos+kBackMargin, mlCurrentItemId, msSelectedOptionsButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			
			
			
			if(bButton || bGamepad)
			{
				mbParallax = false;
				
				mlScrollMargin = 2;
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mlLastInFocusRel = 0;
				mbScrolled = false;
				mbScrollDown = false;
				mbScrollUp = false;
				
				if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut",10);
					
				mTargetGroup = eMainMenuGroup_Main;
				msTargetFocus = mbMainMenuActive ? msSelectedMainMenuButton : msSelectedPauseMenuButton;
				
				////////
				// Reset menu pos
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(false);
					//msSelectedOptionsButton = "Options";					
					return;
				}
			}
			msSelectedOptionsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedOptionsButton);	
		}
		else
		{
			bool bBack = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			if (bBack)
			{
				mbParallax = false;
				
				mlScrollMargin = 2;
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mlLastInFocusRel = 0;
				mbScrolled = false;
				mbScrollDown = false;
				mbScrollUp = false;
				
				mTargetGroup = eMainMenuGroup_Main;
				msTargetFocus = mbMainMenuActive ? msSelectedMainMenuButton : msSelectedPauseMenuButton;
			}
		}
		
		DoScrollMask(-3);
		
		GuiHandleTransition(0.05f, 0.04f, mTargetGroup, msTargetFocus);
		
		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
		
		// END GuiOptions()
	}

	//-------------------------------------------------------

	void GuiStartGame()
	{
		//////////////////
		// Draw the save slots
		cVector2f vPos = kSaveSlotPos;
		vPos.x = (1280.0 / 2.0) * (720.0 / 1280.0) / (cGraphics_GetLowLevel().GetScreenSizeFloat().y / cGraphics_GetLowLevel().GetScreenSizeFloat().x); 
		float fSpacingMul = 2.0 * vPos.x / 1024.0;
		for(int i = 0; i < 5; ++i)
		{
			OptionMenu_SaveSlot("SaveSlot"+i, vPos + kSaveSlotSpacing * (i - 2.5 + (fSpacingMul - 1.0) / 2.0) * fSpacingMul, (i % 2) == 0 ? "gamma_background" : "", msSelectedStartButton, msSelectedStartButton);
		}

		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kMainMenuButtonPos, 8, msSelectedStartButton);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				mCurrentGroup = eMainMenuGroup_Main;

				msFocusNextFrame = msSelectedMainMenuButton;
				ApplySettings();

				//////////
				// Reset menu pos
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(msSelectedStartButton != "Back");
					return;
				}
			}
			
			msSelectedStartButton = OptionMenu_UpdateFocus("Back", msSelectedStartButton);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(msSelectedStartButton != "Back");
	}

	//-------------------------------------------------------
	
	void GuiLoadGame()
	{		
		////////////////////////////////////
		// Options background
		//ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(kLoadWindowBgSize));
		
		//cImGuiGfx gfx;
		//ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(kLoadBgPos, 0.01), OptionMenu_GetScaledSize(kLoadBgSize), cColor(0.0, 0.5));
		
		////////////////
		// Title
		//OptionMenu_SectionTitle("Options", kOptionsBgPos, kLoadBgSize);
		
		cImGuiGfx gfx = cImGuiGfx("startmenu_submenu_backdrop_loadscreen.tga", eImGuiGfx_Texture);
		gfx.mColor = cColor(1, mfTransitionAlpha);
		ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(kLoadBgPos, 0.0), OptionMenu_GetScaledSize(kLoadBgSize));
		
		cImGuiGfx gfxFrame = cImGuiGfx("startmenu_frame_load.tga", eImGuiGfx_Texture);
		gfxFrame.mColor = cColor(1, mfTransitionAlpha);
		ImGui_DrawGfx(gfxFrame, OptionMenu_GetTopLeftOffset(kLoadFramePos, 0.5f), OptionMenu_GetScaledSize(kLoadFrameSize));
		
		cImGuiGfx gfxScrollBar = cImGuiGfx("startmenu_scrollbar_widget.tga", eImGuiGfx_Texture);
		gfxScrollBar.mColor = cColor(1, mfTransitionAlpha);
		
		
		
		////////////////
		// Title
		OptionMenu_SectionTitle("LoadGame", kLoadBgPos, kLoadBgSize);

		//////////////
		// Catch input
		int lActionVertical = 0;
		bool bMouseDown = false;
		float fPadding = mbScrollingSaveList ? 10000 : 5;
		
		int lMaxShownItems = 10;
		
		//////////////////////////////////////////
		// Possible values for lActionVertical:
		// 0:	nothing to do
		// -1:	moves focus up one entry
		// -2:	moves list up by one entry
		// +1:	moves focus down one entry
		// +2:	moves list down one entry
		if(mbShowLoadGame == false)
		{
			/////////////////////////
			// Only catch input if confirmation popup is not visible
			
			if(ImGui_ActionTriggered(eImGuiAction_Down, true)) 
			{
				Sound_PlayGui("special_fx/frontend/frontend_menu_focus", 1.0f, eSoundEntryType_Gui); 
				lActionVertical++;
			}
			if(ImGui_ActionTriggered(eImGuiAction_Up, true)) 
			{
				Sound_PlayGui("special_fx/frontend/frontend_menu_focus", 1.0f, eSoundEntryType_Gui); 
				lActionVertical--;
			}
			if(ImGui_ActionTriggered(eImGuiAction_ScrollDown, true) && (mlSaveFileOffset + mlSelectedLoadButton) < mvSaveNames.size()-1 && mlSelectedLoadButton != lMaxShownItems) lActionVertical+=2;
			if(ImGui_ActionTriggered(eImGuiAction_ScrollUp, true) && (mlSaveFileOffset + mlSelectedLoadButton) > 0 && mlSelectedLoadButton != lMaxShownItems) lActionVertical-=2;
			bMouseDown = ImGui_ActionIsDown(eImGuiAction_MouseLeft, false);
		}

		////////////////
		// Draw a list of all save files
		int c = 0;
			
		for(int i=mlSaveFileOffset; i<mvSaveNames.size() && c<lMaxShownItems; ++i)
		{
			tWString sDisplayedName = mvSaveNames[i];

			int lSubPos =cString_GetFirstStringPosW(sDisplayedName, tWString("AutoSave"));
			if(lSubPos>=0)
			{
				sDisplayedName = cString_SubW(sDisplayedName, lSubPos+8, -1);
			}
			
			if (OptionMenu_ButtonSaveFile("Save"+c, sDisplayedName, mvSaveDates[i], kLoadSlotsPos + cVector2f(0, c * kLoadSlotsSpacing),
																				   kLoadSlotsTimestampPos + cVector2f(0, c * kLoadSlotsSpacing+5), mlSelectedLoadButton == c, mfTransitionAlpha))
			{
				if(bMouseDown == false || OptionMenu_GetMouseInside(kLoadScrollPos - cVector2f(fPadding, 0), 
																	kLoadScrollPos + kLoadScrollSize + cVector2f(10000, 0)).y == -1)
				{
					mlSaveFileToLoad = i;
					mbShowLoadGame = true;
					msMessageBoxFocus = "No";
					msFocusNextFrame="No";
				}
			}

			if(bMouseDown == false)
			{
				if (ImGui_PrevBecameInFocus())
				{
					mlSelectedLoadButton = c;
				}
			}
			c++;
		}
		
		//////////////
		// Update focus
		if(lActionVertical != 0)
		{
			if (mfTransitionAlpha == 1) Sound_PlayGui("special_fx/frontend/frontend_menu_slider", 1.0f, eSoundEntryType_Gui);
			//////////
			// Select file
			if(lActionVertical<0)	// Scroll up
			{
				if(lActionVertical==-1)
				{
					if (mlSelectedLoadButton==lMaxShownItems)	// Back button
					{
						mlSelectedLoadButton = cMath_Min(mvSaveNames.size() - 1, lMaxShownItems-1);
					}
					else
					{
						mlSelectedLoadButton--;
						if(mlSelectedLoadButton < 0)
						{
							if(mlSaveFileOffset > 0) 
							{
								mlSelectedLoadButton = 0;
								mlSaveFileOffset--;
							}
							else
							{
								mlSelectedLoadButton = lMaxShownItems;
							}
						}
					}
				}
				else
				{
					// Scrolling with Wheel
					if(mlSaveFileOffset > 0) 
					{
						mlSaveFileOffset--;
					}
				}
			}
			else	// Scroll down
			{
				if(lActionVertical==1)
				{
					if (mlSelectedLoadButton==lMaxShownItems)	// Back button
					{
						mlSelectedLoadButton = 0;
					}
					else
					{
						mlSelectedLoadButton++;
						if(mlSelectedLoadButton >= cMath_Min(mvSaveNames.size(),lMaxShownItems) )
						{
							if(mlSaveFileOffset<mvSaveNames.size()-lMaxShownItems) 
							{
								mlSelectedLoadButton--;
								mlSaveFileOffset++;
							}
							else
							{
								///////////
								// No more files, scroll to back button
								mlSelectedLoadButton = lMaxShownItems;
							}
						}
					}
				}
				else
				{
					// Scrolling with Wheel
					if(mlSaveFileOffset<mvSaveNames.size()-lMaxShownItems) 
					{
						mlSaveFileOffset++;
					}
				}
			}
			
		}

		//////////////
		// Scroll bar
		if(mvSaveNames.size() > lMaxShownItems)
		{
			////////////
			// Update input
			float fFiles = mvSaveNames.size();
			int lOldOffset = mlSaveFileOffset;
			float fMouseScrollY = OptionMenu_GetMouseInside(kLoadScrollPos - cVector2f(fPadding, 0), kLoadScrollPos + kLoadScrollSize + cVector2f(fPadding, 0)).y;

			if(fMouseScrollY != -1.0)
			{
				///////////
				// Mouse touching scroll, check if button pressed
				if(bMouseDown)
				{
					mlSaveFileOffset = cMath_RoundToInt((fFiles-lMaxShownItems) * fMouseScrollY);
					mbScrollingSaveList = true;
				}
			}

			if(bMouseDown == false)
			{
				////////
				// Stopped scrolling
				mbScrollingSaveList = false;
			}

			mlSaveFileOffset = cMath_Clamp(mlSaveFileOffset, 0, mvSaveNames.size() - lMaxShownItems);

			if(mlSelectedLoadButton >= 0 && mlSelectedLoadButton < 10 && (mlSaveFileOffset - lOldOffset) != 0)
			{
				int lDiff = (mlSaveFileOffset - lOldOffset);
				mlSelectedLoadButton = cMath_Clamp(mlSelectedLoadButton - lDiff, 0, 9);
			}

			float fScaleY = 1.0 - (fFiles - 10.0) / fFiles;
			float fPosY = 0;
			if (fFiles>lMaxShownItems)
				fPosY = (mlSaveFileOffset) / (fFiles-lMaxShownItems);
				
			ImGui_DrawGfx(gfxScrollBar, OptionMenu_GetTopLeftOffset(kLoadScrollPos + kLoadScrollSize * cVector2f(0, (1.0 - fScaleY) * fPosY), 0.01), OptionMenu_GetScaledSize(kLoadScrollSize * cVector2f(1, fScaleY)), ((fMouseScrollY == -1.0f && mbScrollingSaveList == false) || mbShowLoadGame) ? kMainMenuButtonBgColor : cColor(1,mfTransitionAlpha));
		}

		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kLoadButtonPos, 0, mlSelectedLoadButton < lMaxShownItems ? ("Save"+mlSelectedLoadButton) : "Back", true, cVector2f_Zero, cVector3f_Zero, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			if(bButton || bGamepad)
			{
				mTargetGroup = eMainMenuGroup_Main;
				msFocusNextFrame = msSelectedMainMenuButton;
				
				if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut",10);
					
				////////
				// Reset menu pos
				if(bGamepad == false)
				{
					mlSelectedLoadButton = 0;
					OptionMenu_ShowGamepadButtons(false);
				}

				return;
			}

			if(bMouseDown == false)
			{
				if (ImGui_PrevBecameInFocus())
				{
					//cLux_AddTodoMessage("Sound: Menu focus changed");
					//Sound_PlayGui("special_fx/frontend/frontend_menu_focus", 1.0f, eSoundEntryType_Gui);
					mlSelectedLoadButton = lMaxShownItems;
				}
			}
		}

		///////////
		// Manual focus since we catch input
		if(mbShowLoadGame == false)
		{
			if(mlSelectedLoadButton >= 0 && mlSelectedLoadButton < 10) msFocusNextFrame = "Save"+mlSelectedLoadButton;
			else													   msFocusNextFrame = "Back";
		}
		
		GuiHandleTransition(0.05f, 0.025f, mTargetGroup, msTargetFocus);

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
	}

	//-------------------------------------------------------

	void GuiOptionsGameplay()
	{
		GuiPauseDarkOverlay();
		//GuiHandleTransition(0.05f, 0.025f);
		
		/*if (ImGui_TimerExists("TransitionIn") && mfTransitionAlpha < 1)
		{
			msSelectedGameplayButton = msFocusNextFrame;
			
			if (msSelectedGameplayButton == "")
			{
				msSelectedGameplayButton = "Language";
				ImGui_SetFocus(msSelectedGameplayButton);
			}
		}*/
		
		array<tString> vMenuItems = {"Language", "ShowHints", "ScreenDisortion"/*, "ColorSeparation"*/, "CrosshairSimple"/*, "Options_Accessibility"*/, "Back"};

		for (int i=0; i<=vMenuItems.length()-1; i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_UpdateMultiSelectionExtraWidth(mvLangFiles, "Languages");
		OptionMenu_AlignExtraButtonWidth();		
		
		cVector2f vGameplayMenuPos = kOptionsGameplayBgPos;
		cVector2f vGameplayMenuSize = Platform_IsConsole() ? kOptionsGameplayPS4BgSize : kOptionsGameplayBgSize;
		vGameplayMenuSize += cVector2f(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_MultiSelect,0);
		
		cVector2f vOptionsMenuSize = kOptionsBgSize+cVector2f(gfOptionsMenu_ExtraWidth,0);
		
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vGameplayMenuPos.x+vGameplayMenuSize.x-40,0),0);
		cVector2f vRightAnchor = cVector2f(vGameplayMenuPos.x+vGameplayMenuSize.x-40,0);
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Gameplay", vGameplayMenuPos, vGameplayMenuSize);	
			
		////////////////////////////////////
		// Background
		tString sBkg = OptionMenu_GetBackground(OptionMenu_GetScaledSize(vGameplayMenuSize));
		cImGuiGfx gfx = cImGuiGfx(sBkg, eGuiMaterial_Alpha, eImGuiGfx_TextureTemporary);
		gfx.mColor = cColor(1,mfTransitionAlpha);
		
		//cLux_AddDebugMessage("GFX: "+sBkg+" - ACTUAL: "+OptionMenu_GetScaledSize(vGameplayMenuSize));

		ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(vGameplayMenuPos, 0.0), OptionMenu_GetScaledSize(vGameplayMenuSize));
		
		mlCurrentItemId = mlFirstItemId;
		
		/////////////////////////
		// Handles dynamic scrolling
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		DoScrollInput(vMenuItems);

		/////////////////
		// LANGUAGE
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			tString sLang = cString_SetFileExt(mpConfig.GetString("Main", "StartLanguage", cLux_GetDefaultGameLanguage()), "");
			int lValue = 0;

			for(int i = 0; i < mvLangFiles.size(); ++i)
			{
				if(sLang == mvLangFiles[i])
				{
					lValue = i;
					break;
				}
			}
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsGameplayButtonPos, mlCurrentItemId, msSelectedGameplayButton, mvLangFiles, lValue, false, mlActionHorizontal, "Languages", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(lValue != lNewValue)
			{
				mpConfig.SetString("Main", "StartLanguage", cString_SetFileExt(mvLangFiles[lNewValue], "lang"));
				FontHandler_SetLanguage(mvLangFiles[lNewValue]);
				ApplySettings();
			}

			msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
		}
		mlCurrentItemId++;
		/////////////////
		// Hints
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Gameplay", "ShowHints", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsGameplayButtonPos, mlCurrentItemId, msSelectedGameplayButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Gameplay", "ShowHints", bNewValue);
			}
			
			msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
		}
		mlCurrentItemId++;
		/////////////////
		// Screen Distortion
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Gameplay", "ScreenDisortion", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsGameplayButtonPos, mlCurrentItemId, msSelectedGameplayButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Gameplay", "ScreenDisortion", bNewValue);
			}
			
			msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
		}
		mlCurrentItemId++;
		/* Merged with screen distortions
		/////////////////
		// Color Separation
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Gameplay", "ColorSeparation", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsGameplayButtonPos, mlCurrentItemId, msSelectedGameplayButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Gameplay", "ColorSeparation", bNewValue);
			}
			
			msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
		}
		mlCurrentItemId++;
		*/
		/////////////////
		// Cursor Style
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Gameplay", "CrossHairStyleSimple", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsGameplayButtonPos, mlCurrentItemId, msSelectedGameplayButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Gameplay", "CrossHairStyleSimple", bNewValue);
				ApplySettings();
			}

			msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
		}
		mlCurrentItemId++;
		//////////////////
		// Accessibility
/*		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{			
			if (OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsGameplayButtonPos, mlCurrentItemId, msSelectedGameplayButton, true, vRightAnchor, vInfoBoxPos))
			{
				mPrevGroup = eMainMenuGroup_Options_Game;
				mTargetGroup = eMainMenuGroup_Options_Accessibility;
				msTargetFocus = msSelectedAudioButton;
			}
			msSelectedGameplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGameplayButton);
		}
		mlCurrentItemId++;	
		*/
		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kOptionsGameplayButtonPos+kBackMargin, mlCurrentItemId, msSelectedGameplayButton,true,cVector2f_Zero,cVector3f_Zero,mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				/////////////
				// Enable subtitles if other than english is selected
				tString sLang = mpConfig.GetString("Main", "StartLanguage", cLux_GetDefaultGameLanguage());
				if((sLang == "english" || sLang == "english.lang") == false)
				{
					mpConfig.SetBool("Sound", "ShowSubtitles", true);
				}

				ApplySettings();
				
				if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut", 10);
					
				mTargetGroup = eMainMenuGroup_Options;
				msTargetFocus = msSelectedOptionsButton;

				/////////
				// Reset menu position
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(msSelectedGameplayButton != "Back");
					//msSelectedGameplayButton = "Language";
					return;
				}
			}

			msSelectedGameplayButton = OptionMenu_UpdateFocus("Back", msSelectedGameplayButton);
		}
		
		GuiHandleTransition(0.05f, 0.05f, mTargetGroup, msTargetFocus);

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(msSelectedGameplayButton != "Back" && msSelectedGameplayButton != "Options_Accessibility");
	}
	
	//------------------------------------------------------- 
	
	void GuiOptionsControls()
	{
		GuiPauseDarkOverlay();
		
		/*if (ImGui_TimerExists("TransitionIn"))
		{
			msSelectedGameplayButton = msFocusNextFrame;
			
			if (msSelectedGameplayButton == "")
			{
				msSelectedGameplayButton = (Platform_IsConsole()) ? "GamepadSens" : "MouseSens";
				ImGui_SetFocus(msSelectedGameplayButton);
			}
		}*/
		
		array<tString> vMenuItemsPC = {"MouseSens", "InvertMouseY", "SmoothMouse", "Keybind", "GamepadSens", "InvertGamepadY", "PadVibration", "GamepadMapping", "Back"};
		array<tString> vMenuItemsPS4 = {"GamepadSens_PS4", "InvertGamepadY_PS4", "PadVibration_PS4", "GamepadMapping_PS4", "Back"};
		array<tString> vMenuItems = (Platform_IsConsole()) ? vMenuItemsPS4 : vMenuItemsPC;
				
		for (int i=0; i<=vMenuItems.length()-1; i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_AlignExtraButtonWidth();

		////////////////////////////////////
		// Options background
		cVector2f vControlsMenuPos = kOptionsControlsBgPos;
		cVector2f vControlsMenuSize = Platform_IsConsole() ? kOptionsControlsPS4BgSize : kOptionsControlsBgSize;
		vControlsMenuSize += cVector2f(cMath_Min(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_MultiSelect,620.f),0);
		
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vControlsMenuPos.x+vControlsMenuSize.x-40,0),0);
		cVector2f vRightAnchor = cVector2f(vControlsMenuPos.x+vControlsMenuSize.x-40,0);
		
		tString sBkg = OptionMenu_GetBackground(OptionMenu_GetScaledSize(vControlsMenuSize));
		cImGuiGfx gfx = cImGuiGfx(sBkg, eGuiMaterial_Alpha, eImGuiGfx_TextureTemporary);
		gfx.mColor = cColor(1,mfTransitionAlpha);
		ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(vControlsMenuPos, 0.0), OptionMenu_GetScaledSize(vControlsMenuSize));
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Controls", vControlsMenuPos, vControlsMenuSize);
		
		mlCurrentItemId = mlFirstItemId;
		
		/////////////////////////
		// Handles dynamic scrolling
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		DoScrollInput(vMenuItems);
		
		cVector2f vSeparator = cVector2f_Zero;
		if (Platform_IsConsole() == false)
		{
			/////////////////
			// Mouse sensitivity
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				float fValue = mpConfig.GetFloat("Input", "MouseSensitivity", 1.0f);
				fValue -= 0.01f;
				fValue /= 4.0f;
				fValue = OptionMenu_ButtonOptionsSlider(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos, mlCurrentItemId, msSelectedInputMouseButton, fValue, 0.2f / 4.0f, mlActionHorizontal, "", "", vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				fValue *= 4.0f;
				fValue += 0.01f;
				mpConfig.SetFloat("Input", "MouseSensitivity", fValue);

				msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
			}
			mlCurrentItemId++;
			/////////////////
			// Invert Mouse Y
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				bool bValue = mpConfig.GetBool("Input", "InvertMouse", false);
				bValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos, mlCurrentItemId, msSelectedInputMouseButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				mpConfig.SetBool("Input", "InvertMouse", bValue);

				msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
			}
			mlCurrentItemId++;
			/////////////////
			// Smooth mouse
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				bool bValue = mpConfig.GetBool("Input", "SmoothMouse", true);
				bValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos, mlCurrentItemId, msSelectedInputMouseButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				mpConfig.SetBool("Input", "SmoothMouse", bValue);
				msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
			}
			mlCurrentItemId++;
			/////////////////
			// Keybindings
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos, mlCurrentItemId, msSelectedInputMouseButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
				{
					mPrevGroup = eMainMenuGroup_Options_Controls;
					mTargetGroup = eMainMenuGroup_Options_Input_Keybind;
					msTargetFocus = msSelectedInputMouseButton;
					mbKeybindChanged = false;
					mbBindingGamepad = false;
					mKeyBindBackDest = eMainMenuGroup_Options_Controls;
					msKeyBindBackFocus = msSelectedInputMouseButton;
					
					mpKeyConfig.Save();
				}
				msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
			}
			mlCurrentItemId++;
			vSeparator = cVector2f(0,15);
		}
		/////////////////
		// Gamepad Sens
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			float fValue = mpConfig.GetFloat("Input", "GamepadSensitivity", 2.0f);
			fValue -= 0.01f;
			fValue /= 5.0f;
			fValue = OptionMenu_ButtonOptionsSlider(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos+vSeparator, mlCurrentItemId, msSelectedInputMouseButton, fValue, 0.2f / 4.0f, mlActionHorizontal, "", "", vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			fValue *= 5.0f;
			fValue += 0.01f;
			mpConfig.SetFloat("Input", "GamepadSensitivity", fValue);

			msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
		}
		mlCurrentItemId++;
		/////////////////
		// Invert Pad Y
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bValue = mpConfig.GetBool("Input", "InvertPad", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos+vSeparator, mlCurrentItemId, msSelectedInputMouseButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			if(bValue != bNewValue) mpConfig.SetBool("Input", "InvertPad", bNewValue);

			msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
		}
		mlCurrentItemId++;
		/////////////////
		// Pad vibration
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bValue = mpConfig.GetBool("Input", "Rumble", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos+vSeparator, mlCurrentItemId, msSelectedInputMouseButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			if(bValue != bNewValue) mpConfig.SetBool("Input", "Rumble", bNewValue);

			msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
		}
		mlCurrentItemId++;
		/////////////////
		// Gamepad Presets
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsControlsButtonPos+vSeparator, mlCurrentItemId, msSelectedInputMouseButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				mPrevGroup = eMainMenuGroup_Options_Controls;
				mTargetGroup = eMainMenuGroup_Options_Input_GamepadMapping;
				mKeyBindBackDest = eMainMenuGroup_Options_Controls;
				msTargetFocus = "GamepadPreset";
				mpKeyConfig.Save();
			}

			msSelectedInputMouseButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedInputMouseButton);
		}
		mlCurrentItemId++;
		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kOptionsControlsButtonPos+vSeparator+kBackMargin, mlCurrentItemId, msSelectedInputMouseButton,true,cVector2f_Zero, cVector3f_Zero, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				mTargetGroup = eMainMenuGroup_Options;
				msTargetFocus = msSelectedOptionsButton;
				
				if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut", 10);

				ApplySettings();

				//////////
				// Reset menu pos
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(msSelectedInputMouseButton != "Back");
					//msSelectedInputMouseButton = "MouseSens";
					return;
				}
			}
			
			msSelectedInputMouseButton = OptionMenu_UpdateFocus("Back", msSelectedInputMouseButton);
		}
		
		GuiHandleTransition(0.05f, 0.05f, mTargetGroup, msTargetFocus);

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(msSelectedInputMouseButton != "Back");

	}

	//-------------------------------------------------------
	
	eMainMenuGroup mGamepadMappingBackDest = eMainMenuGroup_Options_Controls;
	void GuiOptionsInputGamepadContents(int alInY, int &out alOutY, eMainMenuGroup aMappingBackDest, tString asInSelectedButton, tString &out asOutSelectedButton)
	{
		GuiPauseDarkOverlay();
		
		int lY = alInY;
		
		mGamepadMappingBackDest = aMappingBackDest;
		/////////////////
		// Mapping
		{
			if(OptionMenu_ButtonOptions("GamepadMapping", kOptionsButtonPos, lY++, asInSelectedButton))
			{
				mPrevGroup = eMainMenuGroup_Options_Controls;
				mKeyBindBackDest = eMainMenuGroup_Options_Controls;
				mCurrentGroup = eMainMenuGroup_Options_Input_GamepadMapping;
				msFocusNextFrame = "Back";
				mpKeyConfig.Save();
			}

			asInSelectedButton = OptionMenu_UpdateFocus("GamepadMapping", asInSelectedButton);
		}
		
		/////////////////
		// Gamepad Sens
		{
			float fValue = mpConfig.GetFloat("Input", "GamepadSensitivity", 2.0f);
			fValue -= 0.01f;
			fValue /= 5.0f;
			fValue = OptionMenu_ButtonOptionsSlider("GamepadSens", kOptionsButtonPos, lY++, asInSelectedButton, fValue, 0.2f / 5.0f, mlActionHorizontal);
			fValue *= 5.0f;
			fValue += 0.01f;
			mpConfig.SetFloat("Input", "GamepadSensitivity", fValue);

			asInSelectedButton = OptionMenu_UpdateFocus("GamepadSens", asInSelectedButton);
		}

		/////////////////
		// Invert Pad Y
		{
			bool bValue = mpConfig.GetBool("Input", "InvertPad", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle("InvertGamepadY", kOptionsButtonPos, lY++, asInSelectedButton, bValue, mlActionHorizontal);
			if(bValue != bNewValue) mpConfig.SetBool("Input", "InvertPad", bNewValue);

			asInSelectedButton = OptionMenu_UpdateFocus("InvertGamepadY", asInSelectedButton);
		}

		/////////////////
		// Pad vibration
		{
			bool bValue = mpConfig.GetBool("Input", "Rumble", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle("PadVibration", kOptionsButtonPos, lY++, asInSelectedButton, bValue, mlActionHorizontal);
			if(bValue != bNewValue) mpConfig.SetBool("Input", "Rumble", bNewValue);

			asInSelectedButton = OptionMenu_UpdateFocus("PadVibration", asInSelectedButton);
		}
		
		asOutSelectedButton = asInSelectedButton;
		alOutY = lY;
	}
	
	//------------------------------------------------------- 
	
	tString ParseKeybind(tString asBind, bool abAnalog)
	{
		if(asBind.length() > 0)
		{
			int lPos = cString_GetFirstCharPos(asBind, '.');

			if(lPos != -1)
			{
				tString sType = cString_Sub(asBind, 0, lPos);

				if(sType == "Gamepad")
				{
					if(abAnalog)
					{
						tString sAxisNum = cString_Sub(asBind, lPos+8);
						sAxisNum = cString_Sub(sAxisNum, 0, cString_GetFirstCharPos(sAxisNum, '.'));
						int lAxis = cString_ToInt(sAxisNum, 0);

						return "Stick."+(lAxis / 2);
					}
					else
					{
						tString sKey = cString_Sub(asBind, lPos+3);

						return sKey;
					}
				}
				else
				{
					tString sKey = cString_Sub(asBind, lPos+1);

					return sKey;					
				}
			}
		}

		return asBind;
	}
	
	//------------------------------------------------------- 
	
	eMainMenuGroup mKeyBindBackDest = eMainMenuGroup_Options_Input;
	tString msKeyBindBackFocus = msSelectedInputButton;
	
	
	
	void GuiOptionsInputKeybind()
	{
		GuiPauseDarkOverlay();
		
		////////////////
		// Select which type to bind
		array<cBindableAction> vActions = mbBindingGamepad ? mvGamepadActions : mvActions;
		tString sMain = mbBindingGamepad ? "GamepadPrimary" : "Primary";
		tString sSec = mbBindingGamepad ? "GamepadSecondary" : "Secondary";
		
		int c = 0;
		int lNumBinds = 11;
		
		ImGui_SetTransCategory("Actions"); 
		for(uint i = 0; i < vActions.size(); ++i)
		{
			OptionMenu_UpdateButtonWidth(vActions[i].msAction);	
		}	

		for(int i = mlKeybindOffset; i < vActions.size() && c < lNumBinds; ++i)
		{
			tString sBind = vActions[i].msAction;
			tString sPrimary = ParseKeybind(mpKeyConfig.GetString(sBind, sMain, ""), vActions[i].mbAnalog);
			tString sSecondary = ParseKeybind(mpKeyConfig.GetString(sBind, sSec, ""), vActions[i].mbAnalog);
			
			ImGui_SetTransCategory("ButtonNames"); 
			OptionMenu_UpdateKeybindExtraWidth(sPrimary, sSecondary);
			
		}
		
		////////////////////////////////////
		// Options background		
		cVector2f vKeybindMenuSize = kKeybindBgSize;
		vKeybindMenuSize += cVector2f(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_Keybind,0); // Edit this to minimize space between label and btn
		cVector2f vRightAnchor = cVector2f(kKeybindBgPos.x+vKeybindMenuSize.x-40,0);
		
		cVector2f kKeybindMenuFrameSize = cVector2f(vKeybindMenuSize.x-75, 382);
		cVector2f kKeybindMenuScrollPos = cVector2f(kKeybindBgPos.x+vKeybindMenuSize.x-40, kKeybindButtonPos.y);
		cVector2f kKeybindScrollSize = cVector2f(15, kKeybindMenuFrameSize.y);

		tString sBkg = OptionMenu_GetBackground(OptionMenu_GetScaledSize(vKeybindMenuSize));
		cImGuiGfx gfx = cImGuiGfx(sBkg, eGuiMaterial_Alpha, eImGuiGfx_TextureTemporary);
		gfx.mColor = cColor(1,mfTransitionAlpha);
		ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(kKeybindBgPos, 0.0), OptionMenu_GetScaledSize(vKeybindMenuSize));
		
		tString sFrame = OptionMenu_GetFrame(OptionMenu_GetScaledSize(kKeybindMenuFrameSize));
		cImGuiGfx gfxFrame = cImGuiGfx("startmenu_frame_load.tga", eImGuiGfx_Texture);
		gfxFrame.mColor = cColor(1,mfTransitionAlpha);
		ImGui_DrawGfx(gfxFrame, OptionMenu_GetTopLeftOffset(kKeybindFramePos, 0.5f), OptionMenu_GetScaledSize(kKeybindMenuFrameSize));
		
		cImGuiGfx gfxScrollBar = cImGuiGfx("startmenu_scrollbar_widget.tga", eImGuiGfx_Texture);
		gfxScrollBar.mColor = cColor(1,mfTransitionAlpha);

		////////////////
		// Get any duplicates
		array<bool> vDuplicates0;
		array<bool> vDuplicates1;
		bool bHasDuplicates = false;

		for(uint i = 0; i < vActions.size(); ++i)
		{
			//////////////
			// Check if this is a duplicate
			bool bDuplicate0 = false;
			bool bDuplicate1 = false;
			
			tString sBind = vActions[i].msAction;
			tString sPrimary = mpKeyConfig.GetString(sBind, sMain, "");
			tString sSecondary = mpKeyConfig.GetString(sBind, sSec, "");
			
			bool bCheck0 = sPrimary.length() != 0;
			bool bCheck1 = sSecondary.length() != 0;

			if(bCheck0 || bCheck1)
			{
				if(sSecondary == sPrimary)
				{
					bDuplicate0 = true;
					bDuplicate1 = true;
				}

				for(uint j = 0; j < vActions.size(); ++j)
				{
					if(i == j) continue;

					sBind = vActions[j].msAction;

					tString sComp0 = mpKeyConfig.GetString(sBind, sMain, "");
					tString sComp1 = mpKeyConfig.GetString(sBind, sSec, "");
					
					if(bCheck0 && (sComp0 == sPrimary || sComp1 == sPrimary)) bDuplicate0 = true;
					if(bCheck1 && (sComp0 == sSecondary || sComp1 == sSecondary)) bDuplicate1 = true;

					if((bCheck0 == false || bDuplicate0) && (bCheck1 == false || bDuplicate1)) break;
				}
			}
			
			vDuplicates0.push_back(bDuplicate0);
			vDuplicates1.push_back(bDuplicate1);
			if(bDuplicate0 || bDuplicate1) bHasDuplicates = true;
		}


		//////////////
		// Catch input
		int lActionVertical = 0;
		bool bMouseDown = false;
		float fPadding = mbScrollingKeybindList ? 10000 : 5;

		if(mlActionToBind == 0 && mbShowApplyKeyChanges == false && mbShowReset == false)
		{
			if(ImGui_ActionTriggered(eImGuiAction_Down, true)) lActionVertical++;
			if(ImGui_ActionTriggered(eImGuiAction_Up, true)) lActionVertical--;
			if(ImGui_ActionTriggered(eImGuiAction_ScrollDown, true) && (mlKeybindOffset + mlSelectedKeybindButton) < vActions.size()-1 && mlSelectedKeybindButton != lNumBinds) lActionVertical+=2;
			if(ImGui_ActionTriggered(eImGuiAction_ScrollUp, true) && (mlKeybindOffset + mlSelectedKeybindButton) > 0 && mlSelectedKeybindButton != lNumBinds) lActionVertical-=2;
			bMouseDown = ImGui_ActionIsDown(eImGuiAction_MouseLeft, false);
		}
		
		////////////////
		// Draw a list of all keybinds
		for(int i = mlKeybindOffset; i < vActions.size() && c < lNumBinds; ++i)
		{
			///////////////
			// Get action and parse the bind
			tString sBind = vActions[i].msAction;

			tString sPrimary = ParseKeybind(mpKeyConfig.GetString(sBind, sMain, ""), vActions[i].mbAnalog);
			tString sSecondary = ParseKeybind(mpKeyConfig.GetString(sBind, sSec, ""), vActions[i].mbAnalog);

			///////////////
			// Draw button, use red color if a duplicate is detected
			cColor color0 = vDuplicates0[i] ? cColor(1, 0, 0, 1) : cColor(0,1);
			cColor color1 = vDuplicates1[i] ? cColor(1, 0, 0, 1) : cColor(0,1);
			bool bDuplicate = vDuplicates0[i] || vDuplicates1[i];
			
			int lFocusChange = 0;
			int lButton = OptionMenu_ButtonKeybind("Bind"+c, sBind, sPrimary, sSecondary, kKeybindSlotsPos + cVector2f(26, c * kKeybindSpacing), mlSelectedKeybindButton == c, mlKeybindFocusSlot, lFocusChange, bDuplicate, vRightAnchor, cVector3f_Zero, mfTransitionAlpha);
			
			if(bMouseDown == false)
			{
				if (lFocusChange > 0)
				{
					mlSelectedKeybindButton = c;
					mlKeybindFocusSlot = lFocusChange-1;
				}
			}

			if(lButton > 0 && mlKeybindFocusSlot > 0)
			{
				if(bMouseDown == false || OptionMenu_GetMouseInside(kKeybindMenuScrollPos - cVector2f(fPadding, 0) + cVector2f(OptionMenu_GetExtraWidth(), 0), 
																	kKeybindMenuScrollPos + kKeybindScrollSize + cVector2f(10000, 0)).y == -1)
				{
					mlActionToBind = i+1;
					msKeybindSlot = mlKeybindFocusSlot == 1 ? sMain : sSec;
					msFocusAfterBind = "Bind"+c + msKeybindSlot;
					msKeybindFirstState = "";
				}
			}
			c++;
		}
		
		//////////////
		// Update focus
		if(lActionVertical != 0)
		{
			//////////
			// Select file
			if (lActionVertical<0)	// Scroll up
			{
				if(lActionVertical==-1)
				{
					if (mlSelectedKeybindButton==lNumBinds+1)	// Back button
					{
						mlSelectedKeybindButton = lNumBinds;
					}
					else if (mlSelectedKeybindButton==lNumBinds)
					{
						mlSelectedKeybindButton = lNumBinds-1;
					}
					else
					{
						mlSelectedKeybindButton--;
						if(mlSelectedKeybindButton < 0)
						{
							if(mlKeybindOffset > 0) 
							{
								mlSelectedKeybindButton = 0;
								mlKeybindOffset--;
							}
							else
							{
								mlSelectedKeybindButton = lNumBinds+1;
							}
						}
					}
				}
				else
				{
					// Scrolling with Wheel
					if(mlKeybindOffset > 0) 
					{
						mlKeybindOffset--;
					}
				}
			}
			else	// Scroll down
			{
				if(lActionVertical==1)
				{
					if (mlSelectedKeybindButton==lNumBinds)
					{
						mlSelectedKeybindButton = lNumBinds+1;
					}
					else if (mlSelectedKeybindButton==lNumBinds+1)	// Back button
					{
						mlSelectedKeybindButton = 0;
					}
					else
					{
						mlSelectedKeybindButton++;
						if(mlSelectedKeybindButton >= cMath_Min(vActions.size(),lNumBinds) )
						{
							if(mlKeybindOffset<vActions.size()-lNumBinds) 
							{
								mlSelectedKeybindButton--;
								mlKeybindOffset++;
							}
							else
							{
								///////////
								// No more files, scroll to back button
								mlSelectedKeybindButton = lNumBinds;
							}
						}
					}
				}
				else
				{
					// Scrolling with Wheel
					if(mlKeybindOffset<vActions.size()-lNumBinds) 
					{
						mlKeybindOffset++;
					}
				}
			}
		}
			
		//////////////
		// Left right focus
		if(mlActionHorizontal != 0 || lActionVertical!=0)
		{
			mlKeybindFocusSlot = cMath_Clamp(mlKeybindFocusSlot + mlActionHorizontal, 1, 2);
		}

		//////////////
		// Scroll bar
		if(vActions.size() > lNumBinds)
		{
			////////////
			// Update input
			float fFiles = vActions.size();
			int lOldOffset = mlKeybindOffset;
			
			cVector2f vMouseScrollMin = kKeybindMenuScrollPos - cVector2f(fPadding, 0);
			cVector2f vMouseScrollMax = kKeybindMenuScrollPos + kKeybindScrollSize + cVector2f(fPadding, 0);
			float fMouseScrollY = OptionMenu_GetMouseInside(vMouseScrollMin, vMouseScrollMax).y;

			if(fMouseScrollY != -1.0)
			{
				///////////
				// Mouse touching scroll, check if button pressed
				if(bMouseDown)
				{
					mlKeybindOffset = cMath_RoundToInt((fFiles-lNumBinds) * fMouseScrollY); // TO DO: Check if numbinds is correct
					mbScrollingKeybindList = true;
				}
			}

			if(bMouseDown == false)
			{
				////////
				// Stopped scrolling
				mbScrollingKeybindList = false;
			}

			mlKeybindOffset = cMath_Clamp(mlKeybindOffset, 0, vActions.size() - lNumBinds);

			if(mlSelectedKeybindButton >= 0 && mlSelectedKeybindButton < lNumBinds && (mlSaveFileOffset - lOldOffset) != 0)
			{
				int lDiff = (mlKeybindOffset - lOldOffset);
				mlSelectedKeybindButton = cMath_Clamp(mlSelectedKeybindButton - lDiff, 0, lNumBinds-1);
			}

			float fScaleY = 1.0 - (fFiles - lNumBinds) / fFiles;
			float fPosY = 0;
			if (fFiles>lNumBinds)
				fPosY = (mlKeybindOffset) / (fFiles-lNumBinds);
			//ImGui_DrawGfx(gfxScrollBar, OptionMenu_GetTopLeftOffset(kKeybindMenuScrollPos + kKeybindScrollSize * cVector2f(0, (1.0 - fScaleY) * fPosY) + cVector2f(OptionMenu_GetExtraWidth(), 0), 0.01), OptionMenu_GetScaledSize(kKeybindScrollSize * cVector2f(1, fScaleY)), ((fMouseScrollY == -1.0f && mbScrollingKeybindList == false) || (mlActionToBind > 0 || mbShowApplyKeyChanges || mbShowReset)) ? kMainMenuButtonBgColor : cColor(1,1));
			ImGui_DrawGfx(gfxScrollBar, OptionMenu_GetTopLeftOffset(kKeybindMenuScrollPos + kKeybindScrollSize * cVector2f(0, (1.0 - fScaleY) * fPosY), 0.01), OptionMenu_GetScaledSize(kKeybindScrollSize * cVector2f(1, fScaleY)), ((fMouseScrollY == -1.0f && mbScrollingKeybindList == false) || (mlActionToBind > 0 || mbShowApplyKeyChanges || mbShowReset)) ? kMainMenuButtonBgColor*cColor(1,mfTransitionAlpha) : cColor(1,mfTransitionAlpha));
		
		}
		
		tString sSelected;
		if(mlSelectedKeybindButton < lNumBinds) sSelected = ("Bind"+mlSelectedKeybindButton);
		else if(mlSelectedKeybindButton == lNumBinds) sSelected = "ResetToDefault";
		else sSelected = "Back";
		
		/////////////////
		// Reset to default
		{
			if(OptionMenu_ButtonOptions("ResetToDefault", kKeybindButtonPos+cVector2f(0, 100), 7, sSelected, true, cVector2f_Zero, cVector3f_Zero, mfTransitionAlpha))
			{
				mbShowReset = true;
				msFocusNextFrame = "No";
			}

			if(bMouseDown == false)
			{
				if (ImGui_PrevBecameInFocus())
				{
					//cLux_AddTodoMessage("Sound: Menu focus changed");
					//Sound_PlayGui("special_fx/frontend/frontend_menu_focus", 1.0f, eSoundEntryType_Gui);
					mlSelectedKeybindButton = lNumBinds;
				}
			}
		}
		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kKeybindButtonPos+ cVector2f(0, 100)+kBackMargin, 8, sSelected, true, cVector2f_Zero, cVector3f_Zero, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			if(bButton || bGamepad)
			{
				if(mbKeybindChanged == false)
				{
					//mCurrentGroup = mKeyBindBackDest;
					//msFocusNextFrame = msKeyBindBackFocus;
					
					mTargetGroup = mPrevGroup;
					msTargetFocus = msSelectedOptionsButton;
					
					if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
				}
				else
				{
					mbShowDuplicateKeys = bHasDuplicates;
					mbShowApplyKeyChanges = true;
					msFocusNextFrame = "No";
				}

				////////
				// Reset menu pos
				if(bGamepad == false)
				{
					mlSelectedKeybindButton = 0;
				}
				
				OptionMenu_ShowGamepadButtons(true);
				return;
			}

			if(bMouseDown == false)
			{
				if (ImGui_PrevBecameInFocus())
				{
					//cLux_AddTodoMessage("Sound: Menu focus changed");
					//Sound_PlayGui("special_fx/frontend/frontend_menu_focus", 1.0f, eSoundEntryType_Gui);
					mlSelectedKeybindButton = lNumBinds+1;
				}
			}
		}

		///////////
		// Manual focus since we catch input
		if(mlActionToBind == 0 && mbShowApplyKeyChanges == false && mbShowReset == false)
		{
			if(mlSelectedKeybindButton >= 0 && mlSelectedKeybindButton < lNumBinds)
			{
				if(mlKeybindFocusSlot == 0) msFocusNextFrame = "Bind"+mlSelectedKeybindButton;
				if(mlKeybindFocusSlot == 1) msFocusNextFrame = "Bind"+mlSelectedKeybindButton+"Primary";
				if(mlKeybindFocusSlot == 2) msFocusNextFrame = "Bind"+mlSelectedKeybindButton+"Secondary";
			}
			else if(mlSelectedKeybindButton == lNumBinds)
			{
				msFocusNextFrame = "ResetToDefault";				
			}
			else						
			{						 
				msFocusNextFrame = "Back";
			}
		}
		
		if(mbKeybindChanged == false && mbShowReset == false)
			GuiHandleTransition(0.05f, 0.05f, mTargetGroup, msTargetFocus);

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
		
		OptionMenu_ResetExtraWidth();
		
		// END KEYBINDINGS
	}
	
	//-------------------------------------------------------
	
	tString msOldProfile;
	tString msOldPreset;
	
	array<tString> mvProfileValues = { "X360 Controller", "PS4 Controller", "Custom" };
	array<tString> mvPresetValues = { "GamepadPreset1", "GamepadPreset3" };
		
	//------------------------------------------------------- 
	
	void GuiOptionsInputGamepadPresets()
	{
		GuiPauseDarkOverlay();
		
		// Gamepad Presets are defined in Dev_user_keys.cfg, as well as in the Input Handler 
		
		cVector2f vGamepadPresetMenuPos = kOptionsBgPos+cVector2f(0,-100);
		cVector2f vGamepadPresetMenuSize = Platform_IsConsole() ? kMappingSize_PS4 : kMappingSize;
		cVector2f vRightAnchor = cVector2f(vGamepadPresetMenuPos.x+468,0);
		
		tString sBkg = "mainmenu_submenu_backdrop_controller_1460x900";
		cImGuiGfx gfx = cImGuiGfx(sBkg, eGuiMaterial_Alpha, eImGuiGfx_TextureTemporary);
		gfx.mColor = cColor(1,mfTransitionAlpha);
		ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(vGamepadPresetMenuPos, 0.0), OptionMenu_GetScaledSize(vGamepadPresetMenuSize));
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Controls", vGamepadPresetMenuPos, vGamepadPresetMenuSize);
		
		/////////////////
		// Draw preset
		tString sDefaultProfile = Platform_IsConsole() ? gvGamepadProfileValues[eGamepadProfile_PS4] : gvGamepadProfileValues[eGamepadProfile_X360];
		tString sDefaultPreset = gvGamepadPresetValues[eGamepadPreset_1];
		
		tString sProfile = mpKeyConfig.GetString("GamepadMapping", "Profile", sDefaultProfile);
		tString sPreset = mpKeyConfig.GetString("GamepadMapping", "Preset", sDefaultPreset);

		///////////////
		// Validation
		
		sProfile = (gvGamepadProfileValues.find(sProfile) == -1) ? sDefaultProfile : sProfile;
		sPreset = (gvGamepadPresetValues.find(sPreset) == -1) ? sDefaultPreset : sPreset;
		
		////////////////
		// Get current selection
		int lId = 0;
		int lProfileId = 0;
		array<tString> vsProfilePresets;

		for (int i = 0; i < mvPresetValues.length(); i++)
		{
			vsProfilePresets.push_back(sProfile);
			vsProfilePresets.push_back(mvPresetValues[i]);
		}
		
		//  0       1       2      3       4      5      6      7      8      9     10     11      12      13      14       15     16      17
		// XBOX, PRESET1, XBOX, PRESET2, XBOX, PRESET3, PS4, PRESET1, PS4, PRESET2, PS4, PRESET3, OTHER, PRESET1, OTHER, PRESET2, OTHER, PRESET3
		
		// 0 = XBOX P1; 2 = XBOX P2; 4 = XBOX P3; 6 = PS4 P1; 8 = PS4 P2; 10 = PS4 P3; 12 = OTHER P1; 14 = OTHER P2; 16 = OTHER P3
		
		for(int i = 0; i < vsProfilePresets.length(); i+=2)
		{
			if(vsProfilePresets[i] == sProfile && vsProfilePresets[i+1] == sPreset)
			{
				lId = i / 2;
				break;
			}
		}
		
		// lId
		// 0 = XBOX P1; 1 = XBOX P2; 2 = XBOX P3; 3 = PS4 P1; 4 = PS4 P2; 5 = PS4 P3; 6 = OTHER P1; 7 = OTHER P2; 8 = OTHER P3
		
		/*for (int i = 0; i < vProfileValues.length(); i++)
		{
			if (sProfile == "X360 Controller")
			{
				lProfileId = 0;
			}
			else if (sProfile == "PS4 Controller")
			{
				lProfileId = 3;
			}
			else
			{
				lProfileId = 6;
			}
		}*/
		
		if(ImGui_IsFading("PresetTransition"))
		{
			float fAlpha = ImGui_GetStateFloat("PresetTransition");
			GuiOptionsInputMappingGamepadProfile(sProfile, sPreset, fAlpha, false);
			GuiOptionsInputMappingGamepadProfile(msOldProfile, msOldPreset, 1.0f-(fAlpha*3.0f), false);
		}
		else
		{
			GuiOptionsInputMappingGamepadProfile(sProfile, sPreset, 1.0f, false);
		}
		
		///////////////////////
		// Preset Selection
		/*{
			
			int lPresetId = lId;
			//cLux_AddDebugMessage("PRESET ID: "+lPresetId);
			int lNewPresetId = OptionMenu_ButtonOptionsMultiSelect("GamepadPreset", vGamepadPresetMenuPos+cVector2f(60,0), 10, msSelectedInputMappingButton, mvPresetValues, lPresetId, false, mlActionHorizontal, "Menu", 0, vRightAnchor, cVector3f_Zero, mfTransitionAlpha);
			//cLux_AddDebugMessage("NEW: "+lNewPresetId);
			
			if (lPresetId != lNewPresetId)
			{
				lId = lNewPresetId;
				
				mpKeyConfig.SetString("GamepadMapping", "Profile", vsProfilePresets[lId * 2]);
				mpKeyConfig.SetString("GamepadMapping", "Preset", vsProfilePresets[lId * 2 + 1]);
				mbKeybindChanged = true;
					
				msOldProfile	= sProfile;
				msOldPreset		= sPreset;
					
				//ImGui_SetStateFloat("PresetTransition", 0.0f);
				//ImGui_FadeStateFloat("PresetTransition", 1.0f, 0.75f);
					
				//ImGui_SetStateFloat("PresetTransitionRight", 1.0f);
				//ImGui_FadeStateFloat("PresetTransitionRight", 0.0f, 0.5f);
	
			}
			
			msSelectedInputMappingButton = OptionMenu_UpdateFocus("GamepadPreset", msSelectedInputMappingButton);
		}*/
		
		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", vGamepadPresetMenuPos+cVector2f(60,0), 11, msSelectedInputMappingButton, true, cVector2f_Zero ,cVector3f_Zero, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				if(mbKeybindChanged == false)
				{					
					mTargetGroup = eMainMenuGroup_Options_Controls;
					msTargetFocus = msSelectedOptionsButton;
					
					if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
					
				}
				else
				{
					mbShowApplyKeyChanges = true;
					msFocusNextFrame = "No";
				}

				//////////
				// Reset menu pos
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(false);
					msSelectedInputMappingButton = "Back";
					return;
				}
			}

			msSelectedInputMappingButton = OptionMenu_UpdateFocus("Back", msSelectedInputMappingButton);
		}
		
		if(mbShowApplyKeyChanges == false)
			GuiHandleTransition(0.05f, 0.05f, mTargetGroup, msTargetFocus);

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//------------------------------------------------------- 
	
	cVector2f mvButtonPos, mvLabelPos;
	void GuiOptionsInputMappingGamepadProfile(const tString &in asProfile, const tString &in asPreset, float afAlpha, bool abFadeController)
	{		
		cVector3f vReferencePos = OptionMenu_GetTopLeftOffset(Platform_IsConsole() ? kMappingPos_PS4 : kMappingPos, 1.0);
		cVector2f vFrameSize = OptionMenu_GetScaledSize(Platform_IsConsole() ? kGamepadPresetSize_PS4 : kGamepadPresetSize);

		cVector2f vControllerSize = vFrameSize;
		float fControllerAlpha = Platform_IsConsole() ? kMappingGamepadAlpha_PS4 : kMappingGamepadAlpha;
		
		float fGfxHeight = vFrameSize.y;
		fGfxHeight *= Platform_IsConsole() ? kMappingGfxHeightMul_PS4 : kMappingGfxHeightMul;
		float fEntrySeparation = fGfxHeight*1.0f;
		
		cImGuiGfx gfxController;
		array<cVector3f> vControlGroupPositions;
		
		GetGamepadProfileLayout(asProfile, gfxController, vControlGroupPositions, vReferencePos, vFrameSize, fGfxHeight, fEntrySeparation);
		
		ImGui_SetModColorMul(cColor(0, fControllerAlpha*afAlpha*mfTransitionAlpha));
		ImGui_SetAlignment(eImGuiAlign_CenterCenter);
		ImGui_DoImage(gfxController, vReferencePos+cVector3f(vFrameSize.x, vFrameSize.y,0)*0.5f, vControllerSize);
		ImGui_SetAlignment(eImGuiAlign_TopLeft);
		
		ImGui_SetModColorMul(cColor(1, afAlpha)*cColor(1,mfTransitionAlpha));
		
		vReferencePos.z += 1.0f;
		
		cImGuiLabelData labelData;
		labelData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu_InfoBox, 56));
		labelData.mFont.mvSize = cVector2f(14);
		labelData.mFont.mColor = cColor(0,1);
		labelData.mFontAlign = eFontAlign_Center;
		
		// Button Colors (Xbox used as reference)
		cColor colButtonA = Platform_IsConsole() ? cColor(0.42,0.54,0.78,1) : cColor(0,0.8,0.4,1);
		cColor colButtonB = Platform_IsConsole() ? cColor(1,0.4,0.4,1) : cColor(1,0.4,0.4,1);
		cColor colButtonY = Platform_IsConsole() ? cColor(0.19,0.87,0.6,1) : cColor(0.9,0.78,0.11,1);
		cColor colButtonX = Platform_IsConsole() ? cColor(0.87,0.55,0.75,1) : cColor(0.04,0.57,0.78,1);
		
		// Left shoulder buttons
		cVector3f vPos = vControlGroupPositions[0];
		
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Axis.4.Positive", labelData, vPos, fGfxHeight, false);
		vPos.y += fEntrySeparation;
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.9", labelData, vPos, fGfxHeight, false);
	
		// Right shoulder buttons
		vPos = vControlGroupPositions[1];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Axis.5.Positive", labelData, vPos, fGfxHeight);
		vPos.y += fEntrySeparation;
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.10", labelData, vPos, fGfxHeight);
		
		// Select
		vPos = vControlGroupPositions[2];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.4", labelData, vPos, fGfxHeight, false);
		
		// Start
		vPos = vControlGroupPositions[3];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.6", labelData, vPos, fGfxHeight);
		
		// D-Pad Up
		vPos = vControlGroupPositions[4];
		//DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.11", labelData, vPos, fGfxHeight, false);
		//vPos.y += fEntrySeparation;
		// D-Pad Down
		//DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.12", labelData, vPos, fGfxHeight, false);
		vPos.y += fEntrySeparation;
		// D-Pad Left
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.13", labelData, vPos, fGfxHeight, false);
		vPos.y += fEntrySeparation;
		// D-Pad Right
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.14", labelData, vPos, fGfxHeight, false);
		
		vPos = vControlGroupPositions[5];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.7", labelData, vPos, fGfxHeight, false);
		
		vPos = vControlGroupPositions[6];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.8", labelData, vPos, fGfxHeight);
		
		// A
		vPos = vControlGroupPositions[7];
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.0", labelData, vPos, fGfxHeight, true, colButtonA);
		vPos.y += fEntrySeparation;
		// B
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.1", labelData, vPos, fGfxHeight, true, colButtonB);
		vPos.y += fEntrySeparation;
		// Y
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.3", labelData, vPos, fGfxHeight, true, colButtonY);
		vPos.y += fEntrySeparation;
		// X
		DrawGamepadButtonActionPair(asProfile, asPreset, "Gamepad.0.Button.2", labelData, vPos, fGfxHeight, true, colButtonX);
		
		ImGui_ResetModifiers();
	}
	
	void GetGamepadProfileLayout(const tString &in asProfile, cImGuiGfx &out aGfxController, array<cVector3f> &out avControlGroupPositions, const cVector3f &in avReferencePos, const cVector2f &in avReferenceSize, float afGfxHeight, float afEntrySeparation)
	{		
		// Draw controller image and set buttons positions
		
		if(asProfile==gvGamepadProfileValues[eGamepadProfile_X360])
		{
			aGfxController = cImGuiGfx("controller_XBOX.tga", eImGuiGfx_Texture);
			
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.25f, afGfxHeight, 0));						// 0 Left shoulder
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.75f, afGfxHeight, 0));						// 1 Right shoulder
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.475f, afGfxHeight, 0));						// 2 Back
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.525f, afGfxHeight, 0));						// 3 Start
			avControlGroupPositions.push_back(avControlGroupPositions[0]+cVector3f(0,afEntrySeparation*4.0f,0.0f));						// 4 DPAD
			avControlGroupPositions.push_back(avControlGroupPositions[0]+cVector3f(0,afEntrySeparation*2.5f,0.0f));						// 5 Left stick
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.575f, avReferenceSize.y*0.9f, 0));			// 6 Right stick
			avControlGroupPositions.push_back(avControlGroupPositions[1]+cVector3f(0, afGfxHeight+afEntrySeparation*2.0f, 0));			// 7 Action button block
		}
		else if(asProfile==gvGamepadProfileValues[eGamepadProfile_PS4])
		{
			aGfxController = cImGuiGfx("controller_PS4.dds", eImGuiGfx_Texture);
					
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.025f, -avReferenceSize.y*0.05f, 0));						// 0 Left shoulder
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*1.0f, -avReferenceSize.y*0.05f, 0));						// 1 Right shoulder
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.475f, -avReferenceSize.y*0.05f, 0));						// 2 Back
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.525f, -avReferenceSize.y*0.05f, 0));						// 3 Start
			avControlGroupPositions.push_back(avControlGroupPositions[0]+cVector3f(0, afEntrySeparation*3.0f,0.0f));					// 4 DPAD
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.425f, avReferenceSize.y*0.75f,0.0f));			// 5 Left stick
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.575f, avReferenceSize.y*0.75f, 0));			// 6 Right stick
			avControlGroupPositions.push_back(avControlGroupPositions[1]+cVector3f(0, afGfxHeight+afEntrySeparation*2.0f, 0));			// 7 Action button block
		}
		else
		{
			aGfxController = cImGuiGfx();
			aGfxController.mColor = cColor(0.3f, 0.3f);
			
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.25f, afGfxHeight, 0));						// 0 Left shoulder
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.75f, afGfxHeight, 0));						// 1 Right shoulder
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.475f, afGfxHeight, 0));						// 2 Back
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.525f, afGfxHeight, 0));						// 3 Start
			avControlGroupPositions.push_back(avControlGroupPositions[0]+cVector3f(0, afEntrySeparation*3.0f,0.0f));					// 4 DPAD
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.425f, avReferenceSize.y*0.9f,0.0f));			// 5 Left stick
			avControlGroupPositions.push_back(avReferencePos+cVector3f(avReferenceSize.x*0.575f, avReferenceSize.y*0.9f, 0));			// 6 Right stick
			avControlGroupPositions.push_back(avControlGroupPositions[1]+cVector3f(0, afGfxHeight+afEntrySeparation*2.0f, 0));			// 7 Action button block
		}
	}
	
	//------------------------------------------------------- 
	
	void DrawGamepadButtonActionPair(const tString &in asProfile, const tString &in asPreset, const tString &in asGamepadString, 
									const cImGuiLabelData &in aLabelData, const cVector3f &in avPosition, float afGfxHeight, bool abLeftToRight=true, cColor aColor=cColor_White)
	{
		tString sActions;
		array<tString> vIgnoredActions = {	"MenuUp", 
											"MenuDown", 
											"MenuLeft", 
											"MenuRight", 
											"MenuCancel", 
											"MenuConfirm", 
											"GamepadBack", 
											"GamepadRotateUp", 
											"GamepadRotateDown", 
											"GamepadRotateLeft", 
											"GamepadRotateRight", 
											"InteractCancel", 
											"SketchbookPrevTab", 
											"SketchbookNextTab",
											"InventoryUse",
											"InventoryAdjustStack",
											"InventoryCombine"
										};
		
		cLux_GetInputHandler().GetActionsAssociatedToGamepadControl(asProfile, asPreset, asGamepadString, sActions);

		if(sActions.length()==0) 
		{	
			Error("No actions found for profile "+asProfile);
			return;
		}
					
		float fLabelSeparation = afGfxHeight*1.25f;
		
		array<tString> vActions;
		cString_GetStringVec(sActions, vActions, "/");
				
		float fLabelMaxLength = -1.0f;
		array<tWString> vActionLabels;
		
		for(int i=0; i<vActions.size(); ++i)
		{
			bool bSkip = false;
			for (int j = 0; j < vIgnoredActions.length(); j++)
			{
				if (vActions[i] == vIgnoredActions[j])
				{
					bSkip = true;
					break;
				}
			}
			
			if (bSkip) continue;
			
			tWString sActionLabel = cResources_Translate("Actions", vActions[i]);
			if (sActionLabel.length()==0)
				continue;
				
			
			vActionLabels.push_back(sActionLabel);
			
			float fActionLabelLength = GetFontLengthW(aLabelData.mFont, 1.0f, sActionLabel);
			
			if(fLabelMaxLength<fActionLabelLength)
				fLabelMaxLength = fActionLabelLength;
		}
				
		tString sProfilePrefix, sInputLayoutString;
		cLux_GetInputHandler().FetchGamepadInputLayoutString(asGamepadString, sProfilePrefix, sInputLayoutString);
		//cLux_AddDebugMessage(sProfilePrefix);
		array<tString> vGfxParts;
		cString_GetStringVec(sInputLayoutString, vGfxParts, ",");
		
		cVector3f vPosition = avPosition;
		vPosition.z += vGfxParts.length()*0.01f;
		
		eImGuiAlign align = eImGuiAlign_CenterRight;
		if(abLeftToRight)
		{
			align = eImGuiAlign_CenterLeft;
		}
		else
		{
			align = eImGuiAlign_CenterRight;
		}
				
		ImGui_SetAlignment(align);
		
		// Draw icons
		for(int i=0; i<vGfxParts.length(); ++i)
		{
			tString sGfxFile = sProfilePrefix + "/" + vGfxParts[i];
			cImGuiGfx gfxControl(sGfxFile, eImGuiGfx_Texture);
			cVector2f vControlSize = ImGui_GetRatioCorrectSizeByHeight(gfxControl, afGfxHeight);
			gfxControl.mColor = aColor;
			ImGui_DoImage(gfxControl, vPosition, vControlSize);
		
			vPosition.z -= 0.01f;
		}
		
		cVector2f vLayoutSize = cVector2f(0, vActionLabels.length()*aLabelData.mFont.mvSize.y+2.0f);

		cVector3f vLayoutPos = avPosition;
		vLayoutPos.y -= vLayoutSize.y*0.5f;
		if(abLeftToRight)
		{
			vLayoutPos.x += fLabelSeparation;
			align = eImGuiAlign_TopLeft;
		}
		else
		{
			align = eImGuiAlign_TopRight;
			vLayoutPos.x -= fLabelSeparation;
		}
				
		ImGui_SetAlignment(align);
							
			
		ImGui_LayoutBegin(eImGuiLayout_Y, vLayoutPos, vLayoutSize);
			for(int i=0; i<vActionLabels.length(); ++i)
				cLux_GetCurrentImGui().DoLabel(vActionLabels[i], aLabelData);
		ImGui_LayoutEnd();
		
		ImGui_SetAlignment(eImGuiAlign_TopLeft);
	}


	//------------------------------------------------------- 
	
	void GuiOptionsDisplay()
	{
		
		GuiPauseDarkOverlay();
		
		array<tString> vMenuItems = {"Resolution", "ResolutionScale", "DynamicResolution", "DisplayMode", "VSync", "UpdateRate", "AllowSlowdowns", "FOV", "Options_Gamma", "Back"};
		array<tString> vDisplayValues = { "Fullscreen", "Windowed", "Borderless" };
		array<tString> vVSyncValues = { "On", "Adaptive", "Off" };
				
		for (int i=0; i<=vMenuItems.length()-1; i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_UpdateMultiSelectionExtraWidth(vDisplayValues);
		OptionMenu_UpdateMultiSelectionExtraWidth(vVSyncValues);
		OptionMenu_AlignExtraButtonWidth();
				
		////////////////////////////////////
		// Options background
		
		cVector2f vDisplayMenuPos = kOptionsDisplayBgPos;
		cVector2f vDisplayMenuSize = kOptionsDisplayBgSize+cVector2f(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_MultiSelect,0);
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vDisplayMenuPos.x+vDisplayMenuSize.x-40,0),0);
		cVector2f vRightAnchor = cVector2f(vDisplayMenuPos.x+vDisplayMenuSize.x-40,0);
		
		tString sBkg = OptionMenu_GetBackground(OptionMenu_GetScaledSize(vDisplayMenuSize));
		cImGuiGfx gfx = cImGuiGfx(sBkg, eGuiMaterial_Alpha, eImGuiGfx_TextureTemporary);
		gfx.mColor = cColor(1,mfTransitionAlpha);
		ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(vDisplayMenuPos, 0.0), OptionMenu_GetScaledSize(vDisplayMenuSize));
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Display", vDisplayMenuPos, vDisplayMenuSize);
		
		mlCurrentItemId = mlFirstItemId;
		
		/////////////////////////
		// Handles dynamic scrolling
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		DoScrollInput(vMenuItems);
		
		/////////////////
		// Resolution
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Get current resolution and update config
			int lResolution = GetCurrentResolution();
			int lNewResolution = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, mvResolutionValues, lResolution, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(lResolution != lNewResolution)
			{
				mlOptionChanges++;
				SetCurrentResolution(lNewResolution);
			}

			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Resolution Scale
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Get current resolution and update config
			float fResolutionScaleMin = 10;
			float fResolutionScaleMax = 200;
			float fValue = mpConfig.GetFloat("Screen", "ResolutionScale", 1) * 100;

			tString sTextValue = "" + (cMath_RoundToInt(fValue) / 5) * 5;

			fValue = (fValue - fResolutionScaleMin) / (fResolutionScaleMax - fResolutionScaleMin);
			float fNewValue = OptionMenu_ButtonOptionsSlider(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, fValue, 0.05, mlActionHorizontal, sTextValue, "", vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			if(fValue != fNewValue)
			{
				mlOptionChanges++;
				fNewValue = (fNewValue * (fResolutionScaleMax - fResolutionScaleMin) + fResolutionScaleMin) / 100;
				mpConfig.SetFloat("Screen", "ResolutionScale", fNewValue);
			}

			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Dynamic Resolution
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Screen", "DynamicResolution", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if (bValue != bNewValue)
			{
				mpConfig.SetBool("Screen", "DynamicResolution", bNewValue);
				mlOptionChanges++;
			}
			 
			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;

		/////////////////
		// Display Mode
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config

			tString sValue = cString_ToLowerCase(mpConfig.GetString("Screen", "FullScreen", "true"));

			int lValue = (sValue == "true") ? 0 : (sValue == "borderless" ? 2 : 1); 
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, vDisplayValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);

			if(lValue != lNewValue)
			{
				mlOptionChanges++;
				mpConfig.SetString("Screen", "FullScreen", (lNewValue == 0) ? "true" :
														   (lNewValue == 1	? "false" : "borderless"));
			}

			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// V-sync
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			tString sValue = cString_ToLowerCase(mpConfig.GetString("Screen", "Vsync", "true"));

			int lValue = (sValue == "true") ? 0 : (sValue == "adaptive" ? 1 : 2);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, vVSyncValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(lValue != lNewValue)
			{
				mlOptionChanges++;
				mpConfig.SetString("Screen", "Vsync",	(lNewValue == 0)	? "true" :
														(lNewValue == 1		? "adaptive" : "false"));
			}
			 
			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Framerate
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			int lValue = GetCurrentRefreshRate();
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, mvRefreshValues, lValue, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(lValue != lNewValue)
			{
				mlOptionChanges++;
				SetCurrentRefreshRate(lNewValue);
			}
			 
			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Min update rate
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Engine", "AllowSlowdowns", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if (bValue != bNewValue)
			{
				mpConfig.SetBool("Engine", "AllowSlowdowns", bNewValue);
				mlOptionChanges++;
			}
			 
			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// FOV
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			float fFOVMin = 50;
			float fFOVMax = 83;
			float fValue = mpConfig.GetFloat("Gameplay", "FOV", 70);

			float fAspectRatio = mpConfig.GetFloat("Screen", "Width", 1920) / mpConfig.GetFloat("Screen", "Height", 1080);
			float fHorizontalFov = 2.0f * cMath_ATan(cMath_Tan(cMath_ToRad(fValue) / 2.0f) * fAspectRatio);
			tString sTextValue = "" + cMath_RoundToInt(cMath_ToDeg(fHorizontalFov));

			fValue = (fValue - fFOVMin) / (fFOVMax - fFOVMin);
			float fNewValue = OptionMenu_ButtonOptionsSlider(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, fValue, 0.2f / 4.0f, mlActionHorizontal, sTextValue, "", vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(fValue != fNewValue)
			{
				mlOptionChanges++;
				fNewValue = fNewValue * (fFOVMax - fFOVMin) + fFOVMin;
				mpConfig.SetFloat("Gameplay", "FOV", fNewValue);
			}

			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;
				
		///////////////////////
		// Gamma
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos, mlCurrentItemId, msSelectedDisplayButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				mlCurrentResolution = GetCurrentResolution(); //keep track of resolution to be able to revert if invalid is selected
				mbShowingGammaMenu = true;
				
				mTargetGroup = eMainMenuGroup_Options_Display_Gamma;
				msTargetFocus = msSelectedOptionsButton;
				
				mbShowingGammaMenu = true;
			}
			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems, vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		mlCurrentItemId++;	
		//cLux_AddDebugMessage("OPTION CHANGES: "+mlOptionChanges+ "- CURRENT: "+mlCurrentOptionChange);
		/////////////////
		// Back
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bButton = OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDisplayButtonPos+kBackMargin, mlCurrentItemId, msSelectedDisplayButton, true, cVector2f_Zero, cVector3f_Zero, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				if(mlOptionChanges > 0)
				{
					// Changes has been made
					mbShowApplyChanges = true;
					msFocusNextFrame = "No";
				}
				else
				{
					// No changes
					mTargetGroup = eMainMenuGroup_Options;
					msTargetFocus = msSelectedOptionsButton;
					
					if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
				}
				
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mlLastInFocusRel = 0;
				mbScrolled = false;
				mbScrollDown = false;
				mbScrollUp = false;

				//////////
				// Reset menu poos
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(msSelectedDisplayButton != "Back");
					//msSelectedDisplayButton = "Resolution";
					return;
				}
			}

			msSelectedDisplayButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDisplayButton);
		}
		else
		{
			bool bBack = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			if (bBack)
			{
				
				if(mlOptionChanges > 0)
				{
					// Changes has been made
					mbShowApplyChanges = true;
					msFocusNextFrame = "No";
				}
				else
				{
					// No changes
					mCurrentGroup = eMainMenuGroup_Options;
					msFocusNextFrame = msSelectedOptionsButton;
					if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
				}
				
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mlLastInFocusRel = 0;
				mbScrolled = false;
				mbScrollDown = false;
				mbScrollUp = false;
			}
		}
		
		if (mbShowApplyChanges == false)
			GuiHandleTransition(0.05f, 0.05f, mTargetGroup, msTargetFocus);

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(msSelectedDisplayButton != "Back");
		
		DoScrollMask(-4);
	}
	
	//------------------------------------------------------- 
	
	void GuiOptionsGraphics()
	{
		GuiPauseDarkOverlay();
		
		array<tString> vMenuItems = {"AutoDetect","AA", "TextureQuality", "TextureFiltering", "ShadowQuality", "DirShadowQuality", "LanternShadows", "Reflection", "Refraction", "SkinShading", "TerrainQuality", "DepthOfField", "FilmGrain", "SSAO", "Bloom", "Back"};
		array<tString> vTextureValues = { "High", "Medium", "Low" };
		array<tString> vTextureFilterValues = { "Bilinear", "Trilinear", "Anis2x", "Anis4x", "Anis8x", "Anis16x" };
		array<tString> vShadowValues = { "Low", "Medium", "High", "VeryHigh" };
		array<tString> vDirShadowValues = { "Low", "Medium", "High", "VeryHigh" };
		array<tString> vReflectionValues = { "Off", "Static", "Dynamic" };
		array<tString> vAAValues = { "Off", "FXAA" };
		array<tString> vDOFValues = {"Low", "Medium", "High"};
				
		for (int i=0; i<=vMenuItems.length()-1; i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_UpdateMultiSelectionExtraWidth(vTextureValues);
		OptionMenu_UpdateMultiSelectionExtraWidth(vTextureFilterValues);
		OptionMenu_UpdateMultiSelectionExtraWidth(vShadowValues);
		OptionMenu_UpdateMultiSelectionExtraWidth(vDirShadowValues);
		OptionMenu_UpdateMultiSelectionExtraWidth(vReflectionValues);
		OptionMenu_UpdateMultiSelectionExtraWidth(vAAValues);
		OptionMenu_UpdateMultiSelectionExtraWidth(vDOFValues);
		OptionMenu_AlignExtraButtonWidth();
		
		cVector2f vGraphicsMenuPos = kOptionsGraphicsBgPos;
		cVector2f vGraphicsMenuButtonPos = kOptionsGraphicsButtonPos;
		cVector2f vGraphicsMenuSize = kOptionsGraphicsBgSize+cVector2f(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_MultiSelect,10);
		cVector2f vRightAnchor = cVector2f(vGraphicsMenuPos.x+vGraphicsMenuSize.x-40,0);
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vGraphicsMenuPos.x+vGraphicsMenuSize.x-30,0),0);
		
		
		//cLux_AddDebugMessage("MOUSE: "+cLux_GetCurrentImGui().GetMousePosition()+" - RIGHT ANCHOR: "+vRightAnchor);
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Options_Graphics", vGraphicsMenuPos, vGraphicsMenuSize);
		
		////////////////////////////////////
		// Options background
		
		tString sBkg = OptionMenu_GetBackground(OptionMenu_GetScaledSize(vGraphicsMenuSize));
		cImGuiGfx gfx = cImGuiGfx(sBkg, eGuiMaterial_Alpha, eImGuiGfx_TextureTemporary);
		gfx.mColor = cColor(1,mfTransitionAlpha);
		ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(vGraphicsMenuPos, 0.0), OptionMenu_GetScaledSize(vGraphicsMenuSize));
		
		mlOptionItemId = 0;
		
		mlCurrentItemId = mlFirstItemId;
		
		/////////////////////////
		// Handles dynamic scrolling
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		DoScrollInput(vMenuItems);
		//OptionMenu_SetOutOfLimit(7);
		//DoScrollInputNew(vMenuItems, mlCurrentItemId, vGraphicsMenuPos, vGraphicsMenuSize, vGraphicsMenuButtonPos);
		
		cVector2f vItemSpacing = cVector2f(0,-3);
		
		/////////////////
		// Auto Detect
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			if (OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				/////////////
				// Show detect settings popup
				mbShowDetectSettings = true;
				msFocusNextFrame = "NO";
				mlCurrentOptionChange = mlOptionChanges; //keep track of number of changes that have been made, determines if "Apply Changes" window should show
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		/////////////////
		// AA
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select box and update config
			tString sValue = mpConfig.GetString("Graphics", "AntiAliasing", "FXAA");

			int lValue = (sValue == "FXAA") ? 1 : 0;
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vAAValues, lValue, true, mlActionHorizontal, "Menu" ,0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(lValue != lNewValue)
			{
				mlOptionChanges++;
				mpConfig.SetString("Graphics", "AntiAliasing", vAAValues[lNewValue]);
			}
		
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Textures
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select box and update config
			int lValue = mpConfig.GetInt("Graphics", "TextureQuality", 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vTextureValues, lValue, true, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(lValue != lNewValue)
			{
				mpConfig.SetInt("Graphics", "TextureQuality", lNewValue);
				mlOptionChanges++;
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;

		/////////////////
		// Textures Filtering
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select box and update config
			int lFilter = mpConfig.GetInt("Graphics", "TextureFilter", 0);
			int lAnis = mpConfig.GetInt("Graphics", "TextureAnisotropy", 0);

			int lValue = 0;

			if(lAnis < 2)
			{
				lValue = lFilter == 2 ? 1 : 0;
			}
			else
			{
				if(lAnis == 2)		lValue = 2;
				else if(lAnis == 4) lValue = 3;
				else if(lAnis == 8) lValue = 4;
				else				lValue = 5;
			}

			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vTextureFilterValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(lValue != lNewValue)
			{
				switch(lNewValue)
				{
				case 0:
					lAnis = 1;
					lFilter = 1;
					break;
				case 1:
					lAnis = 1;
					lFilter = 2;
					break;
				case 2:
					lAnis = 2;
					lFilter = 2;
					break;
				case 3:
					lAnis = 4;
					lFilter = 2;
					break;
				case 4:
					lAnis = 8;
					lFilter = 2;
					break;
				case 5:
					lAnis = 16;
					lFilter = 2;
					break;
				}

				mpConfig.SetInt("Graphics", "TextureFilter", lFilter);
				mpConfig.SetInt("Graphics", "TextureAnisotropy", lAnis);
				mlOptionChanges++;
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Shadows
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select and update config
			int lShadowQuality = mpConfig.GetInt("Graphics", "ShadowResolution", 2);
			int lValue = lShadowQuality;
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vShadowValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);

			if(lValue != lNewValue)
			{	
				mpConfig.SetBool("Graphics", "ShadowsActive", true);
				mpConfig.SetInt("Graphics", "ShadowResolution", lNewValue);
				mlOptionChanges++;
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Dir Light Shadows
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select and update config
			int lShadowQuality = mpConfig.GetInt("Graphics", "DirLightSliceNum", 4);
			int lValue = lShadowQuality-1;
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vShadowValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				
			if(lValue != lNewValue)
			{	
				mpConfig.SetInt("Graphics", "DirLightSliceNum", lNewValue + 1);
				mlOptionChanges++;
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;

		/////////////////
		// Lantern shadows
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select and update config
			bool bValue = mpConfig.GetBool("Graphics", "LanternShadowsActive", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				
			if (bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "LanternShadowsActive", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Reflection
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bWorldReflections = mpConfig.GetBool("Graphics", "WorldReflection", true);
			bool bIrradianceSpecular = mpConfig.GetBool("Graphics", "IrradianceSpecular", true);

			int lValue = (bWorldReflections ? 1 : 0) + (bIrradianceSpecular ? 1 : 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vReflectionValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				
			if(lValue != lNewValue)
			{
				mpConfig.SetBool("Graphics", "WorldReflection", lNewValue >= 2);
				mpConfig.SetBool("Graphics", "IrradianceSpecular", lNewValue >= 1);
				mlOptionChanges++;
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;

		/////////////////
		// Refraction
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Graphics", "Refraction", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "Refraction", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Skin Shading
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Graphics", "SkinShadingActive", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "SkinShadingActive", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Tesselation
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select and update config
			array<tString> vValues = { "Low", "Medium", "High", "VeryHigh" };
			int lValue = mpConfig.GetInt("Graphics", "TerrainQuality", 0);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
					
			if(lValue != lNewValue)
			{	
				mpConfig.SetInt("Graphics", "TerrainQuality", lNewValue);
				mpConfig.SetInt("Graphics", "TerrainTessellation", lNewValue);
				mlOptionChanges++;
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// DOF
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			/////////////
			// Draw multi select box and update config
			int lValue = mpConfig.GetInt("Graphics", "DepthOfFieldQuality", 2);
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, vDOFValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(lValue != lNewValue)
			{
				mpConfig.SetInt("Graphics", "DepthOfFieldQuality", lNewValue);
				mlOptionChanges++;
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		

		/////////////////
		// Film Grain
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Graphics", "FilmGrainActive", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "FilmGrainActive", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;

		/////////////////
		// SSAO
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Graphics", "SSAOActive", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "SSAOActive", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;

		/////////////////
		// Bloom
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Graphics", "BloomActive", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId), mlCurrentItemId, msSelectedGraphicsButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Graphics", "BloomActive", bNewValue);
				mlOptionChanges++;
			}
			
			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		mlCurrentItemId++;
		
		/////////////////
		// Back
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			bool bButton = OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], vGraphicsMenuButtonPos+(vItemSpacing*mlCurrentItemId)+kBackMargin, mlCurrentItemId, msSelectedGraphicsButton, true, cVector2f_Zero, cVector3f_Zero, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{

				// No changes
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mlLastInFocusRel = 0;
				mbScrolled = false;
				mbScrollDown = false;
				mbScrollUp = false;
				
				if(mlOptionChanges > 0)
				{
					// Changes has been made
					mbShowApplyChanges = true;
					msFocusNextFrame = "No";
				}
				else
				{
					// No changes
					mTargetGroup = eMainMenuGroup_Options;
					msTargetFocus = msSelectedOptionsButton;
					
					if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
					
				}



				//////////
				// Reset menu poos
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(msSelectedDisplayButton != "Back");
					msSelectedDisplayButton = "TextureQuality";
					return;
				}
			}

			msSelectedGraphicsButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedGraphicsButton);
		}
		else
		{
			bool bBack = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			if (bBack)
			{
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mlLastInFocusRel = 0;
				mbScrolled = false;
				mbScrollDown = false;
				mbScrollUp = false;
				
				if(mlOptionChanges > 0)
				{
					// Changes has been made
					mbShowApplyChanges = true;
					msFocusNextFrame = "No";
				}
				else
				{
					// No changes
					mTargetGroup = eMainMenuGroup_Options;
					msTargetFocus = msSelectedOptionsButton;
					
					//if (ImGui_TimerExists("TransitionOut") == false)
					//	ImGui_AddTimer("TransitionOut", 10);
				}
			}
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(msSelectedGraphicsButton != "Back");
		
		if (mbShowDetectSettings == false && mbShowApplyChanges == false)
			GuiHandleTransition(0.05f, 0.05f, mTargetGroup, msTargetFocus);
		
		DoScrollMask(-9);
		
	}
	
	//------------------------------------------------------
	
	void DoScrollMask(int alMin)
	{
		//////////////////////////
		// Create masks during scrolling
		
		/*if (mlFirstItemId != alMin)
		{
			cImGuiGfx gfxMask = cImGuiGfx("startmenu_submenu_backdrop_small_maskbottom.tga", eImGuiGfx_Texture);;
			ImGui_DrawGfx(gfxMask, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 2.0f), OptionMenu_GetScaledSize(kOptionsBgSize));
		}
		if (mlFirstItemId != 0)
		{
			cImGuiGfx gfxMask = cImGuiGfx("startmenu_submenu_backdrop_small_masktop.png", eImGuiGfx_Texture);;
			ImGui_DrawGfx(gfxMask, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 2.0f), OptionMenu_GetScaledSize(kOptionsBgSize));
		}*/
	}
	
	//------------------------------------------------------

	void GuiOptionsAudio()
	{
		GuiPauseDarkOverlay();
		
		////////////////////////////////////
		// Options background
		
		array<tString> vMenuItemsPC = {"Volume", "Subtitles", "SubtitleOptions"};
		array<tString> vMenuItemsPS4 = {"SpeakerType", "Volume", "Subtitles", "SubtitleOptions"}; 
		array<tString> vMenuItems = Platform_IsConsole() ? vMenuItemsPS4 : vMenuItemsPC;
		array<tString> vSpeakerValues = {"SmallTV", "MediumTV", "HomeCinema", "Headphones", "RemotePlay", "NightMode"};
		
		for (int i=0; i<=vMenuItems.length()-1; i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
				
		OptionMenu_UpdateToggleExtraWidth();
		cVector2f vBGSize = kOptionsAudioBgSize;

		if(Platform_IsConsole())
		{
			OptionMenu_UpdateMultiSelectionExtraWidth(vSpeakerValues);
			vBGSize = kOptionsAudioBgSizePS4;
		}
		OptionMenu_AlignExtraButtonWidth();

		////////////////////////////////////
		// Options background
		cVector2f vAudioMenuPos = kOptionsAudioBgPos;
		cVector2f vAudioMenuSize = vBGSize+cVector2f(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_MultiSelect,0);
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vAudioMenuPos.x+vAudioMenuSize.x-40,0),0);
		cVector2f vRightAnchor = cVector2f(vAudioMenuPos.x+vAudioMenuSize.x-40,0);
		
		tString sBkg = OptionMenu_GetBackground(OptionMenu_GetScaledSize(vAudioMenuSize));
		cImGuiGfx gfx = cImGuiGfx(sBkg, eGuiMaterial_Alpha, eImGuiGfx_TextureTemporary);
		gfx.mColor = cColor(1,mfTransitionAlpha);
		ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(vAudioMenuPos, 0.0), OptionMenu_GetScaledSize(vAudioMenuSize));
		
		////////////////
		// Audio
		OptionMenu_SectionTitle("Audio", vAudioMenuPos, vAudioMenuSize);
		
		mlCurrentItemId = mlFirstItemId;
		
		/////////////////////////
		// Handles dynamic scrolling
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		DoScrollInput(vMenuItems);

		/////////////////
		// Speaker type
		if(Platform_IsConsole())
		{
			if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
			{
				/////////////
				// Draw multi select box and update config
				tString sValue = mpConfig.GetString("Sound", "SpeakerType", "HomeCinema");
				int lValue =-1;
				for(int i=0;i<vSpeakerValues.size(); ++i)
				{
					if(sValue == vSpeakerValues[i]){
						lValue = i;
						break;
					}
				}
				
				int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAudioButtonPos, mlCurrentItemId, msSelectedAudioButton, vSpeakerValues, lValue, false, mlActionHorizontal, "Menu", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
				if(lValue != lNewValue)
				{
					mpConfig.SetString("Sound", "SpeakerType", vSpeakerValues[lNewValue]);
					ApplySettings(false);
				}

				msSelectedAudioButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAudioButton);
			}
			mlCurrentItemId++;
		}
		/////////////////
		// Volume
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			float fValue = mpConfig.GetFloat("Sound", "Volume", 1.0f);
			float fNewValue = OptionMenu_ButtonOptionsSlider(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAudioButtonPos, mlCurrentItemId, msSelectedAudioButton, fValue, 0.1f, mlActionHorizontal, "", "", vRightAnchor, vInfoBoxPos, mfTransitionAlpha);

			if(fNewValue != fValue)
			{
				mpConfig.SetFloat("Sound", "Volume", fNewValue);
				ApplySettings(false);
			}

			msSelectedAudioButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAudioButton);
		}
		mlCurrentItemId++;
		/////////////////
		// SUBTITLES
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Sound", "ShowSubtitles", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAudioButtonPos, mlCurrentItemId, msSelectedAudioButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Sound", "ShowSubtitles", bNewValue);
			}
			
			msSelectedAudioButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAudioButton);
		}
		mlCurrentItemId++;
		/////////////////////
		// SUBTITLE OPTIONS
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsAudioButtonPos, mlCurrentItemId, msSelectedAudioButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				mPrevGroup = eMainMenuGroup_Options_Audio;
				mTargetGroup = eMainMenuGroup_Options_Audio_Subtitles;
				msTargetFocus = msSelectedSubtitlesButton;
			}
			msSelectedAudioButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedAudioButton);
		}
		mlCurrentItemId++;
		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kOptionsAudioButtonPos+kBackMargin, mlCurrentItemId, msSelectedAudioButton, true, cVector2f_Zero, cVector3f_Zero, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				ApplySettings();
				
				if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
						
				mTargetGroup = eMainMenuGroup_Options;
				msTargetFocus = msSelectedOptionsButton;

				/////////
				// Reset menu position
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(msSelectedAudioButton != "Back");
					//msSelectedAudioButton = "Volume";
					return;
				}
			}

			msSelectedAudioButton = OptionMenu_UpdateFocus("Back", msSelectedAudioButton);
		}
		
		GuiHandleTransition(0.05f, 0.05f, mTargetGroup, msTargetFocus);

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(msSelectedAudioButton != "Back");
	}
	
	//-------------------------------------------------------
	
	void GuiOptionsAccessibility()
	{
		GuiPauseDarkOverlay();
		
		////////////////////////////////////
		// Options background
		
		cImGuiGfx gfx = cImGuiGfx("startmenu_submenu_backdrop_small.tga", eImGuiGfx_Texture);;
		ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(kOptionsAccessibilityBgSize));
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Options_Accessibility", kOptionsBgPos, kOptionsAccessibilityBgSize);

		mlOptionItemId = 0;
		
		/////////////////
		// Keybindings
		/*{
			if(OptionMenu_ButtonOptions("Keybind", kOptionsButtonPos, mlOptionItemId++, msSelectedAccessibilityButton))
			{
				mPrevGroup = eMainMenuGroup_Options_Accessibility;
				mCurrentGroup = eMainMenuGroup_Options_Input_Keybind;
				msFocusNextFrame = msSelectedAccessibilityButton;
				mbKeybindChanged = false;
				mbBindingGamepad = false;
				mKeyBindBackDest = eMainMenuGroup_Options_Input;
				msKeyBindBackFocus = msSelectedInputButton;
				
				mpKeyConfig.Save();
			}

			msSelectedAccessibilityButton = OptionMenu_UpdateFocus("Keybind", msSelectedAccessibilityButton);
		}*/
		{
			if(OptionMenu_ButtonOptions("SubtitleOptions", kOptionsButtonPos, mlOptionItemId, msSelectedAccessibilityButton))
			{
				mPrevGroup = eMainMenuGroup_Options_Accessibility;
				mCurrentGroup = eMainMenuGroup_Options_Audio_Subtitles;
				msFocusNextFrame = msSelectedSubtitlesButton;
			}
			msSelectedAccessibilityButton = OptionMenu_UpdateFocus("SubtitleOptions", msSelectedAccessibilityButton);
		}
		mlOptionItemId++;
		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kOptionsButtonPos+kBackMargin, mlOptionItemId, msSelectedAccessibilityButton);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				ApplySettings();
				mCurrentGroup = eMainMenuGroup_Options_Game;
				msFocusNextFrame = msSelectedOptionsButton;
			}

			msSelectedAccessibilityButton = OptionMenu_UpdateFocus("Back", msSelectedAccessibilityButton);
		}
		
		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
	}
	
	//-------------------------------------------------------
	
	int GetCurrentResolution()
	{
		cVector2l vResolution = cVector2l(mpConfig.GetInt("Screen", "Width", 1280), 
									      mpConfig.GetInt("Screen", "Height", 720));

		if(vResolution.x == -1 || vResolution.y == -1)
		{
			vResolution.x = cGraphics_GetLowLevel().GetScreenSizeInt().x;
			vResolution.y = cGraphics_GetLowLevel().GetScreenSizeInt().y;
		}

		for(int i = 0; i < mvResolutionSizes.size(); ++i)
		{
			if(vResolution == mvResolutionSizes[i])
			{
				return i;
			}
		} 

		////////////
		// Custom resolution
		mvResolutionSizes.push_back(vResolution);
		mvResolutionValues.push_back(""+vResolution.x + "x"+vResolution.y);

		return mvResolutionValues.size()-1;
	}

	void SetCurrentResolution(int aID)
	{
		aID = (aID + mvResolutionSizes.size()) % mvResolutionSizes.size();

		mpConfig.SetInt("Screen", "Width", mvResolutionSizes[aID].x);
		mpConfig.SetInt("Screen", "Height", mvResolutionSizes[aID].y);
	}
	
	int GetCurrentRefreshRate()
	{
		int lRate = mpConfig.GetInt("Screen", "RefreshRate", 0);

		if(lRate == 0)
		{
			lRate = mvRefresh[mvRefresh.size()-1];
		}

		for(int i = 0; i < mvRefresh.size(); ++i)
		{
			if(lRate == mvRefresh[i])
			{
				return i;
			}
		} 

		////////////
		// Custom resolution
		mvRefresh.push_back(lRate);
		mvRefreshValues.push_back(""+lRate);

		return mvRefreshValues.size()-1;
	}

	void SetCurrentRefreshRate(int aID)
	{
		aID = (aID + mvRefresh.size()) % mvRefresh.size();

		mpConfig.SetInt("Screen", "RefreshRate", mvRefresh[aID]);
	}

	//------------------------------------------------------
	
	int GetBaseQualityAMD(tString asPrefix, int alCardNumber)
	{
		if(asPrefix == "HD")
		{
			if(alCardNumber < 6600) return 0;
			if(alCardNumber < 7600) return 1;
			if(alCardNumber < 8600) return 2;
			if(alCardNumber < 9600) return 2;
		}
		else if(asPrefix == "R5")
		{
			return 0;
		}
		else if(asPrefix == "R7")
		{
			return 2;
		}
		else if(asPrefix == "R9")
		{
			return 3;
		}
		else if(asPrefix == "RX")
		{
			if(alCardNumber < 450) return 1;
			if(alCardNumber < 460) return 2;
			if(alCardNumber < 500) return 3;
			if(alCardNumber < 550) return 2;
			if(alCardNumber < 560) return 3;
			if(alCardNumber < 600) return 4;
			if(alCardNumber < 6000) return 4;

			return 4;
		}

		return -1;
	} 

	int GetBaseQualityNvidia(int alCardNumber)
	{
		if(alCardNumber < 100 || alCardNumber > 6000) return -1;

		if(alCardNumber < 450) return 0;
		if(alCardNumber < 550) return 1;
		if(alCardNumber < 650) return 2;
		if(alCardNumber < 750) return 3;
		if(alCardNumber < 6000) return 4;

		return -1;
	}
	
	int GetBaseQualityIntel(tString asPrefix, int alCardNumber)
	{
		if(asPrefix == "UHD")
		{
			if(alCardNumber < 620) return 0;
			if(alCardNumber < 630) return 1;
			if(alCardNumber < 700) return 2;
		}
		else if(asPrefix == "Iris" || asPrefix == "Plus")
		{
			return 2;
		}
		else if(asPrefix == "Xe")
		{
			return 2;
		}

		return -1;
	} 

	void GetQualityAndMemoryFromRenderer(int&out alQuality, int&out alVRAM, bool&out abDynamicResolution)
	{
		/////////////
		// Get and parse graphics info
		tString sGraphicsInfo = cGraphics_GetLowLevel().GetGraphicsInfo();
		Log("GraphicsInfo: " + sGraphicsInfo + "\n");
		array<tString> vInfo;
		cString_GetStringVec(sGraphicsInfo, vInfo, ";");

		alQuality = -1;
		alVRAM = -1;
		abDynamicResolution = false;

		if(vInfo.size() >= 5)
		{
			/////////////////
			// Parse vram
			array<tString> vVRAM;
			cString_GetStringVec(vInfo[4], vVRAM, " ");
			
			if(vVRAM.size() == 3)
			{
				alVRAM = cString_ToInt(vVRAM[1], -1);
			}
			else
			{
				// VRAM Parse failed, no need to continue
				return;
			}
					
			///////////////////
			// Get info about card
			array<tString> vCardName;
			cString_GetStringVec(vInfo[1], vCardName, " ,/\\");
			tString sModelPrefix;
			int lVersion = 0;
			bool bLaptop = false;

			for(uint i = 0; i < vCardName.size(); ++i)
			{
				//////////////
				// Check for mobile GPU
				int lPos = cString_GetFirstCharPos(vCardName[i], 'M');

				if(lPos == -1)
				{
					//////////////
					// Normal gpu
					lVersion = cString_ToInt(vCardName[i], 0);
				}
				else
				{
					//////////////
					// Check if its at the start or end
					if(lPos == 0)
					{
						lVersion = cString_ToInt(cString_Sub(vCardName[i], 1), 0);
						
						if(lVersion != 0) bLaptop = true;
					}
					else if(lPos == vCardName[i].length() - 1)
					{
						lVersion = cString_ToInt(cString_Sub(vCardName[i], 0, lPos), 0);

						if(lVersion != 0) bLaptop = true;
					}
				}

				if(lVersion != 0) break;

				sModelPrefix = vCardName[i];
			}

			Log("Card: " + vInfo[0] + " Model: " + sModelPrefix + " Version: " + lVersion + "\n");


			//////////////
			// Convert card to quality setting
			if(cString_GetFirstStringPos(vInfo[0], "NVIDIA") != -1)
			{
				alQuality = GetBaseQualityNvidia(lVersion);
			}
			else if(cString_GetFirstStringPos(vInfo[0], "AMD") != -1 || 
					cString_GetFirstStringPos(vInfo[0], "ATI") != -1 || 
					cString_GetFirstStringPos(vInfo[0], "Radeon") != -1)
			{
				alQuality = GetBaseQualityAMD(sModelPrefix, lVersion);
			}
			else if(cString_GetFirstStringPos(vInfo[0], "Intel") != -1)
			{
				// Special case for intel cards
				alQuality = GetBaseQualityIntel(sModelPrefix, lVersion);
				alVRAM = 1024;
				abDynamicResolution = true;
			}

			//////////////
			// Downgrade quality one level for laptops
			if(bLaptop)
			{
				if(alQuality >= 0)
					alQuality = cMath_Max(alQuality - 1, 0);
				abDynamicResolution = true;
			}

			//////////////
			// In case vram fails, set to max
			if(alVRAM == 0) alVRAM = 2048;
		}
	}
		
	void AutoDetectSettings(bool abSkipOnHigh)
	{
		if(Platform_IsConsole()) return;

		/////////////////////
		// Parse string to get quality and vram;
		int lBaseQuality;
		int lVRAM;
		bool bDynamicResolution;
		GetQualityAndMemoryFromRenderer(lBaseQuality, lVRAM, bDynamicResolution);
		
		/////////////////
		// Get qality based on vram and GPU card
		eGraphicSettings setting = eGraphicSettings_High;

		if(lVRAM > 0) //valid VRAM?
		{
			switch(lBaseQuality)
			{
			case 0:
				if(lVRAM < 1024)		setting = eGraphicSettings_Low;
				else if(lVRAM < 2048)	setting = eGraphicSettings_Low;
				else					setting = eGraphicSettings_Medium;
				break;
			case 1:
				if(lVRAM <= 1024)		setting = eGraphicSettings_Low;
				else if(lVRAM < 2048)	setting = eGraphicSettings_Medium;
				else					setting = eGraphicSettings_Medium;
				break;
			case 2:
				if(lVRAM <= 512)		setting = eGraphicSettings_Low;
				else if(lVRAM < 1024)	setting = eGraphicSettings_Medium;
				else if(lVRAM < 2048)	setting = eGraphicSettings_Medium;
				else					setting = eGraphicSettings_High;
				break;
			case 3:
				if(lVRAM < 512)			setting = eGraphicSettings_Low;
				else if(lVRAM < 1024)	setting = eGraphicSettings_Medium;
				else if(lVRAM < 2048)	setting = eGraphicSettings_High;
				else					setting = eGraphicSettings_High;
				break;
			case 4:
				if(lVRAM < 512)			setting = eGraphicSettings_Low;
				else if(lVRAM < 1024)	setting = eGraphicSettings_Medium;
				else if(lVRAM < 2048)	setting = eGraphicSettings_High;
				else					setting = eGraphicSettings_High;
				break;
			default:
				setting = eGraphicSettings_High; //Set to high if unsure
				break;
			}
		}

		tString sQuality;
		if(setting == eGraphicSettings_Low)		sQuality = "Low";
		if(setting == eGraphicSettings_Medium)	sQuality = "Medium";
		if(setting == eGraphicSettings_High)	sQuality = "High";
		
		Log("AutoDetect Quality: " +  sQuality + "; Base "+ lBaseQuality + "; VRAM " + lVRAM + " mb\n");

		////////////////////
		// Update config based on quality selected
		switch(setting)
		{
		case eGraphicSettings_High:
			//if(abSkipOnHigh) return;

			mpConfig.SetString("Graphics", "AntiAliasing", "FXAA");
			mpConfig.SetInt("Graphics", "TextureFilter", 2);
			mpConfig.SetInt("Graphics", "TextureAnisotropy", 16);
			mpConfig.SetInt("Graphics", "ShadowResolution", lBaseQuality >= 4 ? 3 : 2);
			mpConfig.SetBool("Graphics", "WorldReflection", true);
			mpConfig.SetBool("Graphics", "IrradianceSpecular", true);
			mpConfig.SetBool("Graphics", "Refraction", true);
			mpConfig.SetInt("Graphics", "DepthOfFieldQuality", 2);
			mpConfig.SetBool("Graphics", "LanternShadowsActive", true);
			mpConfig.SetInt("Graphics", "DirLightSliceNum", 4);
			mpConfig.SetBool("Graphics", "SSAOActive", true);
			mpConfig.SetBool("Graphics", "BloomActive", true);
			mpConfig.SetBool("Engine", "AllowSlowdowns", false);
			if(mpConfig.GetInt("Screen", "RefreshRate", 0) == 30) mpConfig.SetInt("Screen", "RefreshRate", 60);
			if(lBaseQuality >= 4) mpConfig.SetString("Screen", "Vsync", "true");
			else				  mpConfig.SetString("Screen", "Vsync", "adaptive");
			mpConfig.SetBool("Screen", "DynamicResolution", bDynamicResolution);
			mpConfig.SetBool("Graphics", "FilmGrainActive", true);
			mpConfig.SetBool("Graphics", "SkinShadingActive", true);
			mpConfig.SetInt("Graphics", "TerrainTessellation", cMath_Min(lBaseQuality, 3));
			break;
		case eGraphicSettings_Medium:
			mpConfig.SetString("Graphics", "AntiAliasing", "Off");
			mpConfig.SetInt("Graphics", "TextureFilter", 2);
			mpConfig.SetInt("Graphics", "TextureAnisotropy", 2);
			mpConfig.SetInt("Graphics", "ShadowResolution", 1);
			mpConfig.SetInt("Graphics", "DirLightSliceNum", 3);
			mpConfig.SetBool("Graphics", "LanternShadowsActive", false);
			mpConfig.SetBool("Graphics", "WorldReflection", false);
			mpConfig.SetBool("Graphics", "IrradianceSpecular", true);
			mpConfig.SetBool("Graphics", "Refraction", true);
			mpConfig.SetInt("Graphics", "DepthOfFieldQuality", 1);
			mpConfig.SetBool("Graphics", "SSAOActive", true);
			mpConfig.SetBool("Graphics", "BloomActive", true);
			mpConfig.SetBool("Engine", "AllowSlowdowns", false);
			if(mpConfig.GetInt("Screen", "RefreshRate", 0) == 30) mpConfig.SetInt("Screen", "RefreshRate", 60);
			mpConfig.SetString("Screen", "Vsync", "adaptive");
			mpConfig.SetBool("Screen", "DynamicResolution", bDynamicResolution);
			mpConfig.SetBool("Graphics", "FilmGrainActive", false);
			mpConfig.SetBool("Graphics", "SkinShadingActive", false);
			mpConfig.SetInt("Graphics", "TerrainTessellation", 0);
			break;
		case eGraphicSettings_Low:
			mpConfig.SetString("Graphics", "AntiAliasing", "Off");
			mpConfig.SetInt("Graphics", "TextureFilter", 2);
			mpConfig.SetInt("Graphics", "TextureAnisotropy", 0);
			mpConfig.SetInt("Graphics", "ShadowResolution", 0);
			mpConfig.SetInt("Graphics", "DirLightSliceNum", 1);
			mpConfig.SetBool("Graphics", "LanternShadowsActive", false);
			mpConfig.SetBool("Graphics", "WorldReflection", false);
			mpConfig.SetBool("Graphics", "IrradianceSpecular", false);
			mpConfig.SetBool("Graphics", "Refraction", false);
			mpConfig.SetInt("Graphics", "DepthOfFieldQuality", 0);
			mpConfig.SetBool("Graphics", "SSAOActive", false);
			mpConfig.SetBool("Graphics", "BloomActive", false);
			mpConfig.SetInt("Screen", "RefreshRate", 30);
			mpConfig.SetBool("Engine", "AllowSlowdowns", true);
			mpConfig.SetBool("Screen", "DynamicResolution", bDynamicResolution);
			mpConfig.SetString("Screen", "Vsync", "adaptive");
			mpConfig.SetBool("Graphics", "FilmGrainActive", false);
			mpConfig.SetBool("Graphics", "SkinShadingActive", false);
			mpConfig.SetInt("Graphics", "TerrainTessellation", 0);
			break;
		}


		//////////////////
		// Update texture quality based on just the VRAM
		if(lVRAM > 0) //valid VRAM?
		{
			if(lVRAM >= 1700)		
			{
				mpConfig.SetInt("Graphics", "TextureQuality", 0); //high
				mpConfig.SetInt("Graphics", "TerrainQuality", 3);
			}
			else if(lVRAM >= 512)	
			{
				mpConfig.SetInt("Graphics", "TextureQuality", 1); //medium
				mpConfig.SetInt("Graphics", "TerrainQuality", 2);
			}
			else
			{
				mpConfig.SetInt("Graphics", "TextureQuality", 2); //low
				mpConfig.SetInt("Graphics", "TerrainQuality", 0);
			}
		}

		///////////////
		// Apply config
		ApplySettings(true);
		mlCurrentResolution = GetCurrentResolution(); //keep track of resolution to be able to revert if invalid is selected
	}
	
	//------------------------------------------------------

	void GuiOptionsSubtitles()
	{
		GuiPauseDarkOverlay();
		
		array<tString> vMenuItems = {"Subtitles", "HearingAid", "AnimateSubtitles", "FadeSubtitlesOverDistance", "SubtitleSize", "SubtitleBGOpacity", "Back"};
		array<tString> vSubtitleSizeValues = {"Small", "Default", "Large", "VeryLarge"};
		
		for (int i=0; i<=vMenuItems.length()-1; i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_UpdateMultiSelectionExtraWidth(vSubtitleSizeValues);
		OptionMenu_AlignExtraButtonWidth();

		cVector2f vSubtitlesMenuPos = kOptionsBgPos;
		cVector2f vSubtitlesMenuSize = kOptionsSubtitlesBgSize+cVector2f(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_MultiSelect,0);
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vSubtitlesMenuPos.x+vSubtitlesMenuSize.x-40,0),0);
		cVector2f vRightAnchor = cVector2f(vSubtitlesMenuPos.x+vSubtitlesMenuSize.x-40,0);
		
		tString sBkg = OptionMenu_GetBackground(OptionMenu_GetScaledSize(vSubtitlesMenuSize));
		cImGuiGfx gfx = cImGuiGfx(sBkg, eGuiMaterial_Alpha, eImGuiGfx_TextureTemporary);
		gfx.mColor = cColor(1,mfTransitionAlpha);
		ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(vSubtitlesMenuPos, 0.0), OptionMenu_GetScaledSize(vSubtitlesMenuSize));
		
		////////////////
		// Audio
		OptionMenu_SectionTitle("SubtitleOptions", vSubtitlesMenuPos, vSubtitlesMenuSize);

		int lY=0;
		
		mlCurrentItemId = mlFirstItemId;
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		DoScrollInput(vMenuItems);
		
		/////////////////
		// SUBTITLES
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Sound", "ShowSubtitles", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsButtonPos, mlCurrentItemId, msSelectedSubtitlesButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Sound", "ShowSubtitles", bNewValue);
			}
			
			msSelectedSubtitlesButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedSubtitlesButton);
		}
		mlCurrentItemId++;
		/////////////////
		// HEARING AID
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Sound", "ForceShowSubtitleCharacterName", false);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsButtonPos, mlCurrentItemId, msSelectedSubtitlesButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Sound", "ForceShowSubtitleCharacterName", bNewValue);
			}
			
			msSelectedSubtitlesButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedSubtitlesButton);
		}
		mlCurrentItemId++;
		/////////////////
		// GRADUAL SUBTITLES
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Sound", "AnimateSubtitles", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsButtonPos, mlCurrentItemId, msSelectedSubtitlesButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Sound", "AnimateSubtitles", bNewValue);
			}
			
			msSelectedSubtitlesButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedSubtitlesButton);
		}
		mlCurrentItemId++;
		/////////////////
		// FADE AT DISTANCE
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			bool bValue = mpConfig.GetBool("Sound", "FadeSubtitlesOverDistance", true);
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsButtonPos, mlCurrentItemId, msSelectedSubtitlesButton, bValue, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bValue != bNewValue)
			{
				mpConfig.SetBool("Sound", "FadeSubtitlesOverDistance", bNewValue);
			}
			
			msSelectedSubtitlesButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedSubtitlesButton);
		}
		mlCurrentItemId++;
		/////////////////
		// SUBTITLE SIZE
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//////////////
			// Draw button and update config
			tString sValue = mpConfig.GetString("Sound", "SubtitleSizePreset", "Default");
			int lValue = 0;
			for (int i = 0; i < vSubtitleSizeValues.length(); i++)
			{
				if (vSubtitleSizeValues[i] != sValue)
					continue;
				lValue = i;
				break;
			}
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsButtonPos, mlCurrentItemId, msSelectedSubtitlesButton, vSubtitleSizeValues, lValue, false, mlActionHorizontal, "Menu" ,0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			 
			if(lValue != lNewValue)
			{
				tString sNewValue = vSubtitleSizeValues[lNewValue];
				mpConfig.SetString("Sound", "SubtitleSizePreset", sNewValue);
				
				const float fNewSize = cLux_GetGameConfig().GetFloat("Voice", "FontSize_"+sNewValue, 23);
				mpConfig.SetFloat("Sound", "SubtitleSize", fNewSize);
			}
			
			msSelectedSubtitlesButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedSubtitlesButton);
		}
		mlCurrentItemId++;
		///////////////////////
		// SUBTITLE BG OPACITY
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			float fValue = mfSubtitleBGOpacity;
			float fConfigValue = mpConfig.GetFloat("Sound", "SubtitleBGAlpha", 1.0f);
			tString sTextValue = fConfigValue==0 || fConfigValue==1 ? cString_ToString(fConfigValue, 0,true) : cString_ToString(fConfigValue, 1);// fConfigValue==0 ? "Off" : cString_ToString(fConfigValue, 1);
			tString sTextValueTransCat = ""; //fConfigValue==0 ? "Menu" : "";
			float fNewValue = OptionMenu_ButtonOptionsSlider(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsButtonPos, mlCurrentItemId, msSelectedSubtitlesButton, fValue, 0.1f, mlActionHorizontal, sTextValue, sTextValueTransCat, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			float fNewConfigValue = fNewValue;
			if (fNewConfigValue < 0.1)
				fNewConfigValue = 0;
			if (fNewConfigValue > 0.95)
				fNewConfigValue = 1.0f;
			mfSubtitleBGOpacity = fNewValue;
			
			if(fNewConfigValue != fConfigValue)
			{
				mpConfig.SetFloat("Sound", "SubtitleBGAlpha", fNewConfigValue);
				ApplySettings(false);
			}

			msSelectedSubtitlesButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedSubtitlesButton);
		}
		mlCurrentItemId++;
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		/////////////////
		// Back
		{
			bool bButton = OptionMenu_ButtonOptions("Back", kOptionsButtonPos+kBackMargin, mlCurrentItemId, msSelectedSubtitlesButton, true, cVector2f_Zero, cVector3f_Zero, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(bButton || bGamepad)
			{
				ApplySettings();
				
				if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);
				
				mTargetGroup = mPrevGroup;
				msFocusNextFrame = msSelectedAudioButton;

				/////////
				// Reset menu position
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(msSelectedSubtitlesButton != "Back");
					msSelectedSubtitlesButton = "Subtitles";
					return;
				}
			}

			msSelectedSubtitlesButton = OptionMenu_UpdateFocus("Back", msSelectedSubtitlesButton);
		}
		
		GuiHandleTransition(0.05f, 0.05f, mTargetGroup, msTargetFocus);

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(msSelectedSubtitlesButton != "Back");
	}

	//------------------------------------------------------

	void ShowMessageBoxes()
	{
		if(mbShowApplyChanges )
		{
			MessageBoxApplyChanges();
		}
		else if(mbShowDuplicateKeys )
		{
			MessageBoxDuplicateKeys();
		}
		else if(mbShowApplyKeyChanges )
		{
			MessageBoxApplyKeyChanges();
		}
		else if(mbShowReset)
		{
			MessageBoxResetKeys();
		}
		else if(mfKeepDisplaySetting > 0)
		{
			MessageBoxKeepResolution();
		}
		else if(mlActionToBind > 0)
		{
			MessageBoxKeybind();
		}
		else if(mbShowRestartWarning)
		{
			MessageBoxRestartWarning();
		}
		else if(mbShowExit)
		{
			if(mbMainMenuActive)
			{
				MessageBoxExitFromMainMenu();
			}
			else
			{
				MessageBoxExitFromPauseMenu();
			}
		}
		else if(mbShowPlayGo)
		{
			MessageBoxPlayGo();
		}
		else if(mbShowNewGame)
		{
			MessageBoxNewGame();
		}
		else if(mbShowLoadGame)
		{
			MessageBoxLoadGame();
		}
		else if(msLoadSaveError.length() > 0)
		{
			MessageBoxLoadError();
		}
		else if(mbShowDetectSettings)
		{
			MessageBoxDetectSettings();
		}
		else if(mbShowSelectedModDialog)
		{
			MessageBoxModDialog();
		}
	}

	void MessageBoxApplyChanges()
	{
		////////////////
		// Apply changes message box
		int lSelect = OptionMenu_MessageBox("ApplyChanges", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == -1)
		{
			ApplySettings();
			
			//Sound_PlayGui("special_fx/frontend/frontend_menu_select", 1.0f, eSoundEntryType_Gui);

			cLux_AddDebugMessage("APPLY YES");
			if (mCurrentGroup == eMainMenuGroup_Options_Display_Gamma)
			{
				if (Platform_IsConsole())
				{
					mTargetGroup = eMainMenuGroup_Options;
					msTargetFocus = msSelectedOptionsButton;
				}
				else
				{
					mTargetGroup = eMainMenuGroup_Options_Display;
					msTargetFocus = msSelectedDisplayButton;
				}
			}
			else
			{
				mTargetGroup = eMainMenuGroup_Options;
				msTargetFocus = msSelectedOptionsButton;
			}

			mlOptionChanges = 0;

			mbShowRestartWarning = mbRestartWarning;
			mbShowApplyChanges = false;
			
			if(GetCurrentResolution() != mlCurrentResolution && Platform_IsConsole() == false)
			{
				cLux_AddDebugMessage("RES: "+GetCurrentResolution()+" CURR: "+mlCurrentResolution);
				////////////
				// If resolution has changed 
				mfKeepDisplaySetting = 15;
			}

			if(mfKeepDisplaySetting > 0) msFocusNextFrame = "No";
			else if(mbShowRestartWarning == false) msFocusNextFrame = msSelectedVideoButton;
			else if(mbShowRestartWarning) msFocusNextFrame = "Ok";
		}
		else if(lSelect == 1)
		{
			DiscardSettings();
			cLux_AddDebugMessage("DISCARD - Curr Group: "+mCurrentGroup);
			
			//Sound_PlayGui("special_fx/frontend/frontend_menu_select", 1.0f, eSoundEntryType_Gui);
			
			if (mCurrentGroup == eMainMenuGroup_Options_Display_Gamma)
			{
				if (Platform_IsConsole())
				{
					mTargetGroup = eMainMenuGroup_Options;
					msTargetFocus = msSelectedOptionsButton;
				}
				else
				{
					cLux_AddDebugMessage("AM GAMMA. BACK TO DISPLAY");
					mTargetGroup = eMainMenuGroup_Options_Display;
					msTargetFocus = msSelectedDisplayButton;
				}
			}
			else
			{
				cLux_AddDebugMessage("BACK TO OPTIONS");
				mTargetGroup = eMainMenuGroup_Options;
				msTargetFocus = msSelectedOptionsButton;
			}
			
			mlOptionChanges = 0;
			mbShowApplyChanges = false;
		}
		
		if (ImGui_TimerExists("TransitionOut") == false)// && mCurrentGroup == eMainMenuGroup_Options_Display_Gamma)
			ImGui_AddTimer("TransitionOut",10);

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//------------------------------------------------------- 
	
	void MessageBoxApplyKeyChanges()
	{
		////////////////
		// Apply changes message box (Keybinding, Controller Preset)
		int lSelect = OptionMenu_MessageBox("ApplyChanges", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets // ALEX: Why is this not working?
		mlActionHorizontal = 0;

		if(lSelect == -1)
		{
			ApplyKeybinds();	
		}
		else if(lSelect == 1)
		{
			DiscardKeybinds();
		}
		//mCurrentGroup = eMainMenuGroup_Options_Controls;
		//msFocusNextFrame = msSelectedInputButton;
		//mbShowApplyKeyChanges = false;

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	//------------------------------------------------------- 
	
	void MessageBoxDuplicateKeys()
	{
		////////////////
		// Apply changes message box
		int lSelect = OptionMenu_MessageBox("DuplicateKeys", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == -1)
		{
			msFocusNextFrame = "Yes";
			mbShowDuplicateKeys = false;
		}
		else if(lSelect == 1)
		{
			msFocusNextFrame = "Back";
			mbShowDuplicateKeys = false;
			mbShowApplyKeyChanges = false;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	void MessageBoxResetKeys()
	{
		////////////////
		// Apply changes message box
		int lSelect = OptionMenu_MessageBox("ResetToDefaultMessage", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == -1)
		{
			// Erase all settings
			if(mbBindingGamepad)
			{
				for(int i = 0; i < mvGamepadActions.size(); ++i)
				{
					mpKeyConfig.EraseValue(mvGamepadActions[i].msAction, "GamepadPrimary");
					mpKeyConfig.EraseValue(mvGamepadActions[i].msAction, "GamepadSecondary");
				}
			}
			else
			{
				for(int i = 0; i < mvActions.size(); ++i)
				{
					mpKeyConfig.EraseValue(mvActions[i].msAction, "Primary");
					mpKeyConfig.EraseValue(mvActions[i].msAction, "Secondary");
				}
			}

			// Get default settings by reloading key config
			cLux_GetInputHandler().LoadKeyConfig();

			mbKeybindChanged = true;
			msFocusNextFrame = "ResetToDefault";
			mbShowReset = false;
				
			/////////////
			// Reloading keys will make actions trigger again, so ignore next frame
			mlIgnoreInput = 3;
		}
		else if(lSelect == 1)
		{
			msFocusNextFrame = "ResetToDefault";
			mbShowReset = false;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}
	
	void MessageBoxRestartWarning()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox("RestartRequired", "Ok", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;
			
		if(lSelect == 1)
		{
			mbShowRestartWarning = false;
			msFocusNextFrame = msSelectedVideoButton;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
	}

	void MessageBoxKeepResolution()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox("KeepSettings", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus, cString_To16Char(""+cMath_RoundToInt(mfKeepDisplaySetting+0.5)));
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		mfKeepDisplaySetting -= 1.0 / 60.0;	

		if(lSelect == -1)
		{
			// Keep settings
			if(mbShowRestartWarning) msFocusNextFrame = "Ok";
			else msFocusNextFrame = msSelectedVideoButton;

			mfKeepDisplaySetting = 0;
		}
		else if(lSelect == 1 || mfKeepDisplaySetting <= 0)
		{
			//////////
			// Revert to old settings
			mpConfig.SetString("Screen", "FullScreen", msCurrentDisplayMode);
			SetCurrentResolution(mlCurrentResolution);
			ApplySettings();

			if(mbShowRestartWarning) msFocusNextFrame = "Ok";
			else msFocusNextFrame = msSelectedVideoButton;

			mfKeepDisplaySetting = 0;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
	}
	
	void MessageBoxPlayGo()
	{
		////////////////
		// Get time left
		int64 lETA = 0;
		cLux_IsPlayGoReady(lETA);

		int64 lSeconds = lETA % 60;
		int64 lMinutes = (lETA / 60) % 60;
		int64 lHour = (lETA / 3600);

		tString sTime;

		if(lHour > 9) sTime += lHour + ":";
		else if(lHour > 0) sTime += "0"+lHour + ":";
			
		if(lMinutes > 9) sTime += lMinutes + ":";
		else if(lMinutes > 0) sTime += "0"+lMinutes + ":";

		if(lSeconds > 9) sTime += lSeconds;
		else if(lSeconds > 0) sTime += "0"+lSeconds;

		if(lETA == 0)
		{
			mfPlayGoTimer -= 1.0f / 30.0f;
			sTime = "";
		}
		else
		{
			mfPlayGoTimer = 3.0f;
		}

		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox("PlayGoInstructions", "Ok", "", msMessageBoxFocus, msMessageBoxFocus, cString_To16Char(sTime));
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == 1 || mfPlayGoTimer < 0)
		{
			mbShowPlayGo = false;
			msFocusNextFrame = msSelectedMainMenuButton;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
	}

	void MessageBoxKeybind()
	{
		////////////////////////////////////
		// Darken other widgest
		cImGuiGfx gfx;
		ImGui_DrawGfx(gfx, ImGui_FullScreenPos(4.5), ImGui_FullScreenSize(), cColor(0.0, 0.75));

		////////////////////////////////////
		// Options background
		ImGui_DrawFrame(mGfxFrame, OptionMenu_GetTopLeftOffset(kOptionsBgPos, 0.0), OptionMenu_GetScaledSize(kOptionMenu_KeybindBgSize));
			
		///////////////
		// Draw title
		cImGuiLabelData labelData;
		labelData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu_InfoBox, 56));
		labelData.mFont.mvSize = cVector2f(36, 36);
		labelData.mFont.mColor = cColor(1,1);
		labelData.mFontAlign = eFontAlign_Center;
		
		//////////////
		// Get data based on bind type
		bool bAnalog = mbBindingGamepad ? mvGamepadActions[mlActionToBind-1].mbAnalog : mvActions[mlActionToBind-1].mbAnalog;
		tString sAction = mbBindingGamepad ? mvGamepadActions[mlActionToBind-1].msAction : mvActions[mlActionToBind-1].msAction;

		if(bAnalog)
		{
			tString sLabel = msKeybindFirstState.length() == 0 ? "PressRightGamepad" : "PressUpGamepad";

			ImGui_DoLabelExt(sLabel,labelData, OptionMenu_GetTopLeftOffset(kOptionMenu_KeybindBgPos + cVector2f(kOptionMenu_KeybindBgSize.x * 0.45,15), 5.5), 0);
		}
		else
		{
			ImGui_DoLabelExt("PressAnyKey",labelData, OptionMenu_GetTopLeftOffset(kOptionMenu_KeybindBgPos + cVector2f(kOptionMenu_KeybindBgSize.x * 0.45,15), 5.5), 0);
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);

		///////////////
		// Check if keybind button was pressed
		tString sKeyPressed = cLux_GetInputHandler().GetLatestKeyPressed();

		if(sKeyPressed.length() > 0)
		{
			/////////////
			// Disable cancel
			ImGui_ActionTriggered(eImGuiAction_Cancel, true);

			if(sKeyPressed != "Keyboard.Escape")
			{
				//////////////
				// Check for valid keys
				if(mbBindingGamepad)
				{
					// Only allow gamepad 0
					if(cString_GetFirstStringPos(sKeyPressed, "Gamepad.0") == -1)
					{
						return;
					}
				}
				else
				{
					// Only allow mouse or keyboard
					if(cString_GetFirstStringPos(sKeyPressed, "Gamepad") >= 0)
					{
						return;
					}
				}

				if(bAnalog)
				{
					/////////////////
					// Analog requires two binds in a row and must be from gamepad
					if(cString_GetFirstStringPos(sKeyPressed, "Gamepad") != -1 && 
					   cString_GetFirstStringPos(sKeyPressed, "Axis") != -1)
					{
						if(msKeybindFirstState.length() == 0) 
						{
							msKeybindFirstState = sKeyPressed;
							return;
						}
						else if(sKeyPressed != msKeybindFirstState)
						{
							sKeyPressed = msKeybindFirstState +"."+ ParseKeybind(sKeyPressed, false);
						}
						else
						{
							return; //Skip binding if its the same axis again
						}
					}
					else
					{
						return; //Skip binding if not a gamepad axis
					}
				}
				
								
				mpKeyConfig.SetString(sAction, msKeybindSlot, sKeyPressed);
				mbKeybindChanged = true;
				mlIgnoreInput = 3;
			}

			mlActionToBind = 0;
			msFocusNextFrame = msFocusAfterBind;
		}
	}

	void MessageBoxExitFromPauseMenu()
	{
		//////////////
		// Restart warning message box
		bool bExitToMenu = mpConfig.GetBool("Main", "ShowMenu", true);
		tString sMessageBoxText = "ExitNoSaveToMenuMessageBox";
		if(bExitToMenu)
		{
			if(mbSaveAndExit)
				sMessageBoxText = "ExitToMenuMessageBox";
		}
		else
		{
			if(mbSaveAndExit)
				sMessageBoxText = "ExitMessageBox";
		}
		int lSelect = OptionMenu_MessageBox(sMessageBoxText, "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == 1)
		{
			///////////
			// Cancel
			if(mbSaveAndExit)
				msFocusNextFrame = "SaveAndExit";
			else
				msFocusNextFrame = "Exit";
			
			mbShowExit = false;
			mbSaveAndExit = false;
			
		}
		else if(lSelect == -1)
		{
			///////////
			// Check for exit to menu or exit game
			if(bExitToMenu)
			{
				//mbMenuActive = false; 
				cLux_GetGuiHandler().SetGameHudInputFocus(false);

				if(mbSaveAndExit && Map_IsChanging() == false && mbSavingGame==false)
				{
					ResetBlur();
					Game_AutoSave(false, false);
					mbSavingGame = true; //make sure it cant trigger twice
				}
				
				if (cLux_GetCurrentMap() !is null)
				{
					if(cLux_GetCurrentMap().GetName() == "01_02_caves" && cScript_GetGlobalVarBool("Past_Camp") && cScript_GetGlobalVarBool("Caves_Deeper") == false)
						Achievement_Unlock(eAchievement_NopeMerci);
				}
				
				ImGui_AddTimer("ExitToMainMenu", mfFadeLength);
				Map_FadeOut(mfFadeLength);
				Music_StopAll(mfFadeLength);
				Sound_Stop("MenuBGNoise", mfFadeLength);
				
			}
			else
			{
				if(mbSaveAndExit && Map_IsChanging() == false && mbSavingGame==false)
				{
					ResetBlur();
					Game_AutoSave(false, false);
					mbSavingGame = true; //make sure it cant trigger twice
				}

				//mbMenuActive = false; 
				//if(mpConfig.GetBool("Main", "ShowMenu", true) == false) cLux_Exit();
				
				ImGui_AddTimer("ExitGame", mfExitGameFadeLength);
				Map_FadeOut(mfExitGameFadeLength);
				Music_StopAll(mfExitGameFadeLength);
				Sound_Stop("MenuBGNoise", mfFadeLength);
			}
						
			return;
		}
	}
	
	void MessageBoxExitFromMainMenu()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox("ExitMessageBox", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == 1)
		{
			///////////
			// Cancel
			mbShowExit = false;
			mbSaveAndExit = false;
			msFocusNextFrame = "Exit";
		}
		else if(lSelect == -1)
		{
			///////////
			// Exit the game
			//SetMenuActive(false);
			//cLux_Exit();
			
			cLux_GetGuiHandler().SetGameHudInputFocus(false);
			
			ImGui_AddTimer("ExitGame", mfExitGameFadeLength);
			Map_FadeOut(mfExitGameFadeLength);
			Music_StopAll(mfExitGameFadeLength);
			Sound_Stop("MenuBGNoise", mfExitGameFadeLength);
			
			return;
		}
	}

	void MessageBoxNewGame()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox("OverwriteGame", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		mlActionHorizontal = 0;

		if(lSelect == 1)
		{
			///////////
			// Cancel
			mbShowNewGame = false;
			msFocusNextFrame = "NewGame";
		}
		else if(lSelect == -1)
		{
			///////////
			// Load the game
			//Sound_PlayGui("special_fx/frontend/new_game_sting", 1.0f, eSoundEntryType_Gui);
			ClickNewGame();
			
			cLux_GetGuiHandler().SetGameHudInputFocus(false);
			return;
		}
	}

	void MessageBoxLoadGame()
	{
		//////////////
		// Restart warning message box
		int lSelect = OptionMenu_MessageBox("LoadMessageBox", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == 1)
		{
			///////////
			// Cancel
			mbShowLoadGame = false;
				
			if(mCurrentGroup == eMainMenuGroup_LoadGame)
			{
				if(mlSelectedLoadButton >= 0 && mlSelectedLoadButton < 10) msFocusNextFrame = "Save"+mlSelectedLoadButton;
				else													   msFocusNextFrame = "Back";
			}
			else
			{
				msFocusNextFrame = "Continue";
			}
		}
		else if(lSelect == -1)
		{
			///////////
			// Load the game
			ImGui_AddTimer("LoadGame", gfContinueGameFadeOutTime);
			cSound_FadeOutAll(eSoundEntryType_WorldAll, 1.0f / gfContinueGameFadeOutTime, false);
			Music_StopAll(mfFadeLength);
			Sound_Stop("MenuBGNoise", mfFadeLength);
			Sound_PlayGui("special_fx/frontend/new_game_sting", 1.0f, eSoundEntryType_Gui);
			mbShowLoadGame = false;
			cLux_GetGuiHandler().SetGameHudInputFocus(false);
			return;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
	}

	void MessageBoxLoadError()
	{
		//////////////
		// Restart warning message box
		ImGui_SetTransCategory("LoadGame");
		int lSelect = OptionMenu_MessageBox(msLoadSaveError, "Ok", "", msMessageBoxFocus, msMessageBoxFocus, ImGui_Translate(mbProfileError ? "DeleteProfile" : "DeleteSave"));
		ImGui_SetModUseInput(false); //disable input for any other widgets
		ImGui_SetTransCategory("Menu");
		mlActionHorizontal = 0;

		if(lSelect == 1)
		{
			msLoadSaveError = "";

			if(mbProfileError)
			{
				if(mpConfig !is null) mpConfig.Save();
				if(mpKeyConfig !is null) mpKeyConfig.Save();
			}
			else if(mbProfileError == false && cString_To8Char(msPreviousSaveLoaded) != "")
			{
				//////////////////
				//Delete the save file
				cLux_GetSaveHandler().DeleteSaveFile(msPreviousSaveLoaded);

				for(int i = 0; i < mvSaveFiles.size(); ++i)
				{
					if(cString_To8Char(mvSaveFiles[i]) == 
					   cString_To8Char(msPreviousSaveLoaded))
					{
						for(int j = i + 1; j < mvSaveFiles.size(); ++j)
						{
							mvSaveFiles[j-1] = mvSaveFiles[j];
							mvSaveDates[j-1] = mvSaveDates[j];
							mvSaveNames[j-1] = mvSaveNames[j];	
						}
						
						mvSaveFiles.resize(mvSaveFiles.size()-1);
						mvSaveDates.resize(mvSaveDates.size()-1);
						mvSaveNames.resize(mvSaveNames.size()-1);

						break;
					}
				}

				if(cString_To8Char(msContinueFile) == cString_To8Char(msPreviousSaveLoaded))
				{
					 msContinueFile = "";
					 mbCanContinue = false;
				}

				msPreviousSaveLoaded = "";

				if(mbCanContinue == false)
				{
					mbCanContinue = mvSaveFiles.size() > 0;

					if(mbCanContinue)
					{
						msContinueFile = mvSaveFiles[0]; 

						///////////
						// Remove "CheckPoint" from save file list
						for(int i = 0; i < mvSaveFiles.size(); ++i)
						{
							if(mvSaveNames[i] == tWString("CheckPoint"))
							{
								for(int j = i + 1; j < mvSaveFiles.size(); ++j)
								{
									mvSaveFiles[j-1] = mvSaveFiles[j];
									mvSaveDates[j-1] = mvSaveDates[j];
									mvSaveNames[j-1] = mvSaveNames[j];	
								}
						
								mvSaveFiles.resize(mvSaveFiles.size()-1);
								mvSaveDates.resize(mvSaveDates.size()-1);
								mvSaveNames.resize(mvSaveNames.size()-1);

								break;
							}
						}
					}
				}
			}
		}

		///////////
		// Show gamepad legacy
		if(mbProfileError == false) OptionMenu_ShowGamepadButtons(false);
	}
	
	void MessageBoxDetectSettings()
	{
		////////////////
		// Apply changes message box
		int lSelect = OptionMenu_MessageBox("DetectSettingsPrompt", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == -1)
		{
			AutoDetectSettings(false);
			mbShowDetectSettings = false;
		}
		else if(lSelect == 1)
		{
			mbShowDetectSettings = false;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(true);
	}

	//---------------------------------------
	
	void MessageBoxModDialog()
	{
		//////////////
		// Restart warning message box
		ImGui_SetTransCategory("ModMenu");
		int lSelect = OptionMenu_MessageBox("Launch", "Yes", "No", msMessageBoxFocus, msMessageBoxFocus);
		ImGui_SetModUseInput(false); //disable input for any other widgets
		mlActionHorizontal = 0;

		if(lSelect == 1)
		{
			///////////
			// Cancel
			mbShowSelectedModDialog = false;
			
			if(mCurrentGroup == eMainMenuGroup_CustomStories)
			{
				if(mlSelectedModentry >= 0 && mlSelectedModentry < kMaxModsToShow)
					msFocusNextFrame = "Mod" + cString_ToString(mlSelectedModentry);
				else
					msFocusNextFrame = "Back";
			}
			else
			{
				msFocusNextFrame = "Exit";
			}
		}
		else if(lSelect == -1)
		{
			mbShowSelectedModDialog = false;
			cLux_GetModHandler().LaunchMod(mvModIDs[mlModEntryToLoad]);
			return;
		}

		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
	}
	
	//---------------------------------------

	int mlStartPos = 0;
	int mlTestButton = 1;
	int mlMap = 0;
	bool mbPauseProfiler = false;
	int mlProfilerFilter = 0;
	int mlSpeed = 0;
	bool mbReloadGame = false;
	
	int mlFirstItemId = 0; // ID of the first item in the list
	int mlCurrentItemId = 0;
	int mlDebugHoverItemId = 0; // ID of the button to hover
	
	/*void DoOptionsItemDebug(const tString &in asMenuItem, int alAbsoluteID)
	{
		
		if(OptionMenu_ButtonOptions(asMenuItem, kOptionsButtonPos, alAbsoluteID, msSelectedDebugButton))
		{
			if (asMenuItem == "RELOAD")
			{
				cLux_ReloadGame();
				return;
			}
		}
		
		msSelectedDebugButton = OptionMenu_UpdateFocus(asMenuItem, msSelectedDebugButton);
		//cLux_AddDebugMessage(msSelectedDebugButton);
	}*/
	
	//------------------------------------------------------- 
	
	int mlScrollMargin = 2;
	int mlLastInFocus = 0;
	int mlLastInFocusRel = 0;
	bool mbScrolled = false;
	bool mbScrollDown = false;
	bool mbScrollUp = false;
	
	
	
	tString OptionMenu_UpdateFocusCustom(array<tString> avMenuItems, tString asID, tString asSelector)
	{	
		
		if (ImGui_PrevBecameInFocus())
		{
			// Set The newly focused item as the LastInFocus
			mlLastInFocus = mlCurrentItemId-mlFirstItemId;
			//cLux_AddDebugMessage("UPDATE FOCUS - LAST IS NOW (ABSOLUTE) "+mlLastInFocus);
			
			// Get relative position (0 1 2 3 4)
			int lRelativeID;
			
			// SCROLL
			if (mbScrolled)
			{
				lRelativeID = avMenuItems.find(asID)-1;
				mlLastInFocusRel = lRelativeID;
				cLux_AddDebugMessage("ID: "+asID+" - NOW RELATIVE: "+lRelativeID+" NOW ABSOLUTE: "+mlLastInFocus);
				
				if (mlLastInFocus > 0 && lRelativeID < 3)
				{
					//cLux_AddDebugMessage("SCROLL UP");
					
					if (mbScrollUp)
					{
						mlFirstItemId++;
						//cLux_AddDebugMessage("SCROLLING UP - FIRST ID: "+mlFirstItemId);
						
						int lTarget = lRelativeID-1;
						
						//cLux_AddDebugMessage("REFOCUS TO ABSOLUTE: "+mlLastInFocus+" ("+avMenuItems[mlLastInFocus]+")");
						//cLux_AddDebugMessage("TARGET: "+(lTarget));
						mbScrolled = false;
						mbScrollDown = false;
						mbScrollUp = false;
						//mlLastInFocus++;
						return avMenuItems[mlLastInFocus];
					}
					
				}
				cLux_AddDebugMessage("FOCUS UPDATE HERE");
				if (mlLastInFocus < avMenuItems.length() && lRelativeID == 3)
				{
					cLux_AddDebugMessage("SCROLL DOWN");
				
					if (mbScrollDown)
					{
						mlFirstItemId--;
						cLux_AddDebugMessage("SCROLLING DOWN - FIRST ID: "+mlFirstItemId);
						
						int lTarget = lRelativeID+1;
						
						cLux_AddDebugMessage("REFOCUS TO ABSOLUTE: "+mlLastInFocus+" ("+avMenuItems[mlLastInFocus]+")");
						cLux_AddDebugMessage("TARGET: "+(lTarget));
						mbScrolled = false;
						mbScrollDown = false;
						mbScrollUp = false;
						//mlLastInFocus++;
						return avMenuItems[mlLastInFocus];
					}
				}
			
			}
			// NO SCROLL (Happening when mouse hover new button)
			else
			{
				lRelativeID = avMenuItems.find(asID);
				mlLastInFocusRel = lRelativeID;
				mlMenuOffset = mlLastInFocus;
				//cLux_AddDebugMessage("UPDATE FOCUS - LAST IS NOW (ABSOLUTE) "+mlLastInFocus+" LAST IS NOW (REL) "+mlLastInFocusRel+" MENU OFFSET: "+mlMenuOffset);
				tString asAbsoluteID = avMenuItems[mlLastInFocus];
				//cLux_AddDebugMessage("NO SCROLL - ID: "+asAbsoluteID+" - NOW RELATIVE: "+lRelativeID+" NOW ABSOLUTE: "+mlLastInFocus);
				
				//cLux_AddDebugMessage("NO SCROLL");
				//cLux_AddDebugMessage("JUST FOCUSED: "+mlLastInFocus+" ("+avMenuItems[mlLastInFocus]+")");
				if (mlCurrentItemId >= 0 && mlCurrentItemId < avMenuItems.length())
				{
					mlDebugHoverItemId = avMenuItems.find(avMenuItems[mlCurrentItemId])-mlFirstItemId;
					//cLux_AddDebugMessage("ITEMID: "+mlDebugItemId+" - PREV IN FOCUS - "+asSelector+" - HOVERID: "+mlDebugHoverItemId);
					//cLux_AddTodoMessage("Sound: Menu focus changed");
					Sound_PlayGui("special_fx/frontend/frontend_menu_focus", 1.0f, eSoundEntryType_Gui);
					return asAbsoluteID;
				}
			
			}
			
			
		}
		//cLux_AddDebugMessage("SELECTOR:"+asSelector);
		return asSelector;
	}
	
	//------------------------------------------------------- 
	
	void DoScrollInputNew(array<tString> avMenuItems, int &out alSelected, cVector2f avBgPos, cVector2f avBgSize, cVector2f avBtnPos)
	{
		//cLux_AddDebugMessage("SCROLLED: "+mbScrolled);
		
		// alSelected is mlCurrentItemId which is assigned to mlFirstItemId 
		
		//////////////
		// Catch input
		int lActionVertical = 0;
		bool bMouseDown = false;
		float fPadding = mbScrolling ? 10000 : 5;
		
		int lMaxShownItems = OptionMenu_GetLimit();
		{
			if(ImGui_ActionTriggered(eImGuiAction_Down, true)) lActionVertical++;
			if(ImGui_ActionTriggered(eImGuiAction_Up, true)) lActionVertical--;
			if(ImGui_ActionTriggered(eImGuiAction_ScrollDown, true) && (mlMenuOffset + alSelected) < avMenuItems.size()-1 && alSelected != lMaxShownItems) lActionVertical+=2;
			if(ImGui_ActionTriggered(eImGuiAction_ScrollUp, true) && (mlMenuOffset + alSelected + 1) > 0 && alSelected != lMaxShownItems) lActionVertical-=2;
			bMouseDown = ImGui_ActionIsDown(eImGuiAction_MouseLeft, false);
			
			//cLux_AddDebugMessage("MAX ITEMS: "+lMaxShownItems);
		}
		
		//mlLastInFocusRel = (mlLastInFocus > 0) ? mlLastInFocusRel : mlLastInFocus; //Keep 4th spot

		//////////////
		// Update focus
		if(lActionVertical != 0)
		{
			//////////
			// Select file
			if(lActionVertical<0)	// Scroll up
			{
				if(lActionVertical==-1)
				{
					if (alSelected==lMaxShownItems)	// Back button
					{
						alSelected = cMath_Min(avMenuItems.size() - 1, lMaxShownItems-1);
					}
					else
					{
						alSelected--;
						if(alSelected < 0)
						{
							if(mlFirstItemId < 0)  // Make sure it doesn't go past the first item
							{
								alSelected = 0;
								mlMenuOffset--;		
								mlLastInFocus--;
								
								if (mlLastInFocusRel == 0) mlFirstItemId++;
								
								
								ImGui_SetFocus(avMenuItems[mlLastInFocus]);
							}
							else
							{
								alSelected = lMaxShownItems;
							}
						}
					}
				}
				else
				{
					// Scrolling with Wheel
					if(mlFirstItemId < 0) 
					{
						mlMenuOffset--;
						mlFirstItemId++; 
						mlLastInFocus--;
						
						cLux_AddDebugMessage("FIRST: "+mlFirstItemId+" REL: "+mlLastInFocusRel + "MAX: "+lMaxShownItems);
						// move selection if selection at the bottom
						if (mlLastInFocusRel == lMaxShownItems-1) 
						{
							cLux_AddDebugMessage("I AM HERE. THIS DOESN'T WORK ON BACK BUTTON (> MAX)");
							ImGui_SetFocus(avMenuItems[mlLastInFocus]);
						}

					}
					else
					{
						mlLastInFocus--;
						ImGui_SetFocus(avMenuItems[mlLastInFocus]);
					}
				}
			}
			else	// Scroll down
			{
				if(lActionVertical==1)
				{
					if (alSelected==lMaxShownItems)	// Back button
					{
						cLux_AddDebugMessage("BACK");
						alSelected = 0;
					}
					else
					{
						alSelected++;
						if(mlFirstItemId > -(avMenuItems.size()-lMaxShownItems) || mlLastInFocus != avMenuItems.size()-1)  // Make sure it doesn't go past the last item
						{
							
							alSelected--; // You are at the end of the list, so stay on the last item
							mlMenuOffset++;
							mlLastInFocus++;
							cLux_AddDebugMessage("LAST: "+mlLastInFocus);
	
							if (mlLastInFocusRel == lMaxShownItems-1) mlFirstItemId--;
							ImGui_SetFocus(avMenuItems[mlLastInFocus]);							
						}
						else
						{
							///////////
							// No more files, scroll to back button
							cLux_AddDebugMessage("NO MORE");
							alSelected = lMaxShownItems;
						}
						cLux_AddDebugMessage("[KEY DOWN] SELECTED: "+alSelected+" OFFSET: "+mlMenuOffset);
						

					}
				}
				else
				{
					// Scrolling with Wheel
					cLux_AddDebugMessage("ACTION VERT: "+lActionVertical+" FIRST: "+mlFirstItemId+" OFFSET: "+mlMenuOffset);
					if(mlFirstItemId > -(avMenuItems.size()-lMaxShownItems)) 
					{
						
						mlMenuOffset++;
						mlFirstItemId--;
						//mlLastInFocusRel--;
						
						cLux_AddDebugMessage("LAST: "+mlLastInFocus+" RELATIVE: "+mlLastInFocusRel);
						
						if (mlFirstItemId < 0) 
						{
							cLux_AddDebugMessage("LAST ++");
							mlLastInFocus++;
							ImGui_SetFocus(avMenuItems[mlLastInFocus]);
						}
						
					}
					else
					{
						mlLastInFocus++;
						ImGui_SetFocus(avMenuItems[mlLastInFocus]);
					}
				}
			}
			
		}
		
		cVector2f kMenuScrollPos = cVector2f(avBgPos.x+avBgSize.x-40, avBtnPos.y);
		cVector2f kScrollSize = cVector2f(15, avBgSize.y);
		
		//////////////
		// Scroll bar
		if(avMenuItems.size() > lMaxShownItems)
		{
			////////////
			// Update input
			float fFiles = avMenuItems.size();
			int lOldOffset = mlMenuOffset;
			float fMouseScrollY = OptionMenu_GetMouseInside(kMenuScrollPos - cVector2f(fPadding, 0) + cVector2f(OptionMenu_GetExtraWidth(), 0), kMenuScrollPos + kScrollSize + cVector2f(fPadding, 0) + cVector2f(OptionMenu_GetExtraWidth(), 0)).y;

			if(fMouseScrollY != -1.0)
			{
				///////////
				// Mouse touching scroll, check if button pressed
				if(bMouseDown)
				{
					mlMenuOffset = cMath_RoundToInt((fFiles-lMaxShownItems) * fMouseScrollY); // TO DO: Check if numbinds is correct
					mbScrollingKeybindList = true;
				}
			}

			if(bMouseDown == false)
			{
				////////
				// Stopped scrolling
				mbScrollingKeybindList = false;
			}

			mlMenuOffset = cMath_Clamp(mlMenuOffset, 0, avMenuItems.size() - lMaxShownItems);

			if(mlSelectedKeybindButton >= 0 && mlSelectedKeybindButton < lMaxShownItems && (mlMenuOffset - lOldOffset) != 0)
			{
				int lDiff = (mlMenuOffset - lOldOffset);
				mlSelectedKeybindButton = cMath_Clamp(mlSelectedKeybindButton - lDiff, 0, lMaxShownItems-1);
			}

			float fScaleY = 1.0 - (fFiles - lMaxShownItems) / fFiles;
			float fPosY = 0;
			if (fFiles>lMaxShownItems)
				fPosY = (mlMenuOffset) / (fFiles-lMaxShownItems);
			//ImGui_DrawGfx(gfxScrollBar, OptionMenu_GetTopLeftOffset(kMenuScrollPos + kScrollSize * cVector2f(0, (1.0 - fScaleY) * fPosY) + cVector2f(OptionMenu_GetExtraWidth(), 0), 0.01), OptionMenu_GetScaledSize(kScrollSize * cVector2f(1, fScaleY)), ((fMouseScrollY == -1.0f && mbScrollingKeybindList == false) || (mlActionToBind > 0 || mbShowApplyKeyChanges || mbShowReset)) ? kMainMenuButtonBgColor : cColor(1,1));
			//ImGui_DrawGfx(gfxScrollBar, OptionMenu_GetTopLeftOffset(kMenuScrollPos + kScrollSize * cVector2f(0, (1.0 - fScaleY) * fPosY), 0.01), OptionMenu_GetScaledSize(kScrollSize * cVector2f(1, fScaleY)), ((fMouseScrollY == -1.0f && mbScrollingKeybindList == false) || (mlActionToBind > 0 || mbShowApplyKeyChanges || mbShowReset)) ? kMainMenuButtonBgColor*cColor(1,mfTransitionAlpha) : cColor(1,mfTransitionAlpha));
		
		}
		
		
	}

	void DoScrollInput(array<tString> avMenuItems)
	{
		// When this happens, mlDebugItemId is 0 
		return;

		/////////////////////
		// SCROLL DOWN
		if(ImGui_ActionTriggered(eImGuiAction_Down, true) || ImGui_ActionTriggered(eImGuiAction_ScrollDown)) 
		{ 
			
			mlLastInFocusRel = (mlLastInFocus > 2) ? mlLastInFocusRel : mlLastInFocus; //Keep 4th spot
			
			//cLux_AddDebugMessage("[INPUT] LAST ABSOLUTE: "+mlLastInFocus+" ("+avMenuItems[mlLastInFocus]+") LAST RELATIVE: "+(mlLastInFocusRel)+")) - FIRST: "+mlFirstItemId);
			
			if (mlLastInFocus < avMenuItems.length())
			{	
				if (mlLastInFocusRel == 5 &&  mlLastInFocus == avMenuItems.length()-1) return;
				
				// SCROLL DOWN (detected here so that mouse doesn't trigger it)
				int lNextID = mlLastInFocus+1;
				tString sNextID = avMenuItems[lNextID];
				//cLux_AddDebugMessage("NEXT ID (ABSOLUTE): "+(lNextID)+" ("+sNextID+")");
				
				if (lNextID > 3 && mlLastInFocusRel >= 3 && mlLastInFocus + mlScrollMargin < avMenuItems.length()-1)
				{ 
					//cLux_AddDebugMessage("WILL SCROLL DOWN"); 
					mbScrolled = true;
					mbScrollUp = false;
					mbScrollDown = true;
					
					if (mlLastInFocusRel == 4) 
						mlFirstItemId -= 1;
					if (mlLastInFocusRel == 5) 
						mlFirstItemId -= 2;
					
				}

				//cLux_AddDebugMessage("SETTING FOCUS TO: "+(lNextID)+" ("+avMenuItems[lNextID]+")");
				ImGui_SetFocus(avMenuItems[lNextID]);
			}
		}
		
		/////////////////////
		// SCROLL UP
		if(ImGui_ActionTriggered(eImGuiAction_Up, true) || ImGui_ActionTriggered(eImGuiAction_ScrollUp)) 
		{
			if (mlLastInFocusRel == 0 &&  mlLastInFocus == 0) return;
			
			
			
			//if (mlLastInFocusRel == 0) mlLastInFocusRel = 1;// (mlLastInFocus < 2) ? mlLastInFocusRel : mlLastInFocusRel;
			
			//if (mlLastInFocusRel < 3) mlLastInFocusRel = 2;
			//int lRelID = (mlLastInFocus-5 < 3) ? 2 : mlLastInFocus;
			//cLux_AddDebugMessage("VALUES BEFORE MOVING");
			cLux_AddDebugMessage("[INPUT] LAST ABSOLUTE: "+mlLastInFocus+" ("+avMenuItems[mlLastInFocus]+") LAST RELATIVE: "+(mlLastInFocusRel)+")) - FIRST: "+mlFirstItemId);
			
			if (mlLastInFocus > 0)
			{		
				int lNextID = mlLastInFocus-1;
				tString sNextID = avMenuItems[lNextID];
				cLux_AddDebugMessage("NEXT ID (ABSOLUTE): "+(lNextID)+" ("+sNextID+")");
				
				if (lNextID > 1 && mlLastInFocusRel <= 2)
				{
					cLux_AddDebugMessage("WILL SCROLL UP "+mlLastInFocusRel); 
					mbScrolled = true;
					mbScrollUp = true;
					mbScrollDown = false;
					
					if (mlLastInFocusRel == 0)
					{
						cLux_AddDebugMessage("AAA");
						//mlFirstItemId += 2;
					}
					else if (mlLastInFocusRel == 1) 
						mlFirstItemId += 1;
				}
				/*if (lNextID == 0 && mlLastInFocusRel == 1)
				{
					mlFirstItemId += 1;
				}*/

				cLux_AddDebugMessage("SETTING FOCUS TO: "+(lNextID)+" ("+avMenuItems[lNextID]+")");
				ImGui_SetFocus(avMenuItems[lNextID]);
			}
		}

	}
	
	//------------------------------------------------------- 

	void GuiOptionsDebug()
	{
		GuiPauseDarkOverlay();
		
		///////////////////
		// Get strings and update size
		array<tString> vStartPositions;
		cLux_GetStartPositions(vStartPositions);
		array<tString> vMaps;
		cLux_GetConsoleMaps(vMaps);
		
		array<tString> vMenuItems = {"RELOAD", "PROFILER", "PROFILE EVERY 5 SEC", "PROFILER TYPE", "GAME SPEED", "MAPS", "LOAD MAP", "START POS", "TELEPORT", "TEST BUTTON", "PRESS TEST KEY" , "BACK"};
		
		for (int i=0; i<=vMenuItems.length()-1; i++)
		{
			OptionMenu_UpdateButtonWidth(vMenuItems[i]);
		}
		OptionMenu_UpdateToggleExtraWidth();
		OptionMenu_UpdateMultiSelectionExtraWidth(vMaps, "");
		OptionMenu_UpdateMultiSelectionExtraWidth(vStartPositions, "");
		OptionMenu_AlignExtraButtonWidth();
		
		cVector2f vDebugMenuPos = kOptionsDebugBgPos;
		cVector2f vDebugMenuSize = kOptionsDebugBgSize+cVector2f(gfOptionsMenu_ExtraWidth+gfOptionsMenu_ExtraWidth_MultiSelect,0);
		cVector2f vRightAnchor = cVector2f(vDebugMenuPos.x+vDebugMenuSize.x-40,0);
		
		cVector3f vInfoBoxPos = OptionMenu_GetTopLeftOffset(cVector2f(vDebugMenuPos.x+vDebugMenuSize.x-60,0),0);
		
		tString sBkg = OptionMenu_GetBackground(OptionMenu_GetScaledSize(vDebugMenuSize));
		cImGuiGfx gfx = cImGuiGfx(sBkg, eGuiMaterial_Alpha, eImGuiGfx_TextureTemporary);
		gfx.mColor = cColor(1,mfTransitionAlpha);
		ImGui_DrawGfx(gfx, OptionMenu_GetTopLeftOffset(vDebugMenuPos, 0.0), OptionMenu_GetScaledSize(vDebugMenuSize));
		
		////////////////
		// Title
		OptionMenu_SectionTitle("Options_Debug", vDebugMenuPos, vDebugMenuSize);

		ImGui_SetTransCategory("Menu");
		
		mlCurrentItemId = mlFirstItemId;
		
		/////////////////////////
		// Handles dynamic scrolling
		OptionMenu_SetOutOfLimit(vMenuItems.length());
		DoScrollInput(vMenuItems);
		
		/////////////////
		// Reload
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				cLux_ReloadGame();
				return;
			}
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
		}
		mlCurrentItemId++;

		/////////////////
		// Profiler
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//cLux_AddDebugMessage("PROFILER");
			array<tString> vProfiler = { "OFF", "CPU", "GPU" };
			//////////////
			// Draw button and update config
			int lValue = cLux_GetProfilerActive();
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, vProfiler, lValue, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(lValue != lNewValue)
			{
				cLux_SetProfilerActive(lNewValue);

				if(lNewValue == 0)
				{
					cLux_SetProfilerPauseInterval(0.0f);
					mbPauseProfiler = false;
				}
			}
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
		}
		mlCurrentItemId++;
		
		/////////////////////////////////
		// Profiler Pause Every 5 Seconds
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//cLux_AddDebugMessage("PROFILER PAUSE");
			//////////////
			// Draw button and update config
			bool bNewValue = OptionMenu_ButtonOptionsToggle(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, mbPauseProfiler, mlActionHorizontal, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			
			if(bNewValue != mbPauseProfiler)
			{
				mbPauseProfiler = bNewValue;
				cLux_SetProfilerPauseInterval(mbPauseProfiler ? 5.0f : 0.0f);
			}
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
		}
		mlCurrentItemId++;
		
		/////////////////
		// Profiler Filter
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//cLux_AddDebugMessage("PROFILER FILTER");
			array<tString> vFilter = { "Engine", "Game", "Render", "Variable", "Physics" };
			int lFilter = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, vFilter, mlProfilerFilter, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);

			if(lFilter != mlProfilerFilter)
			{
				mlProfilerFilter = lFilter;

				switch(lFilter)
				{
				case 0: cLux_SetProfilerFilter("EngineLoop"); break;
				case 1: cLux_SetProfilerFilter("EngineLoop GameLoop"); break;
				case 2: cLux_SetProfilerFilter("EngineLoop RenderAll"); break;
				case 3: cLux_SetProfilerFilter("EngineLoop Variable"); break;
				case 4: cLux_SetProfilerFilter("EngineLoop GameLoop Message_PostUpdate HPL_Scene_PostUpdate Physics");
				}
			}
		}
		mlCurrentItemId++;
		
		/////////////////
		// Game speed
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//cLux_AddDebugMessage("GAME SPEED");
			array<tString> vSpeed = { "100%", "400%", "25%" };
			int lSpeed = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, vSpeed, mlSpeed, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
			//cLux_AddDebugMessage(msSelectedDebugButton);

			if(lSpeed != mlSpeed)
			{
				mlSpeed = lSpeed;

				switch(lSpeed)
				{
				case 0: cLux_SetDebugGameSpeed(100); break;
				case 1: cLux_SetDebugGameSpeed(400); break;
				case 2: cLux_SetDebugGameSpeed(25); break;
				}
			}
		}
		mlCurrentItemId++;
		
		/////////////////
		// Maps
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{	
			//cLux_AddDebugMessage("MAPS");
			mlMap = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, vMaps, mlMap, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
			//cLux_AddDebugMessage(msSelectedDebugButton);
		}
		mlCurrentItemId++;

		////////////////
		// Maps button
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{			
			//cLux_AddDebugMessage("MAPS BUTTON");
			if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				Map_ChangeMap(vMaps[mlMap], "", "", "");
				SetMenuActive(false);
				cLux_ClearPlayedVoiceLines();
			}
		
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
			//cLux_AddDebugMessage(msSelectedDebugButton);
		}
		mlCurrentItemId++;

		/////////////////
		// Start position
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{	
			//cLux_AddDebugMessage("START POS");
			mlStartPos = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, vStartPositions, mlStartPos, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
			//cLux_AddDebugMessage(msSelectedDebugButton);
		}
		mlCurrentItemId++;

		////////////////
		// Start position button
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//cLux_AddDebugMessage("START POS BUTTON");
			if(OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				cLux_TeleportToStartPos(vStartPositions[mlStartPos]);
			}
		
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
			//cLux_AddDebugMessage(msSelectedDebugButton);
		}
		mlCurrentItemId++;

		///////////////////
		// Test button
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{	
			//cLux_AddDebugMessage("TEST BUTTON");
			array<tString> vTestButtons = { "Test0", "Test1", "Test2", "Test3", "Test4", "Test5", "Test6", "Test7", "Test8", "Test9" };
			mlTestButton = OptionMenu_ButtonOptionsMultiSelect(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, vTestButtons, mlTestButton, false, mlActionHorizontal, "", 0, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
		}
		mlCurrentItemId++;
		
		///////////////////
		// Press test button
		ImGui_SetTransCategory("");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			if (OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos, mlCurrentItemId, msSelectedDebugButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha))
			{
				cLux_RunTestButton(mlTestButton);
			}
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
			//cLux_AddDebugMessage(msSelectedDebugButton);
		}
		mlCurrentItemId++;	
		/////////////////
		// Back
		ImGui_SetTransCategory("Menu");
		if (OptionMenu_CheckOutOfLimits(mlCurrentItemId) == false)
		{
			//cLux_AddDebugMessage("ID: "+mlDebugItemId+" - FIRST: "+mlFirstItemId);
			bool bButton = OptionMenu_ButtonOptions(vMenuItems[mlCurrentItemId-mlFirstItemId], kOptionsDebugButtonPos+kBackMargin, mlCurrentItemId, msSelectedDebugButton, true, vRightAnchor, vInfoBoxPos, mfTransitionAlpha);
			bool bGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			if(bButton || bGamepad)
			{
				cLux_AddDebugMessage("ESC");
				
				mlScrollMargin = 2;
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mlLastInFocusRel = 0;;
				mbScrolled = false;
				mbScrollDown = false;
				mbScrollUp = false;
				
				
				mTargetGroup = eMainMenuGroup_Options;
				msTargetFocus = msSelectedOptionsButton;
				
				if (ImGui_TimerExists("TransitionOut") == false)
						ImGui_AddTimer("TransitionOut", 10);

				////////
				// Reset menu pos
				if(bGamepad == false)
				{
					OptionMenu_ShowGamepadButtons(false);
					msSelectedDebugButton = "Video";					
					return;
				}
			}
			msSelectedDebugButton = OptionMenu_UpdateFocusCustom(vMenuItems,vMenuItems[mlCurrentItemId], msSelectedDebugButton);	
		}
		else
		{
			cLux_AddDebugMessage("ESC");
			bool bBack = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
			if (bBack)
			{
				mlFirstItemId = 0;
				mlLastInFocus = 0;
				mlLastInFocusRel = 0;
				mbScrolled = false;
				mbScrollDown = false;
				mbScrollUp = false;
				
				mTargetGroup = eMainMenuGroup_Options;
				msFocusNextFrame = msSelectedOptionsButton;
			}
		}
		
		GuiHandleTransition(0.05f, 0.05f, mTargetGroup, msTargetFocus);
		
		///////////
		// Show gamepad legacy
		OptionMenu_ShowGamepadButtons(false);
		
		DoScrollMask(-6);		
	}

	//------------------------------------------------------

	void GuiOptionsGamma()
	{
		array<tString> vSpeakerValues = {"SmallTV", "MediumTV", "HomeCinema", "Headphones", "RemotePlay", "NightMode"};
		OptionMenu_UpdateExtraWidth("Gamma", false);
		

		bool bTestConsole = false;
		
		float fAlpha = mbPremenuActive ? mfPreMenuFadeAmount : 1;
		
		/////////////
		// Accept pressed
		bool bAccept = ImGui_ActionTriggered(eImGuiAction_Confirm, true);
		bool bCancelled = ImGui_ActionTriggered(eImGuiAction_Cancel, true);

		bool bShowAcceptOnly = mbPremenuActive;

		OptionMenu_SetModColor(cColor(1, fAlpha*mfTransitionAlpha));
		
		cVector2f vSize =  ImGui_FullScreenSize();

		// 1024 = -30
		// 1479 = 140
		// 2056 = 340
		// 3299 = 775
		
		float x = vSize.x;
		
		// We shall never speak of this.
		// Last minute fixes for ultrawide. Alex and I spent
		// nearly a day trying to figure out the interplay
		// of all the various aspect ratio stuff going on
		// here, and failed utterly.
		// So I pushed a bunch of known good values into
		// an equation solver, and here we go! - IT
		float xOffset = ((0.0000000123f*(x-2056.0f) - 0.00002617f)*(x-1479.0f)+0.373f)*(x-1024.0f)-30.0f;

		/////////////////////////////////////
		// Reference Image
		cImGuiGfx gfx("gamma_background.tga", eImGuiGfx_Texture);
		cVector2f vBgSize = OptionMenu_GetScaledSize(cVector2f(1280, 720) * 0.6);
		cVector3f vBgPos = OptionMenu_GetCenterOffset(cVector2f(0), 5.2) - cVector3f(vBgSize.x * 0.5, vBgSize.y * 0.8, 0.0);
		
		ImGui_DrawGfx(gfx, vBgPos, vBgSize, cColor(1, fAlpha*mfTransitionAlpha));

		ImGui_DrawGfx(cImGuiGfx(), ImGui_FullScreenPos(0.1), ImGui_FullScreenSize(), cColor(0, fAlpha*mfTransitionAlpha));

		// Hack for Russian!
		bool bIsRussian = false;
		{
			cConfigFile@ pConfig = cLux_GetUserConfig();
			tString sLang = cString_SetFileExt(pConfig.GetString("Main", "StartLanguage", cLux_GetDefaultGameLanguage()), "");
			bIsRussian = (sLang=="russian");
		}
		
		////////////////
		// Setup variables
		cVector2f vDlgSize = cVector2f(824,125);
		cVector2f vDlgPos = cVector2f(100+xOffset,500);
		cVector2f vControlPos = vDlgPos;
		vControlPos.y -= 100;
		vControlPos.x += 75;
		cVector2f vSlidePos = vControlPos;
		vSlidePos.x += 650;
		cVector2f vPromptPos = vControlPos;
		vPromptPos.x-=50;
		vPromptPos.y+=50;
		cVector2f vPromptSize = vDlgSize;
		vPromptSize.x+=100;
		cVector2f vPadPromptPos = vDlgPos;
		vPadPromptPos.x-=75;
		vPadPromptPos.y-=475;

		if (bIsRussian)
		{
			vDlgPos.x-=50;
			vDlgSize.x+=100;
			vControlPos.x-=50;
			vSlidePos.x += 125;
			vPromptPos.x-=50;
			vPromptSize.x+=100;
		}
		
		if ( (bTestConsole||Platform_IsConsole()) && mbPremenuActive)
		{
			OptionMenu_UpdateExtraWidth("SpeakerType", false);
			OptionMenu_UpdateMultiSelectionExtraWidth(vSpeakerValues);
			OptionMenu_UpdateExtraButtonWidth_MultiSelection(vSpeakerValues);
			OptionMenu_AlignExtraButtonWidth();
			
			vDlgSize.y+=25.0f;
			vPadPromptPos.y-=25.0f;
		}
		
		tString sBkg = OptionMenu_GetBackground(OptionMenu_GetScaledSize(vDlgSize));
		cImGuiGfx gfxDlg = cImGuiGfx(sBkg, eGuiMaterial_Alpha, eImGuiGfx_TextureTemporary);
		gfxDlg.mColor = cColor(1,mfTransitionAlpha);
		
		ImGui_DrawGfx(gfxDlg, OptionMenu_GetTopLeftOffset(vDlgPos, 0.0), OptionMenu_GetScaledSize(vDlgSize));	
		
		/////////////////////
		// Help text
		{
			cImGuiTextFrameData frameData;
			frameData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu_InfoBox, 96) );
			frameData.mFont.mvSize = cVector2f(24, 24);
			frameData.mFont.mColor = cColor(1,fAlpha*mfTransitionAlpha);
			frameData.mbUseBackgroundGfx = false;
			frameData.mFontAlign = eFontAlign_Left;

			ImGui_DoTextFrameExt("GammaInstructions0", cVector2f(0), 2.0, 0.0, frameData, OptionMenu_GetTopLeftOffset(vPromptPos, 10.0), vPromptSize);
		}
		
		int lY = 3;
		
		////////////////
		// Slider
		{
			float fValue = (mpConfig.GetFloat("Screen", "Gamma", 1.0f) - 0.3f) / (2.0f - 0.6f);
			float fNewValue = OptionMenu_ButtonOptionsSlider("Gamma", vControlPos, lY++, msSelectedGammaButton, fValue, 0.05f, mlActionHorizontal, "", "", 
								vSlidePos, cVector3f_Zero, fAlpha*mfTransitionAlpha);

			if(fNewValue != fValue)
			{
				mpConfig.SetFloat("Screen", "Gamma", (fNewValue * (2.0f - 0.6f) + 0.3f));
				cGraphics_GetLowLevel().SetGammaCorrection((fNewValue * (2.0f - 0.6f) + 0.3f));
				mlOptionChanges++;
			}

			msSelectedGammaButton = OptionMenu_UpdateFocus("Gamma", msSelectedGammaButton);
		}
		
		////////////////
		// Speaker type
		if( (Platform_IsConsole()||bTestConsole) && mbPremenuActive)
		{
			/////////////
			// Draw multi select box and update config
			tString sValue = mpConfig.GetString("Sound", "SpeakerType", "HomeCinema");
			int lValue =-1;
			for(int i=0;i<vSpeakerValues.size(); ++i)
			{
				if(sValue == vSpeakerValues[i]){
					lValue = i;
					break;
				}
			}
			
			int lNewValue = OptionMenu_ButtonOptionsMultiSelect("SpeakerType", vControlPos, lY++, msSelectedGammaButton, vSpeakerValues, lValue, false, mlActionHorizontal, "Menu", 0, 
							vSlidePos, cVector3f_Zero, fAlpha*mfTransitionAlpha);
			
			if(lValue != lNewValue)
			{
				mpConfig.SetString("Sound", "SpeakerType", vSpeakerValues[lNewValue]);
				ApplySettings(false);
			}

			msSelectedGammaButton = OptionMenu_UpdateFocus("SpeakerType", msSelectedGammaButton);
		}

		//////////////
		// Accept button
		{			
			bool bButton = OptionMenu_ButtonOptions(bShowAcceptOnly ? "AcceptGamma" : "Back", vControlPos, lY, msSelectedGammaButton, true, cVector2f_Zero, cVector3f_Zero, fAlpha*mfTransitionAlpha);
			
			if (bButton || (bCancelled && bShowAcceptOnly == false))
			{
				if(bShowAcceptOnly)
				{		
					// Apply directly
					msFocusNextFrame = msSelectedMainMenuButton;
					
					if(mbFirstGameStart)
					{
						//Hck to disable multiple btn clicks
						if (ImGui_TimerExists("FirstGameStartGammaSet")) return;
						ImGui_AddTimer("FirstGameStartGammaSet", 2);
						
						cLux_AddDebugMessage("ACCEPTED");
						
						//////////////
						// Auto detect settings
						AutoDetectSettings(true);
						
						mTargetGroup = eMainMenuGroup_Main;
						msTargetFocus = "NewGame";
						mfPreMenuFadeAmount = 1;
						mfPreMenuFadeDest=mfPreMenuFadeDestMin;
						
						
					}

					ApplySettings();
					
				}
				else
				{
					if(mlOptionChanges == mlCurrentOptionChange)
					{
						// No changes
						mTargetGroup = (Platform_IsConsole()) ? eMainMenuGroup_Options : eMainMenuGroup_Options_Display;
						msTargetFocus = msSelectedGraphicsButton;
						if (ImGui_TimerExists("TransitionOut") == false)
							ImGui_AddTimer("TransitionOut",10.f);
						cLux_AddDebugMessage("BACK: "+mTargetGroup);
						
					}
					else
					{
						/////////////
						// Show apply popup
						mbShowApplyChanges = true;
						msFocusNextFrame = "No";
					}
				}
				
				mbShowingGammaMenu = false;
			}

			msSelectedGammaButton = OptionMenu_UpdateFocus(bShowAcceptOnly ? "AcceptGamma" : "Back", msSelectedGammaButton);
		}

		///////////
		// Show gamepad legacy
		if (mbShowApplyChanges == false)
			OptionMenu_ShowGamepadButtons(true, false, vPadPromptPos);
		
		if (mbFirstGameStart == false && mbPremenuActive == false && mbShowApplyChanges == false)
			GuiHandleTransition(0.05f, 0.025f, mTargetGroup, msTargetFocus);
		
		OptionMenu_SetModColor(cColor(1, 1));
	}
	
	//-------------------------------------------------------
	
	array<uint32> mvModIDs;
	array<tString> mvModNames;
	array<tWString> mvModAuthors;
	array<tString> mvModPics;
	int mlModEntryOffset=0;
	int mlModEntryToLoad=0;
	int mlSelectedModentry=0;
	bool mbScrollingModsList = false;
	
	array<uint32> mvDownloadingModIDs;
	array<tString> mvDownloadingModNames;
	//array<tWString> mvDownloadingModDescriptions;
	
	bool mbShowSelectedModDialog = false;
	
	//-------------------------------------------------------
	
	void GuiCustomStories()
	{
		mbBackgroundShowTitle = false;
		
		//////////////////////////////////////////////////////////////////
		// Title
		OptionMenu_SectionTitle("Mods", kLoadBgPos, kLoadBgSize);
		
		//////////////////////////////////////////////////////////////////
		// PAGE BACKGROUND
		//tString sBkg = OptionMenu_GetBackground(OptionMenu_GetScaledSize(kModsBgSize));
		cImGuiGfx gfxBkg = cImGuiGfx("mainmenu_submenu_backdrop_controller_1460x900", eGuiMaterial_Alpha, eImGuiGfx_TextureTemporary);
		gfxBkg.mColor = cColor(1,mfTransitionAlpha);
		ImGui_DrawGfx(gfxBkg, OptionMenu_GetTopLeftOffset(kModsBgPos, 0.0f), OptionMenu_GetScaledSize(kModsBgSize));
		
		const float fPageFrameAlpha = mfTransitionAlpha * 0.83f;
		
		//////////////////////////////////////////////////////////////////
		// HANDLE MOD LISTING CHANGES
		bool bRebuildModList = false;
		
		while(cLux_GetModHandler().HasNextListEvent())
		{
			eLuxModEntryListEventType eventType;
			array<uint32> vEntryIDs;
			
			cLux_GetModHandler().NextListEvent(eventType, vEntryIDs);
			
			array<tString> vEventType;
			vEventType.resize(5);
			vEventType[eLuxModEntryListEventType_EntriesAdded] = "EntriesAdded";
			vEventType[eLuxModEntryListEventType_EntriesRemoved] = "EntriesRemoved";
			vEventType[eLuxModEntryListEventType_EntriesFetchedDetails] = "EntriesFetchedDetails";
			vEventType[eLuxModEntryListEventType_EntriesStartedDownloading] = "EntriesStartedDownloading";
			vEventType[eLuxModEntryListEventType_EntriesFinishedDownloading] = "EntriesFinishedDownloading";
			
			cLux_AddDebugMessage("List event - type: " + vEventType[eventType] + " - entries: " + vEntryIDs.size());
			
			if(eventType==eLuxModEntryListEventType_EntriesStartedDownloading)
			{
				mvDownloadingModIDs.push_back(vEntryIDs[0]);
				mvDownloadingModNames.push_back("");
				//mvDownloadingModDescriptions.push_back(cString_To16Char(""));
			}
			else if(eventType == eLuxModEntryListEventType_EntriesFinishedDownloading)
			{
				for (uint32 i = 0; i<mvDownloadingModIDs.size(); ++i)
				{
					if(mvDownloadingModIDs[i]!=vEntryIDs[0]) continue;
					
					mvDownloadingModIDs.erase(i);
					mvDownloadingModNames.erase(i);
					//mvDownloadingModDescriptions.erase(i);
					break;
				}
			}
			else if(eventType==eLuxModEntryListEventType_EntriesFetchedDetails)
			{
				for (uint32 i = 0; i<mvDownloadingModIDs.size(); ++i)
				{
					if (mvDownloadingModIDs[i]!=vEntryIDs[0]) continue;
					
					tString sName;
					eLuxModContentType type;
					if(cLux_GetModHandler().GetModDownloadDetails(mvDownloadingModIDs[i], type, sName))
						mvDownloadingModNames[i] = sName;
					
					break;
				}
			}
			else if(eventType==eLuxModEntryListEventType_EntriesRemoved)
			{
				for(uint32 i = 0; i<mvModIDs.size(); ++i)
				{
					for(uint32 j = 0; j<vEntryIDs.size(); ++j)
					{
						if(mvModIDs[i]!=vEntryIDs[j]) continue;
						
						mvModIDs.erase(i);
						mvModNames.erase(i);
						mvModAuthors.erase(i);
						mvModPics.erase(i);
						break;
					}
				}
			}
			else
			{
				bRebuildModList = true;
			}
		}
		
		if(bRebuildModList)
		{
			mvModIDs.resize(0);
			mvModNames.resize(0);
			mvModAuthors.resize(0);
			mvModPics.resize(0);
			cLux_GetModHandler().GetModEntriesByName(eLuxModContentType_StandAlone, mvModIDs, mvModNames, mvModAuthors, mvModPics);
			
			cLux_AddDebugMessage("Rebuilding mod list: ");
			
			for(uint i =0; i<mvModNames.size(); ++i)
			{
				cLux_AddDebugMessage("("+i+") " + mvModNames[i] + " ("+ mvModIDs[i] + ")");
			}
		}
		
		tString sItemNameBase = "Mod";
		bool bDismissPageOnReturn = false;

		//////////////////////////////////////////////////////////////////
		// HANDLE INPUT
		int lActionVertical = 0;
		const int lMaxItems = kMaxModsToShow;
		bool bMouseDown = false;
		
		if(mbShowSelectedModDialog == false)
		{
			// Only catch input if confirmation popup is not visible
			if(ImGui_ActionTriggered(eImGuiAction_Down, true)) 
			{
				Sound_PlayGui("special_fx/frontend/frontend_menu_focus", 1.0f, eSoundEntryType_Gui); 
				lActionVertical++;
			}
			if(ImGui_ActionTriggered(eImGuiAction_Up, true)) 
			{
				Sound_PlayGui("special_fx/frontend/frontend_menu_focus", 1.0f, eSoundEntryType_Gui); 
				lActionVertical--;
			}
			
			if(ImGui_ActionTriggered(eImGuiAction_ScrollDown, true) && 
				(mlModEntryOffset + mlSelectedModentry) < mvModIDs.size()-1 && 
				mlSelectedModentry < lMaxItems)
				lActionVertical+=2;
			
			if(ImGui_ActionTriggered(eImGuiAction_ScrollUp, true) && 
				(mlModEntryOffset + mlSelectedModentry) > 0 && 
				mlSelectedModentry < lMaxItems)
				lActionVertical-=2;
				
			bMouseDown = ImGui_ActionIsDown(eImGuiAction_MouseLeft, false);
		}
		
		ImGui_SetAlignment(eImGuiAlign_TopLeft);
		
		//////////////////////////////////////////////////////////////////
		// DRAW MODS LIST
		
		// Provider icons
		array<tString> vsProviderIcons;
		for(int i=0; i<cLux_GetModHandler().GetProviderNum(); ++i)
		{
			vsProviderIcons.push_back("mod_providericon_" + cLux_GetModHandler().GetProviderName(i) + ".png");
		}
		
		// Mod List Frame
		cImGuiGfx gfxModListFrame = cImGuiGfx("startmenu_frame_load.tga", eImGuiGfx_Texture);
		gfxModListFrame.mColor = cColor(1,fPageFrameAlpha);
		cVector2f vModListFramePos = kModsBgPos + cVector2f(15, 30);
		cVector2f vModListFrameSize = cVector2f(kModsBgSize.x * 0.47, kModsBgSize.y * 0.805);
		ImGui_DrawGfx(gfxModListFrame, OptionMenu_GetTopLeftOffset(vModListFramePos, 0.5f), OptionMenu_GetScaledSize(vModListFrameSize));
		
		//////////////////////////////////////////////////////////////////
		// Draw mod entires
		int lItemIndex = 0;
		
		// Downloading Mods
		int lDownloadModsOffset = mlModEntryOffset;
		for(int i = lDownloadModsOffset; (i < mvDownloadingModIDs.size()) && (lItemIndex < lMaxItems); ++i)
		{
			ImGui_SetTransCategory("");
			const bool bSelected = (lItemIndex == mlSelectedModentry);
			const cVector2f vElemPos = kModsBgPos + cVector2f(35, 50 + (kModsSlotsSpacing * lItemIndex));
			const float fDownloadProgress = cLux_GetModHandler().GetDownloadProgress(mvDownloadingModIDs[i]);
			
			OptionMenu_ButtonMod(sItemNameBase + cString_ToString(lItemIndex), mvDownloadingModNames[i], vElemPos, bSelected, "", mfTransitionAlpha, true, fDownloadProgress);
			
			if (bMouseDown==false && ImGui_PrevInFocus())
					mlSelectedModentry = lItemIndex; 

			lItemIndex++;
		}
		
		// Installed Mods
		int lInstalledModsOffset = cMath_Max(0, mlModEntryOffset -  mvDownloadingModIDs.size());
		for(int i = lInstalledModsOffset; (i < mvModIDs.size()) && (lItemIndex < lMaxItems); ++i)
		{
			ImGui_SetTransCategory("");
			const bool bSelected = (lItemIndex == mlSelectedModentry);
			const cVector2f vElemPos = kModsBgPos + cVector2f(30, 50 + (kModsSlotsSpacing * lItemIndex));
		
			uint32 lProviderIndex = cLux_GetModHandler().GetProviderIndexFromModID(mvModIDs[i]);
			const tString sProvider = vsProviderIcons[lProviderIndex];
			if (OptionMenu_ButtonMod(sItemNameBase + cString_ToString(lItemIndex), mvModNames[i], vElemPos, bSelected, sProvider, mfTransitionAlpha, false))
			{
				mlModEntryToLoad = i;
				mbShowSelectedModDialog = true;
				msMessageBoxFocus = "No";
				msFocusNextFrame="No";
				cLux_AddDebugMessage("mlModEntryToLoad: " + mlModEntryToLoad);
			}
			
			if (bMouseDown==false && ImGui_PrevInFocus())
					mlSelectedModentry = lItemIndex; 

			lItemIndex++;
		}
		
		//////////////////////////////////////////////////////////////////
		// SCROLLING
		const bool bDrawWorkshopBtn = cLux_GetModHandler().GetProviderIsAvailable("SteamWorkshop");
		int lTotalListEntryCount = mvModIDs.size() + mvDownloadingModIDs.size();
		
		if(lActionVertical != 0)
		{
			if (mfTransitionAlpha == 1) 
				Sound_PlayGui("special_fx/frontend/frontend_menu_slider", 1.0f, eSoundEntryType_Gui);
			
			if(lActionVertical < 0) // Move up
			{
				//cLux_AddDebugMessage("UP");
				if(lActionVertical == -1)
				{
					if (mlSelectedModentry > lMaxItems) // Workshop button
					{
						mlSelectedModentry = lMaxItems;
					}
					else if (mlSelectedModentry == lMaxItems) // Back button
					{
						mlSelectedModentry = cMath_Min(lTotalListEntryCount - 1, lMaxItems - 1);
					}
					else
					{
						mlSelectedModentry--;
						
						if(mlSelectedModentry < 0)
						{
							if(mlModEntryOffset > 0) 
							{
								mlSelectedModentry = 0;
								mlModEntryOffset--;
							}
							else
							{
								mlSelectedModentry = lMaxItems+1;
							}
						}
					}
				}
				else
				{
					// Scrolling with Wheel
					if(mlModEntryOffset > 0) 
						mlModEntryOffset--;
				}
			}
			else	// Move down
			{
				//cLux_AddDebugMessage("DOWN");
				if(lActionVertical==1)
				{
					if (mlSelectedModentry > lMaxItems) // workshop button
					{
						mlSelectedModentry = 0;
					}
					else if (mlSelectedModentry == lMaxItems) // back button
					{
						mlSelectedModentry++;
					}
					else
					{
						mlSelectedModentry++;
						
						if(mlSelectedModentry >= cMath_Min(lTotalListEntryCount, lMaxItems) )
						{
							if(mlModEntryOffset < lTotalListEntryCount - lMaxItems) 
							{
								mlSelectedModentry--;
								mlModEntryOffset++;
							}
							else
							{
								///////////
								// No more files, scroll to workshop button
								mlSelectedModentry = lMaxItems;
							}
						}
					}
				}
				else
				{
					// Scrolling with Wheel
					if(mlModEntryOffset < lTotalListEntryCount - lMaxItems) 
						mlModEntryOffset++;
				}
			}
			
		}
		
		//////////////////////////////////////////////////////////////////
		// SCROLL BAR
		const cVector2f vModsScrollPos = vModListFramePos + cVector2f(385, 0);	
		const cVector2f vModsScrollSize = cVector2f(17, vModListFrameSize.y);

		cImGuiGfx gfxScrollBar = cImGuiGfx("startmenu_scrollbar_widget.tga", eImGuiGfx_Texture);
		gfxScrollBar.mColor = cColor(1, mfTransitionAlpha);
		
		if(lTotalListEntryCount > lMaxItems)
		{
			// Update input
			float fFiles = lTotalListEntryCount;
			
			int lOldOffset = mlModEntryOffset;
			const float fPadding = mbScrollingModsList ? 1000 : 5;
			float fMouseScrollY = OptionMenu_GetMouseInside(vModsScrollPos - cVector2f(fPadding, 0), vModsScrollPos + vModsScrollSize + cVector2f(fPadding, 0)).y;
			
			// Mouse touching scroll, check if button pressed
			if(fMouseScrollY != -1.0 && bMouseDown)
			{
				mlModEntryOffset = cMath_RoundToInt((fFiles-lMaxItems) * fMouseScrollY);
				mbScrollingModsList = true;
			}

			if(bMouseDown == false)
			{
				// Stopped scrolling
				mbScrollingModsList = false;
			}
			
			mlModEntryOffset = cMath_Clamp(mlModEntryOffset, 0, lTotalListEntryCount - lMaxItems);
			if(mlSelectedModentry >= 0 && mlSelectedModentry < lMaxItems && (mlModEntryOffset - lOldOffset) != 0)
			{
				const int lDiff = (mlModEntryOffset - lOldOffset);
				mlSelectedModentry = cMath_Clamp(mlSelectedModentry - lDiff, 0, 9);
			}

			const float fScaleY = 1.0 - (fFiles - lMaxItems) / fFiles;
			float fPosY = 0;
			if (fFiles > lMaxItems)
				fPosY = mlModEntryOffset / (fFiles-lMaxItems);
			
			const cColor scrollBarColor = cColor(1, mfTransitionAlpha);
			const cVector2f vScrollBarSize = OptionMenu_GetScaledSize(vModsScrollSize * cVector2f(1, fScaleY));
			const cVector3f vScrollBarPos = OptionMenu_GetTopLeftOffset(vModsScrollPos + vModsScrollSize * cVector2f(0, (1.0 - fScaleY) * fPosY), 0.01);
			
			ImGui_DrawGfx(gfxScrollBar, vScrollBarPos, vScrollBarSize, scrollBarColor);
		}
		
		// Define the mod index for printing img and detail txt.
		int lModIndToShow = (mlSelectedModentry + mlModEntryOffset) - mvDownloadingModNames.size();
		
		//////////////////////////////////////////////////////////////////
		// MOD IMG
		const cVector2f vModImgPos = kModsBgPos + cVector2f(420, 30);
		const float fModImgHeight = kModsBgSize.y * 0.356;
		const cVector2f vModImgSize = cVector2f(fModImgHeight * 2.13, fModImgHeight) * 0.88;
		const bool bShouldShowModDetails = (lModIndToShow >= 0 && mvModIDs.size() > 0 && mlSelectedModentry < lMaxItems);
		
		// Mod img frame
		cImGuiGfx gfxModImgFrame = cImGuiGfx("startmenu_frame_load.tga", eImGuiGfx_Texture);
		gfxModImgFrame.mColor = cColor(1,fPageFrameAlpha);
		ImGui_DrawGfx(gfxModImgFrame, OptionMenu_GetTopLeftOffset(vModImgPos, 0.8f), OptionMenu_GetScaledSize(vModImgSize));
		
		// Mod Img
		if(bShouldShowModDetails && mvModPics[lModIndToShow]!="")
		{
			cImGuiGfx gfxModPic = cImGuiGfx(mvModPics[lModIndToShow], eImGuiGfx_Texture);
			gfxModPic.mColor = cColor(1,mfTransitionAlpha);
			ImGui_DoImage(gfxModPic, OptionMenu_GetTopLeftOffset(vModImgPos + cVector2f(5,2), 0.5), OptionMenu_GetScaledSize(vModImgSize * 0.97));
		}
		
		//////////////////////////////////////////////////////////////////
		// MOD DESC
		
		//Frame
		cImGuiGfx gfxModDescFrame = cImGuiGfx("startmenu_frame_load.tga", eImGuiGfx_Texture);
		gfxModDescFrame.mColor = cColor(1,fPageFrameAlpha);
		cVector2f vModDescFramePos = kModsBgPos + cVector2f(420, 210);
		cVector2f vModDescFrameSize = cVector2f(kModsBgSize.x * 0.467, kModsBgSize.y * 0.485);
		ImGui_DrawGfx(gfxModDescFrame, OptionMenu_GetTopLeftOffset(vModDescFramePos, 0.8f), OptionMenu_GetScaledSize(vModDescFrameSize));
		
		if (bShouldShowModDetails)
		{
			//Author
			ImGui_LayoutBegin(eImGuiLayout_X);
			{
				cImGuiLabelData labelData;
				labelData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu,56));
				labelData.mFont.mvSize = cVector2f(28, 28);
				labelData.mFont.mColor = gTextCol_Dark*cColor(1, mfTransitionAlpha);
				labelData.mFontAlign = eFontAlign_Right;
				cVector2f vAuthorLabelPos = vModDescFramePos + cVector2f(20, 20);
				ImGui_SetTransCategory("ModMenu");
				ImGui_DoLabelExt("ByAuthor", labelData, OptionMenu_GetTopLeftOffset(vAuthorLabelPos, 0.5));
				ImGui_SetTransCategory("");
				ImGui_DoLabelExt(": " + cString_To8Char(mvModAuthors[lModIndToShow]), labelData, OptionMenu_GetTopLeftOffset(vAuthorLabelPos, 0.5));
			}
			ImGui_LayoutEnd();
			
			// Description
			ImGui_SetTransCategory("ModDescriptions");
			cImGuiTextFrameData txtData;
			txtData.mbUseBackgroundGfx = false;
			txtData.mFont.mvSize = cVector2f(23, 23);
			txtData.mFont.mColor = gTextCol_Dark * cColor(1, mfTransitionAlpha);
			cVector2f vTxtFramePos =  vModDescFramePos + cVector2f(20, 50);
			cVector2f vModDescSize = cVector2f(kModsBgSize.x * 0.39, kModsBgSize.y * 0.38);
			tString sDescTxt = "" + mvModIDs[lModIndToShow];
			ImGui_DoTextFrameExt(sDescTxt, cVector2f(0), 0.f, 0.f, txtData, OptionMenu_GetTopLeftOffset(vTxtFramePos, 0.5), OptionMenu_GetScaledSize(vModDescSize));
		}
		
		//////////////////////////////////////////////////////////////////
		// Post mods list btn selection
		tString sSelectedBtn = sItemNameBase + cString_ToString(mlSelectedModentry);
		if (mlSelectedModentry >= lMaxItems)
			sSelectedBtn = (mlSelectedModentry == lMaxItems && bDrawWorkshopBtn) ? "BrowseWorkshop" : "Back";
			
		//////////////////////////////////////////////////////////////////
		// WORKSHOP BTN 
		if (bDrawWorkshopBtn)
		{
			ImGui_SetTransCategory("ModMenu");
			if (OptionMenu_ButtonModOptions("BrowseWorkshop", kModsBgPos + cVector2f(32, 485), sSelectedBtn, false, mfTransitionAlpha))
			{
				//cLux_AddDebugMessage("Browse Steam Workshop");
				cLux_GetModHandler().OpenContentAcquisitionWindow("SteamWorkshop");
				
				return;
			}
			
			if(bMouseDown == false && ImGui_PrevBecameInFocus())
				mlSelectedModentry = lMaxItems;
		}
		
		ImGui_SetTransCategory("Menu");
		
		//////////////////////////////////////////////////////////////////
		// BACK BTN
		bool bBackButton = OptionMenu_ButtonModOptions("Back", kModsBgPos + cVector2f(32, 520), sSelectedBtn, false, mfTransitionAlpha);
		bool bBackGamepad = ImGui_ActionTriggered(eImGuiAction_Cancel, true);
		
		if(bBackButton || bBackGamepad)
		{
			cLux_GetModHandler().CleanUpListing();
			
			mTargetGroup = eMainMenuGroup_Main;
			//mCurrentGroup = eMainMenuGroup_Main;
			msFocusNextFrame = msSelectedMainMenuButton;
			
			if (ImGui_TimerExists("TransitionOut") == false)
					ImGui_AddTimer("TransitionOut", 10);
			
			// Reset menu pos
			if(bBackGamepad == false)
			{
				mlSelectedModentry = 0;
				OptionMenu_ShowGamepadButtons(false);
			}
			
			return;
		}
		
		if(bMouseDown == false && ImGui_PrevBecameInFocus())
			mlSelectedModentry = lMaxItems +1;
		
		//////////////////////////////////////////////////////////////////
		// Manual focus
		if(mbShowSelectedModDialog == false)
		{
			if(mlSelectedModentry >= 0 && mlSelectedModentry < lMaxItems)
				msFocusNextFrame = sItemNameBase + cString_ToString(mlSelectedModentry);
			else
				msFocusNextFrame = (mlSelectedModentry == lMaxItems) ? "BrowseWorkshop" : "Back";
		}
		
		//////////////////////////////////////////////////////////////////
		// THE END
		GuiHandleTransition(0.05f, 0.025f, mTargetGroup, msTargetFocus);
		
		if (mbShowSelectedModDialog==false)
			OptionMenu_ShowGamepadButtons(false);
	}
	
	//-------------------------------------------------------
	
	float mfPreMenuFadeDestMin = -0.1f; // Negative value to have short pause between phases
	
	void GuiPreMenu(float afTimeStep)
	{		
		//cLux_AddDebugMessage("FIRST: "+mbFirstGameStart+ "SHOW PRE: "+mbShowPreMenu+" PREPHASE: "+mPreMenuPhase+" ");
		//cLux_AddDebugMessage("PHASE: "+mPreMenuPhase);
		///////////////////////
		// Init
		if(mbInitPreMenu)
		{
			mbInitPreMenu = false;
			mfPreMenuFadeAmount=1;
			mfPreMenuFadeDest=mfPreMenuFadeDestMin;
			
			mPreMenuPhase = ePreMenuPhase_None;
			mlPreMenuState=-1;
			
			mbBackgroundShowTitle = false;
		}
		
		///////////////////////
		// Fade in/out
		if(mfPreMenuFadeAmount<1 && mfPreMenuFadeDest<1 && mPreMenuPhase < ePreMenuPhase_Gamma)
			ImGui_SetModUseInput(false);
			
		float fMul;
		if (mfPreMenuFadeDest > mfPreMenuFadeDestMin)
		{
			// Fade in
			if (mPreMenuPhase == ePreMenuPhase_FrictionalLogo)
				fMul = 0.45;
			else if (mPreMenuPhase == ePreMenuPhase_FmodLogo)
				fMul = 0.5f;
			else
				fMul = 1.0f;
		}
		else
		{
			// Fade out
			if (mPreMenuPhase == ePreMenuPhase_FrictionalLogo)
				fMul = 0.6;
			else if (mPreMenuPhase == ePreMenuPhase_FmodLogo)
				fMul = 0.7f;
			else
				fMul = 0.6f;
		}
		
		
		////////////
		// Skip Logo - Wait for keypress
		tString sKeyPressed = cLux_GetInputHandler().GetLatestKeyPressed();
		
		// Only allow skip during logo phases
		if(mPreMenuPhase==ePreMenuPhase_FrictionalLogo || mPreMenuPhase==ePreMenuPhase_FmodLogo)
		{
			if(sKeyPressed.length() > 0)
			{
				ImGui_StopTimer("FGLogoOver");
				ImGui_StopTimer("FModLogoOver");
				mfPreMenuFadeDest = mfPreMenuFadeDestMin;
			}
		}

		mfPreMenuFadeAmount	= cMath_IncreaseTo(mfPreMenuFadeAmount, afTimeStep*fMul, mfPreMenuFadeDest);
		
		if(mfPreMenuFadeAmount<=mfPreMenuFadeDestMin && mfPreMenuFadeDest==mfPreMenuFadeDestMin)
		{
			mPreMenuPhase++;
			mlPreMenuState++;
			mfPreMenuFadeDest =1;	

			//cLux_AddDebugMessage("FIRST: "+mbFirstGameStart+ "SHOW PRE: "+mbShowPreMenu+" PREPHASE: "+mPreMenuPhase+" ");
			
			if(mPreMenuPhase==ePreMenuPhase_Init)
			{
			}

			if(mPreMenuPhase == ePreMenuPhase_PressToContinue)
			{
				if(mbShowPressX)
				{
					////////////
					// Display press to continue
					cLux_AddDebugMessage("[PRE-MENU] PRESS TO CONTINUE");
				}
				else
				{
					////////////
					// Skip this on PC
					mPreMenuPhase++;
					mlPreMenuState++;
				}
			}
			
			if(mPreMenuPhase==ePreMenuPhase_None)
			{
				
				cLux_AddDebugMessage("[PRE-MENU] INIT");
				cLux_AddTodoMessage("Sound: Menu stinger");
				//Sound_PlayGui("special_fx/frontend/FG_Menu_Sting", 1.0f, eSoundEntryType_Gui);
				//Music_PlayExt("IngameMenu_Music", true, 0.45f, 0.8f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
				cLux_AddTodoMessage("Sound: Menu background noise");
				
			}
	
			if(mPreMenuPhase==ePreMenuPhase_FrictionalLogo)
			{
				cLux_AddDebugMessage("[PRE-MENU] LOGO");
				if(mpConfig.GetBool("Game", "SkipLogo", false))
				{
					mbMouseVisible = true;
					mPreMenuPhase = ePreMenuPhase_Gamma;
				}
				else
				{
					ImGui_AddTimer("FGLogoOver", 3.2f);
					mbMouseVisible = true;
					Sound_PlayGui("special_fx/frontend/FG_Menu_Sting", 1.0f, eSoundEntryType_Gui);
				}
				/*
				if(mbShowPressX)
				{
					cLux_AddTodoMessage("Sound: Menu background noise");
					//Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
				}
				else
				{
					//mPreMenuPhase++;
					//mlPreMenuState++;
				}
				*/
			}
			
			if(mPreMenuPhase==ePreMenuPhase_FmodLogo)
			{
				cLux_AddDebugMessage("[PRE-MENU] FMOD LOGO");
				ImGui_AddTimer("FModLogoOver", 2.5f);
				mbMouseVisible = true;
			}
		
			if(mPreMenuPhase==ePreMenuPhase_Welcome) // WELCOME
			{
				cLux_AddDebugMessage("[PRE-MENU] WELCOME");
				if(mbFirstGameStart && mbShowPreMenu)
				{
					cLux_AddTodoMessage("Sound: Menu background noise");
					//Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
				}
				else
				{
					mPreMenuPhase = ePreMenuPhase_FinalFade;
                    
					//Music_PlayExt("Menu_Music", true, mfMenuMusicVol, 1.0f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
					
					cLux_AddTodoMessage("Sound: Menu background noise");
					//Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
					
					//return;//So we do not show the gamma setup!
				}
			}
			
			if(mPreMenuPhase==ePreMenuPhase_Gamma)
			{
				cLux_AddDebugMessage("[PRE-MENU] GAMMA");
				
				/*if(mbFirstGameStart && mbShowPreMenu)
				{
					mPreMenuPhase = ePreMenuPhase_FinalFade;
				}*/
				
				if(mbFirstGameStart && mbShowPreMenu)
				{
					//Music_PlayExt("IngameMenu_Music", true, 0.35f, 0.8f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
					cLux_AddTodoMessage("Sound: Menu background noise");
					//Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
				}
				else
				{
					cLux_AddTodoMessage("IM GOING TO FINAL FADE");
					mPreMenuPhase = ePreMenuPhase_FinalFade;
					//Music_PlayExt("Menu_Music", true, mfMenuMusicVol, 1.0f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
					msFocusNextFrame = msSelectedMainMenuButton;					
					//return;//So we do not show the gamma setup!
				}
			}
			
			if(mPreMenuPhase==ePreMenuPhase_FinalFade)
			{
				cLux_AddDebugMessage("[PRE-MENU] FINAL FADE");
				mfPreMenuFadeAmount = 1;
				//Music_PlayExt("Menu_Music", true, mfMenuMusicVol, 1.0f, 6.0f, 0.0f, eMusicPrio_OverrideAll, false);
				msFocusNextFrame = msSelectedMainMenuButton;
			}
			
			if(mPreMenuPhase==ePreMenuPhase_Done)
			{
				
				cLux_AddDebugMessage("[PRE-MENU] DONE ");
				
				if(Sound_GuiIsPlaying("special_fx/frontend/FG_Menu_Sting"))
				{
					Sound_StopGui("special_fx/frontend/FG_Menu_Sting", 1.0f);
				}
				
				if (mbFirstGameStart == false && mbPremenuActive == true && ImGui_TimerExists("TransitionIn") == false)
				{
					cLux_AddDebugMessage("I AM CREATING THIS FADE");
					ImGui_AddTimer("TransitionIn",10); // THIS CREATES A DOUBLE FADE ON START
				}
				cLux_AddTodoMessage("Sound: Menu background noise");
				
				mbFirstGameStart = false;
				mpConfig.SetBool("Main", "FirstGameStart", mbFirstGameStart);
				
				mbPremenuActive = false;
				mbBackgroundShowTitle = true;
				mbPremenuActive = false;
				Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
				//Sound_CreateAtEntity("MenuBGNoise", "special_fx/frontend/main_menu_bg", "Player", 6.0f, false, 1.0f);
			}
		}
		
		///////////////////////
		// Black screen
		if(mPreMenuPhase==ePreMenuPhase_None)
		{
			cImGuiGfx gfxBlack;
			ImGui_DrawGfx(gfxBlack, ImGui_FullScreenPos(0.1), ImGui_FullScreenSize(), cColor(0,1));
		}
		///////////////////////
		// FG Logo
		if(mPreMenuPhase==ePreMenuPhase_FrictionalLogo)
		{			
			cImGuiGfx gfxBlack;
			ImGui_DrawGfx(gfxBlack, ImGui_FullScreenPos(0.1), ImGui_FullScreenSize(), cColor(0,1));
			//cImGuiGfx gfx("frictional_games_logo.dds", eImGuiGfx_Texture);
			//cVector2f vBgSize = OptionMenu_GetScaledSize(cVector2f(900, 351));
			cImGuiGfx gfxFG("frictional_games_logo_color.png", eImGuiGfx_Texture);
			cVector2f vBgSize = OptionMenu_GetScaledSize(cVector2f(1000, 343)*0.6f);
			cVector3f vBgPos = OptionMenu_GetCenterOffset(cVector2f(0), 10.2) - cVector3f(vBgSize.x * 0.5, vBgSize.y * 0.5, 0.0);
			ImGui_DrawGfx(gfxFG, vBgPos, vBgSize, cColor(1, mfPreMenuFadeAmount));
			
			/*cImGuiGfx gfxNewton("newton_logo.png", eImGuiGfx_Texture);
			cImGuiGfx gfxFMod("fmod_logo.png", eImGuiGfx_Texture);
			cImGuiGfx gfxAnnosoft("annosoft_logo.png", eImGuiGfx_Texture);
			cVector2f vLicenseLogoSize = OptionMenu_GetScaledSize(cVector2f(728, 192)*0.3f);
			cVector3f vLicenseLogoPos = OptionMenu_GetCenterOffset(cVector2f(0), 10.2) - cVector3f(vLicenseLogoSize.x * 0.5, vLicenseLogoSize.y * 0.5, 0.0);
			
			cLux_AddDebugMessage("CENTER: "+vLicenseLogoPos);
			
			ImGui_DrawGfx(gfxNewton, vLicenseLogoPos+cVector3f(-vLicenseLogoPos.x * 0.70f, vLicenseLogoPos.y*0.6f, 0), vLicenseLogoSize, cColor(1, mfPreMenuFadeAmount));
			ImGui_DrawGfx(gfxFMod, vLicenseLogoPos+cVector3f(0, vLicenseLogoPos.y*0.6f, 0), vLicenseLogoSize, cColor(1, mfPreMenuFadeAmount));
			ImGui_DrawGfx(gfxAnnosoft, vLicenseLogoPos+cVector3f(vLicenseLogoPos.x * 0.70f, vLicenseLogoPos.y*0.6f, 0), vLicenseLogoSize, cColor(1, mfPreMenuFadeAmount));*/
			
			//loadscreen_mask
			
			if(ImGui_TimerOver("FGLogoOver"))
			{
				mfPreMenuFadeDest = mfPreMenuFadeDestMin;
			}
		}
		///////////////////////
		// Fmod Logo
		if(mPreMenuPhase==ePreMenuPhase_FmodLogo)
		{			
			cImGuiGfx gfxBlack;
			ImGui_DrawGfx(gfxBlack, ImGui_FullScreenPos(0.1), ImGui_FullScreenSize(), cColor(0,1));
			
			/*cVector3f vBgCenter = cVector3f(kScreenCenter.x,kScreenCenter.y,0);
			cImGuiGfx gfx("fmod_logo.png", eImGuiGfx_Texture);
			cVector2f vBgSize = OptionMenu_GetScaledSize(cVector2f(728, 192) * 0.3f);
			cVector3f vBgPos = OptionMenu_GetCenterOffset(cVector2f(0), 10.2) - cVector3f(vBgSize.x * 0.5, vBgSize.y * 0.5, 0.0);
			ImGui_DrawGfx(gfx, vBgPos, vBgSize, cColor(1, mfPreMenuFadeAmount));*/
			//ImGui_DrawAlignedGfx(gfx, cVector3f(vBgCenter.x,vBgCenter.y,9990), eImGuiAlign_CenterCenter, cVector2f(300,300));
			
			cImGuiGfx gfxNewton("newton_logo.png", eImGuiGfx_Texture);
			cImGuiGfx gfxFMod("fmod_logo.png", eImGuiGfx_Texture);
			cImGuiGfx gfxAnnosoft("annosoft_logo.png", eImGuiGfx_Texture);
			cVector2f vLicenseLogoSize = OptionMenu_GetScaledSize(cVector2f(728, 192)*0.3f);
			cVector3f vLicenseLogoPos = OptionMenu_GetCenterOffset(cVector2f(0), 10.2) - cVector3f(vLicenseLogoSize.x * 0.5, vLicenseLogoSize.y * 0.5, 0.0);
			
			ImGui_DrawGfx(gfxNewton, vLicenseLogoPos+cVector3f(-vLicenseLogoPos.x * 0.70f, 0, 0), vLicenseLogoSize, cColor(1, mfPreMenuFadeAmount));
			ImGui_DrawGfx(gfxFMod, vLicenseLogoPos+cVector3f(0, 0, 0), vLicenseLogoSize, cColor(1, mfPreMenuFadeAmount));
			ImGui_DrawGfx(gfxAnnosoft, vLicenseLogoPos+cVector3f(vLicenseLogoPos.x * 0.70f, 0, 0), vLicenseLogoSize, cColor(1, mfPreMenuFadeAmount));
			
			if(ImGui_TimerOver("FModLogoOver"))
			{
				mfPreMenuFadeDest = mfPreMenuFadeDestMin;
			}
		}
		///////////////////////
		// Declaration of intent
		else if(mPreMenuPhase==ePreMenuPhase_Welcome)
		{
			//cLux_AddDebugMessage("WELCOME");
			GuiWelcomeMessages();
		}
		///////////////////
		// Press to continue
		else if(mPreMenuPhase == ePreMenuPhase_PressToContinue)
		{
			cImGuiGfx gfxBlack;
			ImGui_DrawGfx(gfxBlack, ImGui_FullScreenPos(0.1), ImGui_FullScreenSize(), cColor(0,1));
			
			cImGuiGfx gfxSide("insta_square.png", eImGuiGfx_Texture);
			cVector3f vFacePos = OptionMenu_GetTopLeftOffset(cVector2f(960, 360), 2.0f);
			ImGui_DrawAlignedGfx(gfxSide, vFacePos, eImGuiAlign_CenterCenter, OptionMenu_GetScaledSize(cVector2f(500, 500)), cColor(1, mfPreMenuFadeAmount));

			GuiPressX();
		}
		///////////////////////
		// Gamma
		else if(mPreMenuPhase==ePreMenuPhase_Gamma)
		{
			// Show profile save error
			if(msLoadSaveError.length() > 0)
			{
				MessageBoxLoadError();
				ImGui_SetModUseInput(false); 
			}
			
			cImGuiGfx gfxBlack;
			ImGui_DrawGfx(gfxBlack, ImGui_FullScreenPos(0.1), ImGui_FullScreenSize(), cColor(0,1));
			GuiOptionsGamma();		
		}
		else if(mPreMenuPhase==ePreMenuPhase_FinalFade)
		{
			mfPreMenuFadeDest = mfPreMenuFadeDestMin;
			cImGuiGfx gfxBlack;
			ImGui_DrawGfx(gfxBlack, ImGui_FullScreenPos(0.1), ImGui_FullScreenSize(), cColor(0,mfPreMenuFadeAmount));
			mfTransitionAlpha = 0;
		}
		else if(mPreMenuPhase==ePreMenuPhase_Done)
		{
		}
		
	}
	
	//------------------------------------------------------
		
	void GuiPressX()
	{
		cImGuiLabelData labelData;
		labelData.mFont.SetFile(FontHandler_GetFont(eFontType_MainMenu, 72));
		labelData.mFont.mvSize = cVector2f(46, 46);
		labelData.mFont.mColor = cColor(1, mfPreMenuFadeAmount);
		ImGui_SetTransCategory("Menu");
		ImGui_DoLabelExt("PressX",labelData, OptionMenu_GetTopLeftOffset(kOptionMenu_PressXPos, 4.0));
				
		////////////
		// Wait for keypress
		tString sKeyPressed = cLux_GetInputHandler().GetLatestKeyPressed();

		if(sKeyPressed.length() > 0)
		{
			int lPos = cString_GetFirstStringPos(sKeyPressed, "Gamepad");
			int lEndPos = cString_GetFirstStringPos(sKeyPressed, "Button.0");
			if(lPos != -1 && lEndPos != -1)
			{
				/////////////////
				// Get the device id from the gamepad that pressed the button
				tString sNum = cString_Sub(sKeyPressed, 8);
				int lDotPos = cString_GetFirstCharPos(sNum, '.');
				int lNum = cString_ToInt(cString_Sub(sNum, 0, lDotPos), 0 );

				/////////////
				// Set that gamepad as the primary one
				cLux_GetInputHandler().SetPrimaryGamepad(lNum);

				mfPreMenuFadeDest=mfPreMenuFadeDestMin;
			}
		}
		ImGui_SetTransCategory("");
	}
	
	//-------------------------------------------------------
	
	bool mbWelcomeScreen = false;
	float mfWelcomeScreenTransparency = 0;
	int mlWelcomeMessageIndex = 0;
	float mfPromptTransparency = 0;
	float mfWelcome1_Transparency = 0;
	float mfWelcome2_Transparency = 0;
	float mfWelcome3_Transparency = 0;
	
	void GuiWelcomeMessages()
	{
		if (mbWelcomeScreen == false) return;
		
		mfPreMenuFadeAmount = 1;
		cLux_AddDebugMessage("WELCOME phase: "+mlWelcomeMessageIndex+" TRANS "+mfWelcome1_Transparency);
		float fWaitTime;
		switch (mlWelcomeMessageIndex)
		{	
			case 0:
				mfWelcomeScreenTransparency = cMath_IncreaseTo(mfWelcomeScreenTransparency,0.02f,1);
				fWaitTime = 1.5f;
				break;
			case 1:
				fWaitTime = 3.5f;
				mfWelcome1_Transparency = cMath_IncreaseTo(mfWelcome1_Transparency,0.02f,1);
				break;
			case 2:
				fWaitTime = 2.8f;
				mfWelcome2_Transparency = cMath_IncreaseTo(mfWelcome2_Transparency,0.05f,1);
				break;
			case 3:
				mfWelcome3_Transparency = cMath_IncreaseTo(mfWelcome3_Transparency,0.05f,1);
				fWaitTime = 2.8f;
				break;
			case 4:
				mfPreMenuFadeDest = mfPreMenuFadeDestMin;
				break;
		}
		
		if (ImGui_TimerExists("IncreaseIndex") == false)
			ImGui_AddTimer("IncreaseIndex",fWaitTime);
			
		if (ImGui_TimerOver("IncreaseIndex"))
		{
			if (mlWelcomeMessageIndex < 4)
				mlWelcomeMessageIndex++;
			else if (mlWelcomeMessageIndex == 4)
			{
				if (mfWelcomeScreenTransparency > 0)
					mfWelcomeScreenTransparency -= 0.02f;
				else
				{
					StartNewGame();
					mbWelcomeScreen = false;
					mlWelcomeMessageIndex++;
				}
			}
		}
		
		/*if (mfPromptTransparency == 0 && ImGui_TimerExists("PromptTransparency") == false)
			ImGui_AddTimer("PromptTransparency", 2.5f);
			
		if (ImGui_TimerOver("PromptTransparency"))
			mfPromptTransparency = 1;*/
				
		cVector2f vSize = cVector2f(1600,768);
		cVector3f vBgCenter = cVector3f(kScreenCenter.x,kScreenCenter.y,0);
		
		cImGuiGfx gfxBlack;
		ImGui_DrawGfx(gfxBlack, ImGui_FullScreenPos(2), ImGui_FullScreenSize(), cColor(0,1));
		
		cImGuiGfx gfx("loadscreen_mask.dds", eImGuiGfx_Texture);
		cVector2f vBgSize = OptionMenu_GetScaledSize(cVector2f(2048, 1152)*0.6f);
		cVector3f vBgPos = OptionMenu_GetCenterOffset(cVector2f(0), -1) - cVector3f(vBgSize.x * 0.5f, vBgSize.y * 0.5f, 0.0f);
		ImGui_DrawGfx(gfx, vBgPos, vBgSize, cColor(1, mfWelcomeScreenTransparency));
		//ImGui_DrawAlignedGfx(gfx, cVector3f(vBgCenter.x,vBgCenter.y,1), eImGuiAlign_CenterCenter,vSize);
		
		ImGui_GroupBegin(cVector3f(0,0,10), cVector2f(kScreenCenter.x,600));
		
		cImGuiTextFrameData textData = ImGui_GetDefaultTextFrame();
		textData.mFont.SetFile(FontHandler_GetFont(eFontType_Credits, 56));
		textData.mFont.mvSize = cVector2f(24, 24);
		float fLineHeight = textData.mFont.mvSize.y*1.2f;
		
		textData.mFontAlign = eFontAlign_Center;
		textData.mbUseBackgroundGfx = false;
		
		ImGui_SetTransCategory("PreMenu");
		textData.mFont.mColor = cColor(1, mfWelcome1_Transparency*mfWelcomeScreenTransparency);
		ImGui_DoTextFrameExt("WelcomeMessage01", cVector2f_Zero, 6, 0, textData, ImGui_NrmPosGroup(cVector3f(0.5f,0.8f,20)), ImGui_NrmSizeGroup(1));
		textData.mFont.mColor = cColor(1, mfWelcome2_Transparency*mfWelcomeScreenTransparency);
		ImGui_DoTextFrameExt("WelcomeMessage02", cVector2f_Zero, 6, 0, textData, ImGui_NrmPosGroup(cVector3f(0.5f,0.8f,20))+cVector3f(0,fLineHeight,0), ImGui_NrmSizeGroup(1));
		textData.mFont.mColor = cColor(1, mfWelcome3_Transparency*mfWelcomeScreenTransparency);
		ImGui_DoTextFrameExt("WelcomeMessage03", cVector2f_Zero, 6, 0, textData, ImGui_NrmPosGroup(cVector3f(0.5f,0.8f,20))+cVector3f(0,fLineHeight*2.0f,0), ImGui_NrmSizeGroup(1));
		ImGui_SetTransCategory("");
			
		ImGui_GroupEnd();
		
		
		////////////
		// Wait for keypress
		/*tString sKeyPressed = cLux_GetInputHandler().GetLatestKeyPressed();

		if(sKeyPressed.length() > 0)
		{
			int lPos = cString_GetFirstStringPos(sKeyPressed, "Gamepad");
			int lEndPos = cString_GetFirstStringPos(sKeyPressed, "Button.0");
			if(lPos != -1 && lEndPos != -1)
			{
				/////////////////
				// Get the device id from the gamepad that pressed the button
				tString sNum = cString_Sub(sKeyPressed, 8);
				int lDotPos = cString_GetFirstCharPos(sNum, '.');
				int lNum = cString_ToInt(cString_Sub(sNum, 0, lDotPos), 0 );

				/////////////
				// Set that gamepad as the primary one
				cLux_GetInputHandler().SetPrimaryGamepad(lNum);
				
				if (mlWelcomeMessageIndex < 3)
					mlWelcomeMessageIndex++;
				else
					mfPreMenuFadeDest = mfPreMenuFadeDestMin;

				mfPromptTransparency = 0;
				ImGui_StopTimer("PromptTransparency");
			}
			else if (sKeyPressed == "MouseButton.LeftMouse")
			{
				if (mlWelcomeMessageIndex < 3)
					mlWelcomeMessageIndex++;
				else
					mfPreMenuFadeDest = mfPreMenuFadeDestMin;
					
				mfPromptTransparency = 0;
				ImGui_StopTimer("PromptTransparency");
			}
		}*/
		
		
	}

	//------------------------------------------------------
	
	void ApplySettings(bool abSave = true)
	{
		/////////////
		// Saves the config
		if(abSave && cLux_GetSaveConfigAtExit()) mpConfig.Save();

		/////////////
		// Applies the changes to the engine and displays a message box if restart is needed
		mbRestartWarning = cLux_ApplyUserConfig();
	}

	void DiscardSettings()
	{
		///////////
		// Load settings
		mpConfig.Load();
		cGraphics_GetLowLevel().SetBrightness(mpConfig.GetFloat("Graphics", "Brightness", 1.0));
		cGraphics_GetLowLevel().SetGammaCorrection(mpConfig.GetFloat("Graphics", "Gamma", 1.0));
	}

	//------------------------------------------------------
	
	void ApplyKeybinds()
	{
		/////////////
		// Saves the config
		mpKeyConfig.Save();

		cLux_GetInputHandler().LoadKeyConfig();

		/////////////
		// Reloading keys will make actions trigger again, so ignore next frame
		mlIgnoreInput = 3;
		mbKeybindChanged = false;
		
		mTargetGroup = eMainMenuGroup_Options_Controls;
		msTargetFocus = msSelectedInputButton;
		mbShowApplyKeyChanges = false;
	}

	void DiscardKeybinds()
	{
		///////////
		// Load settings
		mpKeyConfig.Load();
		mbKeybindChanged = false;
		
		mTargetGroup = eMainMenuGroup_Options_Controls;
		msTargetFocus = msSelectedInputButton;
		mbShowApplyKeyChanges = false;
	}

	//------------------------------------------------------------
	
	void OnDraw(float afFrameTime)
	{
		
	}
	void OnPostRender(float afFrameTime)
	{
	
	}
	
	//------------------------------------------------------------
	
	/////////////////////////////////////////
	// ACTIONS
	/////////////////////////////////////////
	
	//------------------------------------------------------------
	
	int mlBlurID = -1;
	
	bool mbPauseSoundDelay = false;
	
	void OnAction(int alAction, bool abPressed)
	{
		if(abPressed)
		{
			if(alAction == eAction_OpenMenu && LoadScreen_IsVisible() == false && Sketchbook_IsOpen() == false && mbPauseMenuEnabled && cLux_GetCurrentMap()!=null)
			{
				if(mbMenuActive == false)
				{
					// PAUSE
					mbMainMenuActive = false;
					SetMenuActive(true);
					mbPauseSoundDelay = true;
					
					
					if (mlBlurID == -1)
						mlBlurID = Effect_Blur_Start(1,0);
						//mlBlurID = Effect_DoF_Start(0.f, 0.1f, 1.0f, 0.f);
				}
				else
				{
					// UNPAUSE
					mbMenuButtonPressed = true;
					Sound_PlayGui("special_fx/frontend/unpause", 1.0f, eSoundEntryType_Gui);
					// This is duplicated when the player clicks on Return to game
					ResetBlur();
				}
			}
		}

		// Block all input
	}


	void OnAnalogInput(int alAnalogId, const cVector3f &in avAmount)
	{
	
	}
	
	//------------------------------------------------------------
	
	void OnExitPressed()
	{
	
	}
	
	//------------------------------------------------------------
	
	void AppGotInputFocus()
	{
	
	}
	void AppLostInputFocus()
	{
	
	}
	
	/////////////////////////////////////////
	// GLOBAL
	/////////////////////////////////////////
	
	//------------------------------------------------------------
		
	bool mbMainMenuActive = false;
	bool mbMenuActive = false;
	bool mbPauseMenuEnabled = true;
	bool mbMenuButtonPressed = false;
	bool mbCanContinue = false;
	bool mbGameOver = false;
	bool mbSaveLoadEnabled = true;
	
	//------------------------------------------------------------
		 
	bool mbRestartWarning = false;
	bool mbShowRestartWarning = false;
	bool mbShowApplyChanges = false;
	bool mbShowExit = false;
	bool mbShowPlayGo = false;
	bool mbShowNewGame = false;
	bool mbShowLoadGame = false;
	bool mbShowApplyKeyChanges = false;
	bool mbShowPreMenu = false;
	bool mbPremenuActive=false;
	bool mbFirstGameStart = false;
	bool mbShowReset = false;
	bool mbShowDuplicateKeys = false;
	bool mbShowPressX = false;
	float mfKeepDisplaySetting = 0.0f;
	bool mbShowDetectSettings = false;
	
	bool mbSaveAndExit = false;
	
	float mfPlayGoTimer = 0.0f;
	
	cImGuiFrameGfx mGfxFrame;
	//cImGuiWindowData mWindowData;
	
	tString msMessageBoxFocus = "No";
	
	[volatile] cConfigFile@ mpConfig;
	[volatile] cConfigFile@ mpKeyConfig;

	int mlActionHorizontal;
		
	int mlClickedPauseMenuButton;
	int mlClickedMainMenuButton;

	int mlCurrentResolution;
	tString msCurrentDisplayMode;

	tString msSelectedMainMenuButton;
	tString msSelectedStartButton;
	tString msSelectedPauseMenuButton;
	tString msSelectedOptionsButton;
	tString msSelectedGammaButton;
	tString msSelectedInputButton;
	tString msSelectedAccessibilityButton;
	tString msSelectedGraphicsButton;
	tString msSelectedInputMouseButton;
	tString msSelectedInputGamepadButton;
	tString msSelectedInputMappingButton;
	tString msSelectedVideoButton;
	tString msSelectedDisplayButton;
	tString msSelectedVideoPostEffectButton;
	tString msSelectedVideoWorldButton;
	tString msSelectedVideoGammaButton;
	tString msSelectedAudioButton;
	tString msSelectedSubtitlesButton;
	tString msSelectedGameplayButton;
	tString msSelectedDebugButton;
	int mlSelectedLoadButton = 0;
	int mlSelectedKeybindButton = 0;
	
	bool mbBackgroundTitleSounds =true;
	bool mbBackgroundShowTitle =false;
	float mfBackgroundTitleAlpha=0;
	
	float mfMainAlpha=1;
	
	bool mbMouseVisible=true;
	
	ePreMenuPhase mPreMenuPhase=ePreMenuPhase_Init;
	int mlPreMenuState=0;
	bool mbInitPreMenu = true;
	float mfPreMenuFadeAmount=0;
	float mfPreMenuFadeDest=0;

	int mlOptionChanges = 0;
	int mlCurrentOptionChange;

	float mfFadeOut = 0.0f;
	float mfFadeIn = 0.0f;
	
	float mfFadeLength = 2.f;
	float mfExitGameFadeLength = 1.0f;

	tString msFocusNextFrame;

	eMainMenuGroup mCurrentGroup;
	eMainMenuGroup mPrevGroup;

	cVector2f mvAspectRatio;
	cVector2f mvSize;
	cVector2f mvOffset;
	
	array<cVector2l> mvResolutionSizes;
	array<tString> mvResolutionValues;
	array<int> mvRefresh;
	array<tString> mvRefreshValues;
	int mlSelectedResolution;

	array<tWString> mvSaveNames;
	array<tString> mvSaveDates;
	array<tWString> mvSaveFiles;
	bool mbHasSaveFiles = false;
	int mlSaveFileOffset=0;
	int mlSaveFileToLoad=0;
	bool mbScrollingSaveList=false;
	tString msLoadSaveError;
	bool mbProfileError;
	tWString msPreviousSaveLoaded;
	tWString msContinueFile;

	array<tString> mvLangFiles;
	
	bool mbScrolling=false;
	int mlMenuOffset=0;

	float mfDisableEscapeCount = 1.0;
	
	float mfSubtitleBGOpacity = -1.0f;
	
	////////////////
	// Keybinding
	array<cBindableAction> mvActions;
	array<cBindableAction> mvGamepadActions;
	int mlActionToBind=0;
	tString msKeybindSlot = "Primary";
	bool mbScrollingKeybindList=false;
	int mlKeybindOffset=0;
	int mlKeybindFocusSlot = 0;
	tString msFocusAfterBind;
	bool mbKeybindChanged;
	int mlIgnoreInput = 0;
	tString msKeybindFirstState;
	bool mbBindingGamepad = false;
	[nosave] bool mbSavingGame = false;

	[nosave] bool mbClearTimersNextFrame = true;

	bool mbInitiated = false;
	
	//------------------------------------------------------------
}
